<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>对Rust生命周期的一些常见误解 - 子实</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="子实"><meta name="msapplication-TileImage" content="/img/avatar-o.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="子实"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="《PingCap的Rust训练课程5：异步编程》中提到的一篇好文，值得一看。"><meta property="og:type" content="article"><meta property="og:title" content="对Rust生命周期的一些常见误解"><meta property="og:url" content="https://zlotus.github.io/2022/12/24/common-rust-lifetime-misconceptions/"><meta property="og:site_name" content="子实"><meta property="og:description" content="《PingCap的Rust训练课程5：异步编程》中提到的一篇好文，值得一看。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zlotus.github.io/img/og_image.png"><meta property="article:published_time" content="2022-12-24T08:45:00.000Z"><meta property="article:modified_time" content="2023-03-25T12:16:00.000Z"><meta property="article:author" content="子实"><meta property="article:tag" content="Rust"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><meta property="twitter:creator" content="@Zealot_uS"><meta property="twitter:site" content="Zealot_uS"><link rel="publisher" href="+LotusQin"><meta property="fb:admins" content="qinzishi"><meta property="fb:app_id" content="qinzishi"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zlotus.github.io/2022/12/24/common-rust-lifetime-misconceptions/"},"headline":"对Rust生命周期的一些常见误解","image":["https://zlotus.github.io/img/og_image.png"],"datePublished":"2022-12-24T08:45:00.000Z","dateModified":"2023-03-25T12:16:00.000Z","author":{"@type":"Person","name":"子实"},"publisher":{"@type":"Organization","name":"子实","logo":{"@type":"ImageObject","url":"https://zlotus.github.io/img/opm_sq.png"}},"description":"《PingCap的Rust训练课程5：异步编程》中提到的一篇好文，值得一看。"}</script><link rel="icon" href="/img/avatar-o.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/2014/07/09/about-me/">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-24T08:45:00.000Z" title="12/24/2022, 4:45:00 PM">2022-12-24</time>发表</span><span class="level-item"><time dateTime="2023-03-25T12:16:00.000Z" title="3/25/2023, 8:16:00 PM">2023-03-25</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a></span><span class="level-item">1 小时读完 (大约9612个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">对Rust生命周期的一些常见误解</h1><div class="content"><article class="message message-immersive is-info">
<div class="message-body">
<i class="fa fa-exclamation-circle mr-2"></i>本文内容大多翻译自原文：<a target="_blank" rel="noopener" href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md">Common Rust Lifetime Misconceptions</a>。
</div>
</article>

<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li>
<li><a href="#%E6%A6%82%E5%BF%B5%E8%AF%AF%E8%A7%A3">概念误解</a><ul>
<li><a href="#1-t%E5%8F%AA%E5%8C%85%E5%90%AB%E8%87%AA%E6%9C%89%E7%B1%BB%E5%9E%8B">1) <code>T</code>只包含自有类型</a></li>
<li><a href="#2-%E5%A6%82%E6%9E%9CT-39-static%EF%BC%8C%E5%88%99T%E5%9C%A8%E7%A8%8B%E5%BA%8F%E6%95%B4%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%83%BD%E6%9C%89%E6%95%88">2) 如果<code>T: &#39;static</code>，则<code>T</code>在程序整个生命周期都有效</a></li>
<li><a href="#3-amp-39-a-T%E4%B8%8ET-39-a%E6%98%AF%E4%B8%80%E5%9B%9E%E4%BA%8B">3) <code>&amp;&#39;a T</code>与<code>T: &#39;a</code>是一回事</a></li>
<li><a href="#4-%E6%88%91%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B2%A1%E6%9C%89%E6%B3%9B%E5%9E%8B%E4%B9%9F%E6%B2%A1%E6%9C%89%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">4) 我的代码没有泛型也没有生命周期</a></li>
<li><a href="#5-%E5%A6%82%E6%9E%9C%E4%BB%A3%E7%A0%81%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91%EF%BC%8C%E5%B0%B1%E8%AF%B4%E6%98%8E%E6%88%91%E4%BB%AC%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B3%A8%E9%87%8A%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84">5) 如果代码通过编译，就说明我们的生命周期注释是正确的</a></li>
<li><a href="#6-box%E6%8C%87%E9%92%88%E4%B8%AD%E7%9A%84trait%E5%AF%B9%E8%B1%A1%E6%B2%A1%E6%9C%89%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A6%82%E5%BF%B5">6) box指针中的trait对象没有生命周期概念</a></li>
<li><a href="#7-%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA%E4%BC%9A%E5%91%8A%E8%AF%89%E6%88%91%E5%A6%82%E4%BD%95%E4%BF%AE%E5%A4%8D%E7%A8%8B%E5%BA%8F">7) 编译器的错误提示会告诉我如何修复程序</a></li>
<li><a href="#8-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A2%9E%E9%95%BF%E5%92%8C%E6%94%B6%E7%BC%A9">8) 生命周期可以在运行时增长和收缩</a></li>
<li><a href="#9-%E5%B0%86%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8%E9%99%8D%E7%BA%A7%E4%B8%BA%E5%85%B1%E4%BA%AB%E5%BC%95%E7%94%A8%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84">9) 将可变引用降级为共享引用是安全的</a></li>
<li><a href="#10-%E9%97%AD%E5%8C%85%E9%81%B5%E5%BE%AA%E4%B8%8E%E5%87%BD%E6%95%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9C%81%E7%95%A5%E8%A7%84%E5%88%99">10) 闭包遵循与函数相同的生命周期省略规则</a></li>
</ul>
</li>
<li><a href="#%E7%BB%93%E8%AE%BA">结论</a></li>
<li><a href="#%E8%AE%A8%E8%AE%BA">讨论</a></li>
<li><a href="#%E8%AE%A2%E9%98%85">订阅</a></li>
<li><a href="#%E6%B7%B1%E5%85%A5%E9%98%85%E8%AF%BB">深入阅读</a></li>
</ul>
<span id="more"></span>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>文中列出的这些误解都是我曾经以为正确的概念，我也看到现在仍有许多初学者都因为这些误解而苦苦挣扎。文中的一些术语可能不标准，我列了一张表，以解释我在文中使用某些短语时原本想表达的意思。</p>
<table>
<thead>
<tr>
<th>短语</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>T</code></td>
<td>1) 包含所有可能类型的集合 <em>或</em><br>2) 该集合中的某种类型</td>
</tr>
<tr>
<td>自有类型</td>
<td>某些非引用类型，如<code>i32</code>、<code>String</code>、<code>Vec</code>等</td>
</tr>
<tr>
<td>1) 借用类型 <em>或</em><br>2) 引用类型</td>
<td>某些引用类型，可变或不可变均可，如<code>&amp;i32</code>、<code>&amp;mut i32</code>等</td>
</tr>
<tr>
<td>1) 可变借用 <em>或</em><br>2) 互斥借用</td>
<td>排他可变引用，如<code>&amp;mut T</code></td>
</tr>
<tr>
<td>1) immut ref <em>or</em><br>2) shared ref</td>
<td>shared immutable reference, i.e. <code>&amp;T</code></td>
</tr>
</tbody></table>
<h2 id="概念误解"><a href="#概念误解" class="headerlink" title="概念误解"></a>概念误解</h2><p>总的来说，一个变量的生命周期是指：该变量指向的数据在其当前的内存地址中，能被编译器静态验证为有效的时间。下面将用6500字的篇幅来详细说明大家通常会混淆的地方。</p>
<h3 id="1-T只包含自有类型"><a href="#1-T只包含自有类型" class="headerlink" title="1) T只包含自有类型"></a>1) <code>T</code>只包含自有类型</h3><p>这种误解更多的是关于泛型，而是不关于生命周期，但是泛型和生命周期在Rust中紧密的交织在一起，所以不可能在谈论一个的时候不提及另一个。总之：</p>
<p>当我刚开始学习Rust时，我明白<code>i32</code>、<code>&amp;i32</code>和<code>&amp;mut i32</code>是不同的类型。我也明白一些泛型变量<code>T</code>代表了一个包含所有可能类型的集合。然而，尽管我分别理解了这两个概念，但我并不能把它们放在一起理解。在我的新手Rust大脑中，我认为泛型是这样工作的：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>类型变量</strong></td>
<td><code>T</code></td>
<td><code>&amp;T</code></td>
<td><code>&amp;mut T</code></td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td><code>i32</code></td>
<td><code>&amp;i32</code></td>
<td><code>&amp;mut i32</code></td>
</tr>
</tbody></table>
<p><code>T</code>包含所有自有类型。<code>&amp;T</code>包含所有不可变借用类型。<code>&amp;mut T</code>包含所有可变借用类型。<code>T</code>、<code>&amp;T</code>和<code>&amp;mut T</code>是互不相交的有限集合很好，简单，干净，容易，直观，但这是完全错误的理解。Rust中的泛型实际上是这样工作的：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>类型变量</strong></td>
<td><code>T</code></td>
<td><code>&amp;T</code></td>
<td><code>&amp;mut T</code></td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td><code>i32</code>， <code>&amp;i32</code>, <code>&amp;mut i32</code>, <code>&amp;&amp;i32</code>, <code>&amp;mut &amp;mut i32</code>, …</td>
<td><code>&amp;i32</code>, <code>&amp;&amp;i32</code>, <code>&amp;&amp;mut i32</code>, …</td>
<td><code>&amp;mut i32</code>, <code>&amp;mut &amp;mut i32</code>, <code>&amp;mut &amp;i32</code>, …</td>
</tr>
</tbody></table>
<p><code>T</code>、<code>&amp;T</code>和<code>&amp;mut T</code>均为无限集合，因为我们可以无限地借用一个类型。<code>T</code>是<code>&amp;T</code>和<code>&amp;mut T</code>的超集。而<code>&amp;T</code>和<code>&amp;mut T</code>是互斥集合。下面用几个例子验证这些概念：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Trait</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Trait <span class="keyword">for</span> T &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Trait <span class="keyword">for</span> &amp;T &#123;&#125; <span class="comment">// ❌</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Trait <span class="keyword">for</span> &amp;<span class="keyword">mut</span> T &#123;&#125; <span class="comment">// ❌</span></span><br></pre></td></tr></table></figure>

<p>上面的程序并不能通过编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">error[E0119]: conflicting implementations of trait `Trait` for type `&amp;_`:</span><br><span class="line"> --&gt; src/lib.rs:5:1</span><br><span class="line">  |</span><br><span class="line">3 | impl&lt;T&gt; Trait for T &#123;&#125;</span><br><span class="line">  | ------------------- first implementation here</span><br><span class="line">4 |</span><br><span class="line">5 | impl&lt;T&gt; Trait for &amp;T &#123;&#125;</span><br><span class="line">  | ^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `&amp;_`</span><br><span class="line"></span><br><span class="line">error[E0119]: conflicting implementations of trait `Trait` for type `&amp;mut _`:</span><br><span class="line"> --&gt; src/lib.rs:7:1</span><br><span class="line">  |</span><br><span class="line">3 | impl&lt;T&gt; Trait for T &#123;&#125;</span><br><span class="line">  | ------------------- first implementation here</span><br><span class="line">...</span><br><span class="line">7 | impl&lt;T&gt; Trait for &amp;mut T &#123;&#125;</span><br><span class="line">  | ^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `&amp;mut _`</span><br></pre></td></tr></table></figure>

<p>编译器不允许我们为<code>&amp;T</code>和<code>&amp;mut T</code>实现<code>Trait</code>，因为这会与<code>T</code>的<code>Trait</code>实现冲突，后者已经包括了<code>&amp;T</code>和<code>&amp;mut T</code>的所有内容。下面的程序可以通过编译，因为<code>&amp;T</code>和<code>&amp;mut T</code>互斥：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Trait</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Trait <span class="keyword">for</span> &amp;T &#123;&#125;  <span class="comment">// ✅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Trait <span class="keyword">for</span> &amp;<span class="keyword">mut</span> T &#123;&#125;  <span class="comment">// ✅</span></span><br></pre></td></tr></table></figure>

<p><strong>主要结论</strong></p>
<ul>
<li><code>T</code>是<code>&amp;T</code>和<code>&amp;mut T</code>的超集</li>
<li><code>&amp;T</code>和<code>&amp;mut T</code>是互斥集合</li>
</ul>
<h3 id="2-如果T-39-static，则T在程序整个生命周期都有效"><a href="#2-如果T-39-static，则T在程序整个生命周期都有效" class="headerlink" title="2) 如果T: &#39;static，则T在程序整个生命周期都有效"></a>2) 如果<code>T: &#39;static</code>，则<code>T</code>在程序整个生命周期都有效</h3><p><strong>误解的推论</strong></p>
<ul>
<li><code>T: &#39;static</code>应该读作“<code>T</code>具有<code>&#39;static</code>的生命周期”</li>
<li><code>&amp;&#39;static T</code>与<code>T: &#39;static</code>是一回事</li>
<li>如果有<code>T: &#39;static</code>，则<code>T</code>一定是不可变的</li>
<li>如果有<code>T: &#39;static</code>，则<code>T</code>只能在编译期创建</li>
</ul>
<p>大多数Rust初学者第一次接触到<code>&#39;static</code>生命周期，是在一个类似这样的代码示例中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> str_literal: &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span> = <span class="string">&quot;str literal&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他们被告知<code>&quot;str literal&quot;</code>是被硬编码到编译好的二进制文件中的，并且在运行时被加载到只读存储器中，所以它是不可变的，在整个程序的生命周期中都有效，这就是它<code>&#39;static</code>的含义。这些观念通过使用<code>static</code>关键字定义<code>static</code>变量的规则得到了进一步加强。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：这个理智纯粹是为了说明问题。</span></span><br><span class="line"><span class="comment">// 永远不要使用`static mut`这种别扭的变量。</span></span><br><span class="line"><span class="comment">// 在Rust中，有一些安全的全局可变单例模式，</span></span><br><span class="line"><span class="comment">// 但这些不在本文的讨论范围之内。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> BYTES: [<span class="built_in">u8</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> MUT_BYTES: [<span class="built_in">u8</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    MUT_BYTES[<span class="number">0</span>] = <span class="number">99</span>; <span class="comment">// ❌ - 修改静态变量是非安全的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        MUT_BYTES[<span class="number">0</span>] = <span class="number">99</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">99</span>, MUT_BYTES[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于<code>static</code>变量</p>
<ul>
<li>只能在编译期期创建</li>
<li>应该是不可变的，修改静态变量是非安全的</li>
<li>在整个程序的生命周期中都有效</li>
</ul>
<p><code>&#39;static</code>生命周期可能是根据<code>static</code>变量的默认生命周期来命名的，对吧？所以<code>&#39;static</code>生命周期遵循<code>static</code>变量相同的规则是很合理的，对吧？</p>
<p>也对，但是<em>具有</em><code>&#39;static</code>生命周期的类型与<em>受到</em><code>&#39;static</code>生命周期约束的类型是不同的。后者可以在运行时动态分配、可以安全的在任何地方修改、可以被析构，而且其生命周期可以持续任意的时间。</p>
<p>在这一点上，将<code>&amp;&#39;static T</code>与<code>T: &#39;static</code>区分开很重要。</p>
<p><code>&amp;&#39;static T</code>是对某个<code>T</code>的不可变引用，可以安全的持有无限长时间，包括持有到程序结束。但这只有在<code>T</code>本身是不可变的且在<em>引用被创建后没有移动</em>时才可以。<code>T</code>并不一定要在编译期创建。以内存泄漏为代价，在运行时生成随机的动态分配的数据再返回其<code>&#39;static</code>引用，也是可行的，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在运行时生成随机的&#x27;static str引用</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">rand_str_generator</span></span>() -&gt; &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> rand_string = rand::random::&lt;<span class="built_in">u64</span>&gt;().to_string();</span><br><span class="line">    box::leak(rand_string.into_boxed_str())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>T: &#39;static</code>是一种可以安全的无限期持有的<code>T</code>，包括持有到程序结束。<code>T: &#39;static</code>包括所有的<code>&amp;&#39;static T</code>，此外还包括所有的自有类型，比如<code>String</code>、<code>Vec</code>等。一些数据的持有者被保证，只要所有者持有数据，数据就不会失效，因此所有者可以安全地无限期地持有数据，包括持有到程序结束。<code>T: &#39;static</code>应该读作“<code>T</code>受到<code>&#39;static</code>生命周期约束”，而不是“<code>T</code>具有<code>&#39;static</code>生命周期”。用一个程序来帮助解释这一概念：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">drop_static</span></span>&lt;T: <span class="symbol">&#x27;static</span>&gt;(t: T) &#123;</span><br><span class="line">    std::mem::<span class="built_in">drop</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> strings: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> rand::random() &#123;</span><br><span class="line">            <span class="comment">// 所以字符串都是随机生成且在运行时动态分配的</span></span><br><span class="line">            <span class="keyword">let</span> string = rand::random::&lt;<span class="built_in">u64</span>&gt;().to_string();</span><br><span class="line">            strings.push(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串为自有类型，因此受到&#x27;static约束</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">mut</span> string <span class="keyword">in</span> strings &#123;</span><br><span class="line">        <span class="comment">// 所有字符串均可变</span></span><br><span class="line">        string.push_str(<span class="string">&quot;a mutation&quot;</span>);</span><br><span class="line">        <span class="comment">// 所有字符串均可析构</span></span><br><span class="line">        drop_static(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有字符串在程序结束前均已失效</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I am the end of program&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>主要结论</strong></p>
<ul>
<li><code>T: &#39;static</code>应读作“_<code>T</code>受到<code>&#39;static</code>生命周期约束_”</li>
<li>如果有<code>T: &#39;static</code>，则<code>T</code>可以是一个具有<code>&#39;static</code>生命周期的借用类型 <em>或</em> 一个自有类型</li>
<li>因为<code>T: &#39;static</code>包括自有类型，这意味着<code>T</code>：<ul>
<li>可以在运行时被动态的分配</li>
<li>不需要在程序的生命周期中始终有效</li>
<li>可以安全、自由的修改</li>
<li>可以在运行时动态的析构</li>
<li>可以有不同持续时间的生命周期</li>
</ul>
</li>
</ul>
<h3 id="3-amp-39-a-T与T-39-a是一回事"><a href="#3-amp-39-a-T与T-39-a是一回事" class="headerlink" title="3) &amp;&#39;a T与T: &#39;a是一回事"></a>3) <code>&amp;&#39;a T</code>与<code>T: &#39;a</code>是一回事</h3><p>这条误解是上一条误解的泛化版本。</p>
<p><code>&amp;&#39;a T</code>要求并暗指<code>T: &#39;a</code>，因为如果<code>T</code>本身在生命周期<code>&#39;a</code>上是无效的，那么以<code>&#39;a</code>为生命周期的<code>T</code>的引用在生命周期<code>&#39;a</code>上自然也是无效的。例如，Rust编译器不允许构造<code>&amp;&#39;static Ref&lt;&#39;a, T&gt;</code>类型，因为如果<code>Ref</code>只在<code>&#39;a</code>上有效，我们就不能对它使用<code>&#39;static</code>引用。</p>
<p><code>T: &#39;a</code>包括所有的<code>&amp;&#39;a T</code>，但反过来就不是这样了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只接受受到&#x27;a约束的类型的引用</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">t_ref</span></span>&lt;<span class="symbol">&#x27;a</span>, T: <span class="symbol">&#x27;a</span>&gt;(t: &amp;<span class="symbol">&#x27;a</span> T) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受任意受到&#x27;a约束的类型</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">t_bound</span></span>&lt;<span class="symbol">&#x27;a</span>, T: <span class="symbol">&#x27;a</span>&gt;(t: T) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含一个引用的自有类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ref</span></span>&lt;<span class="symbol">&#x27;a</span>, T: <span class="symbol">&#x27;a</span>&gt;(&amp;<span class="symbol">&#x27;a</span> T);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> string = <span class="built_in">String</span>::from(<span class="string">&quot;string&quot;</span>);</span><br><span class="line"></span><br><span class="line">    t_bound(&amp;string); <span class="comment">// ✅</span></span><br><span class="line">    t_bound(Ref(&amp;string)); <span class="comment">// ✅</span></span><br><span class="line">    t_bound(&amp;Ref(&amp;string)); <span class="comment">// ✅</span></span><br><span class="line"></span><br><span class="line">    t_ref(&amp;string); <span class="comment">// ✅</span></span><br><span class="line">    t_ref(Ref(&amp;string)); <span class="comment">// ❌ - 期待收到一个引用，但实际收到一个结构体</span></span><br><span class="line">    t_ref(&amp;Ref(&amp;string)); <span class="comment">// ✅</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// string var is bounded by &#x27;static which is bounded by &#x27;a</span></span><br><span class="line">    <span class="comment">// 字符串变量受到&#x27;static约束，即受到&#x27;a约束</span></span><br><span class="line">    t_bound(string); <span class="comment">// ✅</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>主要结论</strong></p>
<ul>
<li><code>T: &#39;a</code>比<code>&amp;&#39;a T</code>更通用也更灵活</li>
<li><code>T: &#39;a</code>接受自有类型、包含引用的自有类型以及引用</li>
<li><code>&amp;&#39;a T</code>只接受引用</li>
<li>如果有<code>T: &#39;static</code>，那么<code>T: &#39;a</code>，因为<code>&#39;static</code> &gt;= 所有的<code>&#39;a</code></li>
</ul>
<h3 id="4-我的代码没有泛型也没有生命周期"><a href="#4-我的代码没有泛型也没有生命周期" class="headerlink" title="4) 我的代码没有泛型也没有生命周期"></a>4) 我的代码没有泛型也没有生命周期</h3><p><strong>误解的推论</strong></p>
<ul>
<li>可以避免使用泛型和生命周期</li>
</ul>
<p>这一令人欣慰的误解之所以能够继续存在，要感谢Rust的生命周期省略规则，它允许我们在函数中省略生命周期注释，因为Rust的借用检查器会按照这些规则来推断生命周期：</p>
<ul>
<li>对于一个函数，每个输入的引用参数都具有不同的生命周期</li>
<li>如果有且只有一个输入的生命周期，则所有输出的引用都将应用该生命周期</li>
<li>如果有多个输入的生命周期，但其中一个是<code>&amp;self</code>或<code>&amp;mut self</code>，则所有输出的引用都将应用<code>self</code>的生命周期</li>
<li>否则就必须明确输出生命周期</li>
</ul>
<p>这么多规则很难一下就弄明白，我们来看几个例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print</span></span>(s: &amp;<span class="built_in">str</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开为</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">trim</span></span>(s: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开为</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">trim</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，因为没有输入，无法确定输出的生命周期</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_str</span></span>() -&gt; &amp;<span class="built_in">str</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开的选项包括</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_str</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;() -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>; <span class="comment">// 泛型版本</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_str</span></span>() -&gt; &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>; <span class="comment">// &#x27;static版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，因为有多个输入，无法确定输出的生命周期</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">overlap</span></span>(s: &amp;<span class="built_in">str</span>, t: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开（依然有部分省略）的选项包括</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">overlap</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>, t: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>; <span class="comment">// 输出的有效期不能超过s</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">overlap</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="built_in">str</span>, t: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>; <span class="comment">// 输出的有效期不能超过t</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">overlap</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>, t: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>; <span class="comment">// 输出的有效期不能超过s和t</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">overlap</span></span>(s: &amp;<span class="built_in">str</span>, t: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>; <span class="comment">// 输出的有效期可以超过s和t</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">overlap</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="built_in">str</span>, t: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>; <span class="comment">// 输出的生命周期与输入无关</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开为</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">overlap</span></span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>, t: &amp;<span class="symbol">&#x27;b</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">overlap</span></span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>, t: &amp;<span class="symbol">&#x27;b</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;b</span> <span class="built_in">str</span>;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">overlap</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>, t: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">overlap</span></span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>, t: &amp;<span class="symbol">&#x27;b</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">overlap</span></span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>, <span class="symbol">&#x27;c</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>, t: &amp;<span class="symbol">&#x27;b</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;c</span> <span class="built_in">str</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">compare</span></span>(&amp;<span class="keyword">self</span>, s: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开为</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">compare</span></span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">self</span>, &amp;<span class="symbol">&#x27;b</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>;</span><br></pre></td></tr></table></figure>

<p>如果你曾写过</p>
<ul>
<li>一个结构体方法</li>
<li>一个接受多个引用的函数</li>
<li>一个返回多个引用的函数</li>
<li>一个泛型函数</li>
<li>一个trait对象（后文会有更多介绍）</li>
<li>一个闭包（后文会有更多介绍）</li>
</ul>
<p>那么你的代码中就充满了省略的生命周期注释。</p>
<p><strong>主要结论</strong></p>
<ul>
<li>几乎所有的Rust代码都是泛型代码，到处都有被省略的生命周期注释。</li>
</ul>
<h3 id="5-如果代码通过编译，就说明我们的生命周期注释是正确的"><a href="#5-如果代码通过编译，就说明我们的生命周期注释是正确的" class="headerlink" title="5) 如果代码通过编译，就说明我们的生命周期注释是正确的"></a>5) 如果代码通过编译，就说明我们的生命周期注释是正确的</h3><p><strong>误解的推论</strong></p>
<ul>
<li>Rust函数的生命周期省略规则总是正确</li>
<li>Rust的借用检查器在技术上和语义上总是正确</li>
<li>Rust比我更了解我的程序的语义</li>
</ul>
<p>Rust程序即使在技术上可以通过编译，但在语义上仍然有可能是错误的。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ByteIter</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    remainder: &amp;<span class="symbol">&#x27;a</span> [<span class="built_in">u8</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ByteIter&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;&amp;<span class="built_in">u8</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.remainder.is_empty() &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> byte = &amp;<span class="keyword">self</span>.remainder[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">self</span>.remainder = &amp;<span class="keyword">self</span>.remainder[<span class="number">1</span>..];</span><br><span class="line">            <span class="literal">Some</span>(byte)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> bytes = ByteIter &#123; remainder: <span class="string">b&quot;1&quot;</span> &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="literal">Some</span>(&amp;<span class="string">b&#x27;1&#x27;</span>), bytes.next());</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="literal">None</span>, bytes.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ByteIter</code>是一个迭代字节片的迭代器。为了简洁起见，我们跳过了<code>Iterator</code> trait实现。它似乎能够正常工作，但如果我们想同时检查几个字节会怎样？</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> bytes = ByteIter &#123; remainder: <span class="string">b&quot;1123&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> byte_1 = bytes.next();</span><br><span class="line">    <span class="keyword">let</span> byte_2 = bytes.next();</span><br><span class="line">    <span class="keyword">if</span> byte_1 == byte_2 &#123; <span class="comment">// ❌</span></span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>呕吼！编译错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error[E0499]: cannot borrow `bytes` as mutable more than once at a time</span><br><span class="line">  --&gt; src/main.rs:20:18</span><br><span class="line">   |</span><br><span class="line">19 |     let byte_1 = bytes.next();</span><br><span class="line">   |                  ----- first mutable borrow occurs here</span><br><span class="line">20 |     let byte_2 = bytes.next();</span><br><span class="line">   |                  ^^^^^ second mutable borrow occurs here</span><br><span class="line">21 |     if byte_1 == byte_2 &#123;</span><br><span class="line">   |        ------ first borrow later used here</span><br></pre></td></tr></table></figure>

<p>我想我们可以复制每个字节。当我们处理字节时复制当然是可以的，但是如果我们将<code>ByteIter</code>变成一个通用的切片迭代器，它可以迭代任何<code>&amp;&#39;a [T]</code>，然后我们可能希望在未来使用它来处理那些复制/克隆成本很高，甚至是不可能复制的类型。好吧，我想我们对此无能为力。所以代码能通过编译，生命周期注释就一定正确吗？</p>
<p>不，当前的生命周期注释实际上是错误的来源！它特别难以发现，因为错误的生命周期注释被省略了。让我们声明省略的生命周期以更清楚地了解问题：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ByteIter</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    remainder: &amp;<span class="symbol">&#x27;a</span> [<span class="built_in">u8</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ByteIter&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;&amp;<span class="symbol">&#x27;b</span> <span class="built_in">u8</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.remainder.is_empty() &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> byte = &amp;<span class="keyword">self</span>.remainder[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">self</span>.remainder = &amp;<span class="keyword">self</span>.remainder[<span class="number">1</span>..];</span><br><span class="line">            <span class="literal">Some</span>(byte)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这并没有帮助，我们依然很困惑。这里有一个只有Rust专家知道的奇技淫巧：为你的生命周期注释提供描述性名称。让我们再试一次：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ByteIter</span></span>&lt;<span class="symbol">&#x27;remainder</span>&gt; &#123;</span><br><span class="line">    remainder: &amp;<span class="symbol">&#x27;remainder</span> [<span class="built_in">u8</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;remainder</span>&gt; ByteIter&lt;<span class="symbol">&#x27;remainder</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>&lt;<span class="symbol">&#x27;mut_self</span>&gt;(&amp;<span class="symbol">&#x27;mut_self</span> <span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;&amp;<span class="symbol">&#x27;mut_self</span> <span class="built_in">u8</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.remainder.is_empty() &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> byte = &amp;<span class="keyword">self</span>.remainder[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">self</span>.remainder = &amp;<span class="keyword">self</span>.remainder[<span class="number">1</span>..];</span><br><span class="line">            <span class="literal">Some</span>(byte)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个返回的字节都注释为<code>&#39;mut_self</code>，但这些字节显然来自<code>&#39;remainder</code>！让我们修复这个问题。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ByteIter</span></span>&lt;<span class="symbol">&#x27;remainder</span>&gt; &#123;</span><br><span class="line">    remainder: &amp;<span class="symbol">&#x27;remainder</span> [<span class="built_in">u8</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;remainder</span>&gt; ByteIter&lt;<span class="symbol">&#x27;remainder</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;&amp;<span class="symbol">&#x27;remainder</span> <span class="built_in">u8</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.remainder.is_empty() &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> byte = &amp;<span class="keyword">self</span>.remainder[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">self</span>.remainder = &amp;<span class="keyword">self</span>.remainder[<span class="number">1</span>..];</span><br><span class="line">            <span class="literal">Some</span>(byte)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> bytes = ByteIter &#123; remainder: <span class="string">b&quot;1123&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> byte_1 = bytes.next();</span><br><span class="line">    <span class="keyword">let</span> byte_2 = bytes.next();</span><br><span class="line">    std::mem::<span class="built_in">drop</span>(bytes); <span class="comment">// 我们甚至可以在此处析构迭代器！</span></span><br><span class="line">    <span class="keyword">if</span> byte_1 == byte_2 &#123; <span class="comment">// ✅</span></span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们回过头来看前一个版本的程序，它错的错误非常明显，那为什么Rust会让它通过编译呢？答案很简单：它是内存安全的。</p>
<p>Rust借用检查器只关心程序中的生命周期注释，它仅使用这些注释来对程序的内存安全性进行静态验证。即使生命周期注释存在语义错误，Rust仍会愉快地编译程序，其结果是使程序受到不必要的限制。</p>
<p>下面是一个与上面相反的简单示例：Rust的生命周期省略规则在这个实例中恰好是语义正确的，但我们无意中编写了一个非常严格的方法，其中包含我们显式声明的不必要的生命周期注释。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumRef</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; NumRef&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 我们的结构体以为&#x27;a泛型，这是否意味着我需要将self参数也注释为&#x27;a？</span></span><br><span class="line">    <span class="comment">// （答案：并不是）</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">some_method</span></span>(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="keyword">self</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> num_ref = NumRef(&amp;<span class="number">5</span>);</span><br><span class="line">    num_ref.some_method(); <span class="comment">// 可变借用num_ref直到其生命周期结束</span></span><br><span class="line">    num_ref.some_method(); <span class="comment">// ❌</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, num_ref); <span class="comment">// ❌</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有结构体以<code>&#39;a</code>为泛型，我们几乎不会想编写一个接受参数<code>&amp;&#39;a mut self</code>的方法。我们想告诉Rust的是“此方法将在结构体的整个生命周期内可变地借用该结构体”。实际上，这意味着Rust的借用检查器最多只允许调用一次<code>some_method</code>，然后该结构体将成为永久的可变借用，并因此无法再次使用。这种用例非常少见，但困惑的初学者很可能写出上面这种代码，而且还能通过编译。解决方法是不添加不必要的显式生命周期注释，交给Rust的生命周期省略规则处理：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumRef</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; NumRef&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 不再给mut self添加&#x27;a注释</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">some_method</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的方法实际上是：</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">some_method_desugared</span></span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> <span class="keyword">self</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> num_ref = NumRef(&amp;<span class="number">5</span>);</span><br><span class="line">    num_ref.some_method();</span><br><span class="line">    num_ref.some_method(); <span class="comment">// ✅</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, num_ref); <span class="comment">// ✅</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>主要结论</strong></p>
<ul>
<li>Rust函数的生命周期省略规则并不适用于所有情况</li>
<li>Rust并不比你更了解你程序的语义</li>
<li>给你的生命周期注解起描述性的名字</li>
<li>注意显式生命生命周期注释的位置以及原因</li>
</ul>
<h3 id="6-box指针中的trait对象没有生命周期概念"><a href="#6-box指针中的trait对象没有生命周期概念" class="headerlink" title="6) box指针中的trait对象没有生命周期概念"></a>6) box指针中的trait对象没有生命周期概念</h3><p>之前我们讨论了Rust的函数生命周期省略规则，当然，Rust也有针对特征对象的省略规则，它们是：</p>
<ul>
<li>如果一个trait对象被用作泛型类型的类型参数，那么它的生命周期约束是从包含的类型中推断出来的<ul>
<li>如果包含的类型有唯一的生命周期约束，那么就使用它</li>
<li>如果包含的类型有多个生命周期约束，那么必须指定一个显式生命周期约束</li>
</ul>
</li>
<li>如果以上均不适用，则<ul>
<li>如果该trait由唯一的一个生命周期约束定义，则使用该约束</li>
<li>如果<code>&#39;static</code>用于任何生命周期约束，则使用<code>&#39;static</code></li>
<li>如果trait没有生命周期约束，那么它的生命周期是通过表达式推断出来的，并且在表达式之外是<code>&#39;static</code>的</li>
</ul>
</li>
</ul>
<p>虽然上面这些规则听起来非常复杂，但是可以简单的概括为“<em>trait对象的生命周期约束是从上下文中推断出来的</em>”。在查看了一些示例之后，我们将意识到生命周期约束的推断是非常直观的，因此我们无需记住上面这些形式化的规则：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::Ref;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Trait</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">T1</span></span> = <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Trait&gt;;</span><br><span class="line"><span class="comment">//展开，Box&lt;T&gt;对T没有生命周期约束，因此推断为&#x27;static</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">T2</span></span> = <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Trait + <span class="symbol">&#x27;static</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line"><span class="keyword">impl</span> <span class="keyword">dyn</span> Trait &#123;&#125;</span><br><span class="line"><span class="comment">// 展开为</span></span><br><span class="line"><span class="keyword">impl</span> <span class="keyword">dyn</span> Trait + <span class="symbol">&#x27;static</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">T3</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; = &amp;<span class="symbol">&#x27;a</span> <span class="keyword">dyn</span> Trait;</span><br><span class="line"><span class="comment">// 展开，&amp;&#x27;a T 要求 T: &#x27;a，因此推断为&#x27;a</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">T4</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; = &amp;<span class="symbol">&#x27;a</span> (<span class="keyword">dyn</span> Trait + <span class="symbol">&#x27;a</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">T5</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; = Ref&lt;<span class="symbol">&#x27;a</span>, <span class="keyword">dyn</span> Trait&gt;;</span><br><span class="line"><span class="comment">// 展开，Ref&lt;&#x27;a, T&gt; 要求 T: &#x27;a，因此推断为&#x27;a</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">T6</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; = Ref&lt;<span class="symbol">&#x27;a</span>, <span class="keyword">dyn</span> Trait + <span class="symbol">&#x27;a</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">GenericTrait</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;: <span class="symbol">&#x27;a</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">T7</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; = <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> GenericTrait&lt;<span class="symbol">&#x27;a</span>&gt;&gt;;</span><br><span class="line"><span class="comment">// 展开为</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">T8</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; = <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> GenericTrait&lt;<span class="symbol">&#x27;a</span>&gt; + <span class="symbol">&#x27;a</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; <span class="keyword">dyn</span> GenericTrait&lt;<span class="symbol">&#x27;a</span>&gt; &#123;&#125;</span><br><span class="line"><span class="comment">// 展开为</span></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; <span class="keyword">dyn</span> GenericTrait&lt;<span class="symbol">&#x27;a</span>&gt; + <span class="symbol">&#x27;a</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>实现trait的具体类型可以有引用，因此它们也有生命周期约束，所以它们对应的trait对象也具有生命周期约束。你也可以直接为显然具有生命周期约束的引用实现trait：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Trait</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Struct</span></span> &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ref</span></span>&lt;<span class="symbol">&#x27;a</span>, T&gt;(&amp;<span class="symbol">&#x27;a</span> T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Trait <span class="keyword">for</span> Struct &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> Trait <span class="keyword">for</span> &amp;Struct &#123;&#125; <span class="comment">// 直接为引用类型实现Trait</span></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; Trait <span class="keyword">for</span> Ref&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;&#125; <span class="comment">// 为包含引用的类型实现</span></span><br></pre></td></tr></table></figure>

<p>无论如何，这值得一读，因为当初学者将函数从使用trait对象重构为泛型，或从泛型到使用trait对象时，常常会感到困惑。以这个程序为例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dynamic_thread_print</span></span>(t: <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Display + <span class="built_in">Send</span>&gt;) &#123;</span><br><span class="line">    std::thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, t);</span><br><span class="line">    &#125;).join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">static_thread_print</span></span>&lt;T: Display + <span class="built_in">Send</span>&gt;(t: T) &#123; <span class="comment">// ❌</span></span><br><span class="line">    std::thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, t);</span><br><span class="line">    &#125;).join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码将抛出下面的编译错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">error[E0310]: the parameter type `T` may not live long enough</span><br><span class="line">  --&gt; src/lib.rs:10:5</span><br><span class="line">   |</span><br><span class="line">9  | fn static_thread_print&lt;T: Display + Send&gt;(t: T) &#123;</span><br><span class="line">   |                        -- help: consider adding an explicit lifetime bound...: `T: &#x27;static +`</span><br><span class="line">10 |     std::thread::spawn(move || &#123;</span><br><span class="line">   |     ^^^^^^^^^^^^^^^^^^</span><br><span class="line">   |</span><br><span class="line">note: ...so that the type `[closure@src/lib.rs:10:24: 12:6 t:T]` will meet its required lifetime bounds</span><br><span class="line">  --&gt; src/lib.rs:10:5</span><br><span class="line">   |</span><br><span class="line">10 |     std::thread::spawn(move || &#123;</span><br><span class="line">   |     ^^^^^^^^^^^^^^^^^^</span><br></pre></td></tr></table></figure>

<p>很好，编译期已经告诉我们如何修复问题了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dynamic_thread_print</span></span>(t: <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Display + <span class="built_in">Send</span>&gt;) &#123;</span><br><span class="line">    std::thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, t);</span><br><span class="line">    &#125;).join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">static_thread_print</span></span>&lt;T: Display + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;(t: T) &#123; <span class="comment">// ✅</span></span><br><span class="line">    std::thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, t);</span><br><span class="line">    &#125;).join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在可以通过编译了，不过这两个函数放在一起看起来很奇怪，为什么第二个函数需要<code>&#39;static</code>约束的<code>T</code>，而第一个函数就不需要？这是一个棘手的问题。应用生命周期省略规则，Rust会自动在第一个函数中推断出<code>&#39;static</code>约束，因此两者实际上都有 <code>&#39;static</code>约束。这是Rust编译器实际看到的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dynamic_thread_print</span></span>(t: <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Display + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;) &#123;</span><br><span class="line">    std::thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, t);</span><br><span class="line">    &#125;).join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">static_thread_print</span></span>&lt;T: Display + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;(t: T) &#123;</span><br><span class="line">    std::thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, t);</span><br><span class="line">    &#125;).join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>主要结论</strong></p>
<ul>
<li>所有trait对象都具有某些推断的默认生命周期约束</li>
</ul>
<h3 id="7-编译器的错误提示会告诉我如何修复程序"><a href="#7-编译器的错误提示会告诉我如何修复程序" class="headerlink" title="7) 编译器的错误提示会告诉我如何修复程序"></a>7) 编译器的错误提示会告诉我如何修复程序</h3><p><strong>误解的推论</strong></p>
<ul>
<li>Rust对trait对象的生命周期省略规则总是正确的</li>
<li>Rust比我更了解我程序的语义</li>
</ul>
<p>这种误解结合了前面两种误解，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">box_displayable</span></span>&lt;T: Display&gt;(t: T) -&gt; <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Display&gt; &#123; <span class="comment">// ❌</span></span><br><span class="line">    <span class="built_in">Box</span>::new(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抛出的错误为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">error[E0310]: the parameter type `T` may not live long enough</span><br><span class="line"> --&gt; src/lib.rs:4:5</span><br><span class="line">  |</span><br><span class="line">3 | fn box_displayable&lt;T: Display&gt;(t: T) -&gt; Box&lt;dyn Display&gt; &#123;</span><br><span class="line">  |                    -- help: consider adding an explicit lifetime bound...: `T: &#x27;static +`</span><br><span class="line">4 |     Box::new(t)</span><br><span class="line">  |     ^^^^^^^^^^^</span><br><span class="line">  |</span><br><span class="line">note: ...so that the type `T` will meet its required lifetime bounds</span><br><span class="line"> --&gt; src/lib.rs:4:5</span><br><span class="line">  |</span><br><span class="line">4 |     Box::new(t)</span><br><span class="line">  |     ^^^^^^^^^^^</span><br></pre></td></tr></table></figure>

<p>让我们按照编译器告诉我们方式来修复问题，它将我们boxed trait的约束自动推断为<code>&#39;static</code>，而它推荐的修复方式就基于这个未声明的事实，虽然编译器没有告诉我们，但无需介意：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">box_displayable</span></span>&lt;T: Display + <span class="symbol">&#x27;static</span>&gt;(t: T) -&gt; <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Display&gt; &#123; <span class="comment">// ✅</span></span><br><span class="line">    <span class="built_in">Box</span>::new(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以程序现在可以通过编译了……但这真的是我们想要的吗？可能是也可能不是。编译器没有提到其他修复，但下面这种也是合适的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">box_displayable</span></span>&lt;<span class="symbol">&#x27;a</span>, T: Display + <span class="symbol">&#x27;a</span>&gt;(t: T) -&gt; <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Display + <span class="symbol">&#x27;a</span>&gt; &#123; <span class="comment">// ✅</span></span><br><span class="line">    <span class="built_in">Box</span>::new(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函数接受参数的范围比前面的版本更广！但这会让它变得更好用吗？不一定，要看我们程序的要求和约束。这个例子有点抽象，所以让我们看一个更简单且明显的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">return_first</span></span>(a: &amp;<span class="built_in">str</span>, b: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123; <span class="comment">// ❌</span></span><br><span class="line">    a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抛出的错误为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src/lib.rs:1:38</span><br><span class="line">  |</span><br><span class="line">1 | fn return_first(a: &amp;str, b: &amp;str) -&gt; &amp;str &#123;</span><br><span class="line">  |                    ----     ----     ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">  = help: this function&#x27;s return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`</span><br><span class="line">help: consider introducing a named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">1 | fn return_first&lt;&#x27;a&gt;(a: &amp;&#x27;a str, b: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123;</span><br><span class="line">  |                ^^^^    ^^^^^^^     ^^^^^^^     ^^^</span><br></pre></td></tr></table></figure>

<p>错误消息建议使用相同的生命周期注释输入和输出。如果我们这样做，程序的确会通过编译，但这个函数会过度限制返回类型。我们真正想要的是这样的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">return_first</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(a: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>, b: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span> &#123; <span class="comment">// ✅</span></span><br><span class="line">    a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>主要结论</strong></p>
<ul>
<li>Rust对trait对象的生命周期省略规则并不总是适用于所有情况</li>
<li>Rust并不比你更了解你程序的语义</li>
<li>Rust编译器的错误消息修复建议能够使你的程序通过编译，但这不一定是使你的程序通过编译的最合适的修复方式</li>
</ul>
<h3 id="8-生命周期可以在运行时增长和收缩"><a href="#8-生命周期可以在运行时增长和收缩" class="headerlink" title="8) 生命周期可以在运行时增长和收缩"></a>8) 生命周期可以在运行时增长和收缩</h3><p><strong>误解的推论</strong></p>
<ul>
<li>容器类型可以在运行时切换引用，以改变它们的生命周期</li>
<li>Rust借用检查器会对程序进行高级控制流分析</li>
</ul>
<p>这不能通过编译：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Has</span></span>&lt;<span class="symbol">&#x27;lifetime</span>&gt; &#123;</span><br><span class="line">    lifetime: &amp;<span class="symbol">&#x27;lifetime</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> long = <span class="built_in">String</span>::from(<span class="string">&quot;long&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> has = Has &#123; lifetime: &amp;long &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(has.lifetime, <span class="string">&quot;long&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> short = <span class="built_in">String</span>::from(<span class="string">&quot;short&quot;</span>);</span><br><span class="line">        <span class="comment">// “切换”到short生命周期</span></span><br><span class="line">        has.lifetime = &amp;short;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(has.lifetime, <span class="string">&quot;short&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// “切换回”long生命周期（但实际上并没有）</span></span><br><span class="line">        has.lifetime = &amp;long;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(has.lifetime, <span class="string">&quot;long&quot;</span>);</span><br><span class="line">        <span class="comment">// `short`在此处析构</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(has.lifetime, <span class="string">&quot;long&quot;</span>); <span class="comment">// ❌ - `short`在析构之后仍“被借用”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码抛出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error[E0597]: `short` does not live long enough</span><br><span class="line">  --&gt; src/main.rs:11:24</span><br><span class="line">   |</span><br><span class="line">11 |         has.lifetime = &amp;short;</span><br><span class="line">   |                        ^^^^^^ borrowed value does not live long enough</span><br><span class="line">...</span><br><span class="line">15 |     &#125;</span><br><span class="line">   |     - `short` dropped here while still borrowed</span><br><span class="line">16 |     assert_eq!(has.lifetime, &quot;long&quot;);</span><br><span class="line">   |     --------------------------------- borrow later used here</span><br></pre></td></tr></table></figure>

<p>下面这段代码也不能通过编译，且与上面的代码抛出的错误完全一致：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Has</span></span>&lt;<span class="symbol">&#x27;lifetime</span>&gt; &#123;</span><br><span class="line">    lifetime: &amp;<span class="symbol">&#x27;lifetime</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> long = <span class="built_in">String</span>::from(<span class="string">&quot;long&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> has = Has &#123; lifetime: &amp;long &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(has.lifetime, <span class="string">&quot;long&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虽然这个代码块从不执行</span></span><br><span class="line">    <span class="keyword">if</span> <span class="literal">false</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> short = <span class="built_in">String</span>::from(<span class="string">&quot;short&quot;</span>);</span><br><span class="line">        <span class="comment">// “切换”到short生命周期</span></span><br><span class="line">        has.lifetime = &amp;short;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(has.lifetime, <span class="string">&quot;short&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// “切换回”long生命周期（但实际上并没有）</span></span><br><span class="line">        has.lifetime = &amp;long;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(has.lifetime, <span class="string">&quot;long&quot;</span>);</span><br><span class="line">        <span class="comment">// `short`在此处析构</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(has.lifetime, <span class="string">&quot;long&quot;</span>); <span class="comment">// ❌ - `short`在析构之后仍“被借用”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rust中的生命周期必须在编译时静态验证，借用检查器只会进行最基本的控制流分析，所以它假设<code>if-else</code>语句中的每个块和<code>match</code>语句中的每个匹配分支都可以被执行，然后为变量选择可能的最短的生命周期。一旦一个变量被一个生命周期约束，就将<em>永远</em>受到该生命周期的约束。变量的生命周期只能收缩，而所有的收缩都是在编译时决定的。</p>
<p><strong>主要结论</strong></p>
<ul>
<li>生命周期会在编译期静态验证</li>
<li>生命周期不能在运行时以任何方式增长、收缩或改变</li>
<li>Rust借用检查器将始终为变量选择尽可能短的生命周期，并会假设所有分支代码都能够被执行</li>
</ul>
<h3 id="9-将可变引用降级为共享引用是安全的"><a href="#9-将可变引用降级为共享引用是安全的" class="headerlink" title="9) 将可变引用降级为共享引用是安全的"></a>9) 将可变引用降级为共享引用是安全的</h3><p><strong>误解的推论</strong></p>
<ul>
<li>重新借用一个引用将结束现有的生命周期并开始一个新的生命周期</li>
</ul>
<p>您可以将可变引用传给期望共享引用的函数，因为Rust会隐式地重新借用这个可变引用并将其变为不可变的共享引用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_shared_ref</span></span>(n: &amp;<span class="built_in">i32</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="number">10</span>;</span><br><span class="line">    takes_shared_ref(&amp;<span class="keyword">mut</span> a); <span class="comment">// ✅</span></span><br><span class="line">    takes_shared_ref(&amp;*(&amp;<span class="keyword">mut</span> a)); <span class="comment">// 上一行实际上执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直觉上这是有道理的，因为将一个可变引用重新借用为不可变的应该不会造成什么影响，对吧？令人惊讶的是，实际上并非没有影响，来看下面的程序就无法通过编译：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> b: &amp;<span class="built_in">i32</span> = &amp;*(&amp;<span class="keyword">mut</span> a); <span class="comment">// re-borrowed as immutable</span></span><br><span class="line">    <span class="keyword">let</span> c: &amp;<span class="built_in">i32</span> = &amp;a;</span><br><span class="line">    dbg!(b, c); <span class="comment">// ❌</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码抛出如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error[E0502]: cannot borrow `a` as immutable because it is also borrowed as mutable</span><br><span class="line"> --&gt; src/main.rs:4:19</span><br><span class="line">  |</span><br><span class="line">3 |     let b: &amp;i32 = &amp;*(&amp;mut a);</span><br><span class="line">  |                     -------- mutable borrow occurs here</span><br><span class="line">4 |     let c: &amp;i32 = &amp;a;</span><br><span class="line">  |                   ^^ immutable borrow occurs here</span><br><span class="line">5 |     dbg!(b, c);</span><br><span class="line">  |          - mutable borrow later used here</span><br></pre></td></tr></table></figure>

<p>我们确实进行了可变借用，但它会立即无条件地重新进行不可变借用，然后被丢弃。为什么Rust将不可变的重新借用，仍然视为可变借用的独占生命周期？虽然在上面的特定示例中没有问题，但允许将可变引用降级为共享引用的功能，确实会引入潜在的内存安全问题：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Struct</span></span> &#123;</span><br><span class="line">    mutex: Mutex&lt;<span class="built_in">String</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Struct &#123;</span><br><span class="line">    <span class="comment">// 将可变self降级为共享str</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_string</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.mutex.get_mut().unwrap()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">mutate_string</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果Rust允许将可变引用降级为共享引用</span></span><br><span class="line">        <span class="comment">// 则下面这行代码将使从get_string方法返回的任何共享引用无效</span></span><br><span class="line">        *<span class="keyword">self</span>.mutex.lock().unwrap() = <span class="string">&quot;surprise!&quot;</span>.to_owned();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = Struct &#123;</span><br><span class="line">        mutex: Mutex::new(<span class="string">&quot;string&quot;</span>.to_owned())</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> str_ref = s.get_string(); <span class="comment">// 可变引用降级为共享引用</span></span><br><span class="line">    s.mutate_string(); <span class="comment">// str_ref将变得无效，产生悬空指针</span></span><br><span class="line">    dbg!(str_ref); <span class="comment">// ❌ - 如我们所料</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的要点是，当你将可变引用重新借用为共享引用时，你不只得到了共享引用还掉进了一个大坑：重新借用还延长了可变引用的生命周期，即使可变引用自身已被析构。使用重新借用的共享引用非常难，因为它不仅不可变，还不能被其他任何共享引用共享。重新借用的共享引用集合了可变引用和共享引用的所有缺点，且并没有得到两者的任一的优点。我认为将可变引用重新借用为共享引用应该被视为Rust反面模式。意识到这种反面模式很重要，这样当您看到这样的代码时就可以很容易地发现它：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将可变T降级为共享T</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">some_function</span></span>&lt;T&gt;(some_arg: &amp;<span class="keyword">mut</span> T) -&gt; &amp;T;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Struct</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Struct &#123;</span><br><span class="line">    <span class="comment">// 将可变self降级为共享self</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">some_method</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; &amp;<span class="keyword">Self</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将可变self降级为共享T</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">other_method</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; &amp;T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使你避免了在函数和方法签名中的重新借用，Rust仍然会自动进行隐式重新借用，所以我们很容易在没有意识到的情况下遇到这种问题：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">PlayerID</span></span> = <span class="built_in">i32</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, Default)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Player</span></span> &#123;</span><br><span class="line">    score: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">start_game</span></span>(player_a: PlayerID, player_b: PlayerID, server: &amp;<span class="keyword">mut</span> HashMap&lt;PlayerID, Player&gt;) &#123;</span><br><span class="line">    <span class="comment">// 从服务器获取玩家，如果玩家不存在则创建或插入新玩家</span></span><br><span class="line">    <span class="keyword">let</span> player_a: &amp;Player = server.entry(player_a).or_default();</span><br><span class="line">    <span class="keyword">let</span> player_b: &amp;Player = server.entry(player_b).or_default();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something with players</span></span><br><span class="line">    dbg!(player_a, player_b); <span class="comment">// ❌</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码无法通过编译。<code>or_default()</code>将返回一个<code>&amp;mut Player</code>，我们的显式类型注释将使Rust隐式地重新借用为<code>&amp;Player</code>。所以，正确的写法应该是：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">PlayerID</span></span> = <span class="built_in">i32</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, Default)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Player</span></span> &#123;</span><br><span class="line">    score: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">start_game</span></span>(player_a: PlayerID, player_b: PlayerID, server: &amp;<span class="keyword">mut</span> HashMap&lt;PlayerID, Player&gt;) &#123;</span><br><span class="line">    <span class="comment">// 丢弃返回的可变Player引用，反正我们也不能同时使用它们</span></span><br><span class="line">    server.entry(player_a).or_default();</span><br><span class="line">    server.entry(player_b).or_default();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新获取players，这次直接获取其不可变引用，且不带有啊任何隐式重新借用</span></span><br><span class="line">    <span class="keyword">let</span> player_a = server.get(&amp;player_a);</span><br><span class="line">    <span class="keyword">let</span> player_b = server.get(&amp;player_b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something with players</span></span><br><span class="line">    dbg!(player_a, player_b); <span class="comment">// ✅</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么写有点奇怪还很笨拙，但这是我们在内存安全问题上必要的牺牲。</p>
<p><strong>主要结论</strong></p>
<ul>
<li>尽量不要将可变引用重新借用为共享引用，否则你可能会遇到大麻烦</li>
<li>对可变引用进行重新借用并不会结束它的生命周期，即使该引用已被删除</li>
</ul>
<h3 id="10-闭包遵循与函数相同的生命周期省略规则"><a href="#10-闭包遵循与函数相同的生命周期省略规则" class="headerlink" title="10) 闭包遵循与函数相同的生命周期省略规则"></a>10) 闭包遵循与函数相同的生命周期省略规则</h3><p>这与其说是一种误解，不如说是Rust的陷阱。</p>
<p>尽管闭包也是函数，但并不遵循与函数相同的生命周期省略规则。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">function</span></span>(x: &amp;<span class="built_in">i32</span>) -&gt; &amp;<span class="built_in">i32</span> &#123;</span><br><span class="line">    x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> closure = |x: &amp;<span class="built_in">i32</span>| x; <span class="comment">// ❌</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">error: lifetime may not live long enough</span><br><span class="line"> --&gt; src/main.rs:6:29</span><br><span class="line">  |</span><br><span class="line">6 |     let closure = |x: &amp;i32| x;</span><br><span class="line">  |                       -   - ^ returning this value requires that `&#x27;1` must outlive `&#x27;2`</span><br><span class="line">  |                       |   |</span><br><span class="line">  |                       |   return type of closure is &amp;&#x27;2 i32</span><br><span class="line">  |                       let&#x27;s call the lifetime of this reference `&#x27;1`</span><br></pre></td></tr></table></figure>

<p>补全上面代码省略的内容：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入的生命周期应用于输出的生命周期</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">function</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span> &#123;</span><br><span class="line">    x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 输入和输出分别得到了各自不同的生命周期</span></span><br><span class="line">    <span class="keyword">let</span> closure = <span class="keyword">for</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt; |x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span>| -&gt; &amp;<span class="symbol">&#x27;b</span> <span class="built_in">i32</span> &#123; x &#125;;</span><br><span class="line">    <span class="comment">// 注意：上面一行代码的语法并不合法，我们只是使用它说明情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种差异没有什么合理的解释。闭包最初是使用与函数不同的类型推断语义实现的，不过我们可能要永远这么用下去了，因为如果现在统一两者的实现将是一个破坏性的更新。那么如何显式地注释闭包呢？我们的选择包括：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 若转换为trait对象，占用空间会变得固定，于是产生编译错误</span></span><br><span class="line">    <span class="keyword">let</span> identity: <span class="keyword">dyn</span> <span class="built_in">Fn</span>(&amp;<span class="built_in">i32</span>) -&gt; &amp;<span class="built_in">i32</span> = |x: &amp;<span class="built_in">i32</span>| x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以分配在堆上，但感觉很笨重</span></span><br><span class="line">    <span class="keyword">let</span> identity: <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> <span class="built_in">Fn</span>(&amp;<span class="built_in">i32</span>) -&gt; &amp;<span class="built_in">i32</span>&gt; = <span class="built_in">Box</span>::new(|x: &amp;<span class="built_in">i32</span>| x);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以跳过分配，只创建一个静态引用</span></span><br><span class="line">    <span class="keyword">let</span> identity: &amp;<span class="keyword">dyn</span> <span class="built_in">Fn</span>(&amp;<span class="built_in">i32</span>) -&gt; &amp;<span class="built_in">i32</span> = &amp;|x: &amp;<span class="built_in">i32</span>| x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面这一行实际上是：</span></span><br><span class="line">    <span class="keyword">let</span> identity: &amp;<span class="symbol">&#x27;static</span> (<span class="keyword">dyn</span> <span class="keyword">for</span>&lt;<span class="symbol">&#x27;a</span>&gt; <span class="built_in">Fn</span>(&amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span> + <span class="symbol">&#x27;static</span>) = &amp;|x: &amp;<span class="built_in">i32</span>| -&gt; &amp;<span class="built_in">i32</span> &#123; x &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这么写是最理想的，但这样的语法是无效的</span></span><br><span class="line">    <span class="keyword">let</span> identity: <span class="keyword">impl</span> <span class="built_in">Fn</span>(&amp;<span class="built_in">i32</span>) -&gt; &amp;<span class="built_in">i32</span> = |x: &amp;<span class="built_in">i32</span>| x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这样写也很理想，但依然是无效语法</span></span><br><span class="line">    <span class="keyword">let</span> identity = <span class="keyword">for</span>&lt;<span class="symbol">&#x27;a</span>&gt; |x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span>| -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span> &#123; x &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `impl trait`只能用在在函数签名的返回值部分</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">return_identity</span></span>() -&gt; <span class="keyword">impl</span> <span class="built_in">Fn</span>(&amp;<span class="built_in">i32</span>) -&gt; &amp;<span class="built_in">i32</span> &#123;</span><br><span class="line">        |x| x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> identity = return_identity();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面版本的泛型化写法</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">annotate</span></span>&lt;T, F&gt;(f: F) -&gt; F <span class="keyword">where</span> F: <span class="built_in">Fn</span>(&amp;T) -&gt; &amp;T &#123;</span><br><span class="line">        f</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> identity = annotate(|x: &amp;<span class="built_in">i32</span>| x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你应该已经从上面的示例中注意到了，当闭包类型用作trait约束时，它们确实应用了通常的函数生命周期省略规则。</p>
<p>此处并没有什么教训或启发，Rust现在就是这样。</p>
<p><strong>主要结论</strong></p>
<ul>
<li>每个编程语言都有些陷阱🤷</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li><code>T</code>是<code>&amp;T</code>和<code>&amp;mut T</code>的超集</li>
<li><code>&amp;T</code>和<code>&amp;mut T</code>是互斥集合</li>
<li><code>T: &#39;static</code>应读作“_<code>T</code>受到<code>&#39;static</code>生命周期约束_”</li>
<li>如果有<code>T: &#39;static</code>，则<code>T</code>可以是一个具有<code>&#39;static</code>生命周期的借用类型 <em>或</em> 一个自有类型</li>
<li>因为<code>T: &#39;static</code>包括自有类型，这意味着<code>T</code>：<ul>
<li>可以在运行时被动态的分配</li>
<li>不需要在程序的生命周期中始终有效</li>
<li>可以安全、自由的修改</li>
<li>可以在运行时动态的析构</li>
<li>可以有不同持续时间的生命周期</li>
</ul>
</li>
<li><code>T: &#39;a</code>比<code>&amp;&#39;a T</code>更通用也更灵活</li>
<li><code>T: &#39;a</code>接受自有类型、包含引用的自有类型以及引用</li>
<li><code>&amp;&#39;a T</code>只接受引用</li>
<li>如果有<code>T: &#39;static</code>，那么<code>T: &#39;a</code>，因为<code>&#39;static</code> &gt;= 所有的<code>&#39;a</code></li>
<li>几乎所有的Rust代码都是泛型代码，到处都有被省略的生命周期注释。</li>
<li>Rust函数的生命周期省略规则并不适用于所有情况</li>
<li>Rust并不比你更了解你程序的语义</li>
<li>给你的生命周期注解起描述性的名字</li>
<li>注意显式生命生命周期注释的位置以及原因</li>
<li>所有trait对象都具有某些推断的默认生命周期约束</li>
<li>Rust编译器的错误消息修复建议能够使你的程序通过编译，但这不一定是使你的程序通过编译的最合适的修复方式</li>
<li>生命周期会在编译期静态验证</li>
<li>生命周期不能在运行时以任何方式增长、收缩或改变</li>
<li>Rust借用检查器将始终为变量选择尽可能短的生命周期，并会假设所有分支代码都能够被执行</li>
<li>尽量不要将可变引用重新借用为共享引用，否则你可能会遇到大麻烦</li>
<li>对可变引用进行重新借用并不会结束它的生命周期，即使该引用已被删除</li>
<li>每个编程语言都有些陷阱🤷</li>
</ul>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>讨论这篇文章的地方：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.reddit.com/r/learnrust/comments/gmrcrq/common_rust_lifetime_misconceptions/">learnrust subreddit</a></li>
<li><a target="_blank" rel="noopener" href="https://users.rust-lang.org/t/blog-post-common-rust-lifetime-misconceptions/42950">official Rust users forum</a></li>
<li><a target="_blank" rel="noopener" href="https://twitter.com/pretzelhammer/status/1263505856903163910">Twitter</a></li>
<li><a target="_blank" rel="noopener" href="https://www.reddit.com/r/rust/comments/golrsx/common_rust_lifetime_misconceptions/">rust subreddit</a></li>
<li><a target="_blank" rel="noopener" href="https://news.ycombinator.com/item?id=23279731">Hackernews</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/pretzelhammer/rust-blog/discussions">Github</a></li>
</ul>
<h2 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h2><p>订阅下一篇文章的地方：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://twitter.com/pretzelhammer">Following pretzelhammer on Twitter</a> or</li>
<li><a target="_blank" rel="noopener" href="https://github.com/pretzelhammer/rust-blog/releases.atom">Subscribing to this repo’s release RSS feed</a> or</li>
<li>关注本repo的release (click <code>Watch</code> -&gt; click <code>Custom</code> -&gt; select <code>Releases</code> -&gt; click <code>Apply</code>)</li>
</ul>
<h2 id="深入阅读"><a href="#深入阅读" class="headerlink" title="深入阅读"></a>深入阅读</h2><ul>
<li><a href="./sizedness-in-rust.md">Sizedness in Rust</a></li>
<li><a href="./tour-of-rusts-standard-library-traits.md">Tour of Rust’s Standard Library Traits</a></li>
<li><a href="./restful-api-in-sync-and-async-rust.md">RESTful API in Sync &amp; Async Rust</a></li>
<li><a href="./learning-rust-in-2020.md">Learning Rust in 2020</a></li>
<li><a href="./too-many-brainfuck-compilers.md">Learn Assembly with Entirely Too Many Brainfuck Compilers</a></li>
</ul>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Rust/">Rust</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatpay.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/02/11/oracle-cloud-arm-vps/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">白嫖甲骨文云，但没有完全白嫖</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/12/11/drop-2022/"><span class="level-item">析构2022 - 人可不能太害怕冬天</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><script src="https://utteranc.es/client.js" repo="zlotus/comment" issue-term="pathname" label="some-issue-label" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/opm_sq.png" alt="子实"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">子实</p><p class="is-size-6 is-block">程序员</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>陕西/西安</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">78</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">22</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zlotus" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com/qinzishi"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/Zealot_uS"><i class="fab fa-twitter"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.zhihu.com/people/zlotus" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Diary/"><span class="level-start"><span class="level-item">Diary</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">64</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Shell/"><span class="level-start"><span class="level-item">Shell</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Coroutines/"><span class="tag">Coroutines</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">30</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenCV/"><span class="tag">OpenCV</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Operating-System/"><span class="tag">Operating System</span><span class="tag">21</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Paper/"><span class="tag">Paper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">17</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Raspberry-Pi/"><span class="tag">Raspberry Pi</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag">29</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TensorFlow/"><span class="tag">TensorFlow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tokio/"><span class="tag">Tokio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZMQ/"><span class="tag">ZMQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ctpn/"><span class="tag">ctpn</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macOS/"><span class="tag">macOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/obsidion/"><span class="tag">obsidion</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%A5%E8%AE%B0/"><span class="tag">日记</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E8%B0%88/"><span class="tag">杂谈</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B/"><span class="tag">编程</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%84%9A%E6%9C%AC/"><span class="tag">脚本</span><span class="tag">4</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a><p class="is-size-7"><span>&copy; 2023 子实</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>