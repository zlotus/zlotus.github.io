<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>PingCap的Rust训练课程5：异步编程 - 子实</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="子实"><meta name="msapplication-TileImage" content="/img/avatar-o.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="子实"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="PingCap的Rust训练课程5：异步编程"><meta property="og:type" content="article"><meta property="og:title" content="PingCap的Rust训练课程5：异步编程"><meta property="og:url" content="https://zlotus.github.io/2022/08/30/pna-rust-project-5/"><meta property="og:site_name" content="子实"><meta property="og:description" content="PingCap的Rust训练课程5：异步编程"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zlotus.github.io/img/og_image.png"><meta property="article:published_time" content="2022-08-30T13:01:00.000Z"><meta property="article:modified_time" content="2022-08-30T13:01:00.000Z"><meta property="article:author" content="子实"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Tokio"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><meta property="twitter:creator" content="@Zealot_uS"><meta property="twitter:site" content="Zealot_uS"><link rel="publisher" href="+LotusQin"><meta property="fb:admins" content="qinzishi"><meta property="fb:app_id" content="qinzishi"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zlotus.github.io/2022/08/30/pna-rust-project-5/"},"headline":"PingCap的Rust训练课程5：异步编程","image":["https://zlotus.github.io/img/og_image.png"],"datePublished":"2022-08-30T13:01:00.000Z","dateModified":"2022-08-30T13:01:00.000Z","author":{"@type":"Person","name":"子实"},"publisher":{"@type":"Organization","name":"子实","logo":{"@type":"ImageObject","url":"https://zlotus.github.io/img/opm_sq.png"}},"description":"PingCap的Rust训练课程5：异步编程"}</script><link rel="icon" href="/img/avatar-o.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/2014/07/09/about-me/">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-08-30T13:01:00.000Z" title="8/30/2022, 9:01:00 PM">2022-08-30</time>发表</span><span class="level-item"><time dateTime="2022-08-30T13:01:00.000Z" title="8/30/2022, 9:01:00 PM">2022-08-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a></span><span class="level-item">3 小时读完 (大约31489个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">PingCap的Rust训练课程5：异步编程</h1><div class="content"><article class="message message-immersive is-info">
<div class="message-body">
<i class="fa fa-exclamation-circle mr-2"></i>本文前半部分大多翻译自原文：<a target="_blank" rel="noopener" href="https://github.com/pingcap/talent-plan/tree/master/courses/rust/projects/project-5">PNA Rust Project 5: Asynchrony</a>，但这篇文章年久失修且烂尾，推荐跳过。<br/>
<i class="fa fa-check-circle mr-2"></i>本文 <a href=".#1-Tokio概述"><b>后半部分</b></a> 将使用 <a target="_blank" rel="noopener" href="https://tokio.rs/tokio/tutorial">tokio官方示例 <b>mini-redis</b></a> 作为替身，建议直接阅读。
</div>
</article>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>任务</strong>：通过自定义协议，使用<em>异步网络</em>创建一个多线程、持久化键/值存储的服务端和客户端。</p>
<p><strong>目标</strong>：</p>
<ul>
<li>了解在Rust中编写future时使用基本模式</li>
<li>了解future的错误处理</li>
<li>学会调试类型系统</li>
<li>使用Tokio运行时执行异步网络</li>
<li>使用boxed future处理棘手的类型系统问题</li>
<li>使用<code>impl Trait</code>创建匿名<code>Future</code>类型</li>
</ul>
<p><strong>关键词</strong>：异步、future、tokio、<code>impl Trait</code>。</p>
<span id="more"></span>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><em>注意：本文仅仅是本项目的提纲，并没有写完。如果您已经读到这里了，请电子邮件至<a href="brian@pingcap.com">brian@pingcap.com</a>以提醒我，我将尽快写写完本文。</em></p>
<p>在本项目中，您将创建一个使用自定义协议通信的简单键/值服务端和客户端。该服务端将基于Tokio运行时构建的异步网络。键/值引擎的日志文件读写部分依然使用同步模式，在基础线程池上进行调度工作，并提供一个异步接口。在此过程中，您将尝试使用多种方法多种定义和使用future类型。</p>
<p>因为学习使用Rust中的futures编程有较大的挑战性，而且相关文档目前仍然较少，因此该项目的范围相对有限，相关的解释也比之前的项目更加直接。</p>
<p>请务必阅读有关此项目的背景资料。而如果您在本项目中感觉力不从心，那就让自己放松，休息一下，然后再试试。对于每个人来说，在Rust使用异步编程都是比较困难的。</p>
<h2 id="项目需求规格"><a href="#项目需求规格" class="headerlink" title="项目需求规格"></a>项目需求规格</h2><p>cargo项目<code>kvs</code>建立了一个名为<code>kvs-client</code>的命令行键值存储客户端，和一个名为<code>kvs-server</code>的键值存储服务端，二者又都调用了一个名为<code>kvs</code>的库。客户端通过一个自定义协议与服务端通信。</p>
<p>CLI参数与上一个项目中的相同。引擎实现大致相同，即通过线程池分发同步的文件I/O作业。</p>
<p>本项目的不同之处在于，所有的网络操作都是异步执行的。</p>
<p>为了实现异步操作，<code>KvsClient</code>将提供基于future的API，而<code>KvsEngine</code> trait也将提供基于future的API，尽管它是通过线程池使用同步（阻塞）I/O实现的。</p>
<p>您的<code>KvsServer</code>将基于tokio运行时，tokio将负责把异步作业分发给自己的多个线程（tokio自带的线程池）。这意味着您的架构中实际包含了两层线程池，第一层用来异步的处理网络请求，每个线程占用一个核心；第二层用来同步的处理文件I/O，使用充足的线程以保持负责处理网络的线程持续忙碌。</p>
<p>这种架构带来的变化，就是作业将从多个线程中生成到您的线程池，您的<code>ThreadPool</code> trait及其实现将变为实现了<code>Clone + Send + &#39;sync</code>的共享类型，就像<code>KvsEngine</code>那样。</p>
<p>因为您将实验多种不同的future返回方式，这里不再一一列出定义，而是在需要时定义。</p>
<p>更具体地说，您将使用以下所有函数签名：</p>
<ul>
<li><code>Client::get(&amp;mut self, key: String) -&gt; Box&lt;Future&lt;Item = Option&lt;String&gt;, Error = Error&gt;</code></li>
<li><code>Client::get(&amp;mut self, key: String) -&gt; future::SomeExplicitCombinator&lt;...&gt;</code></li>
<li><code>Client::get(&amp;mut self, key: String) -&gt; impl Future&lt;Item = Option&lt;String&gt;, Error = Error&gt;</code></li>
<li><code>Client::get(&amp;mut self, key: String) -&gt; ClientGetFuture</code></li>
</ul>
<h2 id="项目设置"><a href="#项目设置" class="headerlink" title="项目设置"></a>项目设置</h2><p>继续上一个项目，删除之前的测试目录，并复制本项目的测试目录。这个项目应该包含一个名为<code>kvs</code>的库，以及两个可执行文件，<code>kvs-server</code>和<code>kvs-client</code>。</p>
<p><code>Cargo.toml</code>中需要以下dev-dependencies：</p>
<figure class="highlight toml"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dev-dependencies]</span></span><br><span class="line"><span class="attr">assert_cmd</span> = <span class="string">&quot;0.11&quot;</span></span><br><span class="line"><span class="attr">criterion</span> = <span class="string">&quot;0.2.11&quot;</span></span><br><span class="line"><span class="attr">crossbeam-utils</span> = <span class="string">&quot;0.6.5&quot;</span></span><br><span class="line"><span class="attr">predicates</span> = <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.6.5&quot;</span></span><br><span class="line"><span class="attr">tempfile</span> = <span class="string">&quot;3.0.7&quot;</span></span><br><span class="line"><span class="attr">walkdir</span> = <span class="string">&quot;2.2.7&quot;</span></span><br><span class="line"><span class="attr">panic-control</span> = <span class="string">&quot;0.1.4&quot;</span></span><br></pre></td></tr></table></figure>

<p>与之前的项目不同，不必费心编写足够的类型定义来编译测试套件。因为这样做将会一次向前跳过多个步骤。文本将明确指出何时使用测试套件。</p>
<h2 id="知识背景：深入思考Rust中的future"><a href="#知识背景：深入思考Rust中的future" class="headerlink" title="知识背景：深入思考Rust中的future"></a>知识背景：深入思考Rust中的future</h2><ul>
<li>为什么使用future？网络 vs 文件/io，阻塞 vs 非阻塞，同步 vs 异步</li>
<li>从用户角度看future（不是以poll为核心的实现）</li>
<li>关于执行器和运行时的技术细节，不需要思考过多</li>
<li>考虑函数调用链及其如何转换为future类型</li>
<li>如何调试Rust类型</li>
<li><code>Result</code> vs <code>Future</code> vs <code>FutureResult</code></li>
<li>future的错误处理</li>
<li>确定的future vs 智能指针future vs 匿名future</li>
<li>关于future 0.1和future 0.3 的注意事项（我们将使用future 0.1）</li>
<li>关于async/await的注意事项</li>
</ul>
<h2 id="第1部分：将tokio引入客户端"><a href="#第1部分：将tokio引入客户端" class="headerlink" title="第1部分：将tokio引入客户端"></a>第1部分：将tokio引入客户端</h2><p>最终我们要将客户端和服务器都转换为future，由于客户端非常简单，我们就从这里入手。我们将首先在现有的同步KvsClient上，介绍tokio运行时。</p>
<p>这</p>
<p>对于客户端，我们将在保持同步<code>KvsClient</code>的同时引入异步运行时，然后再改造<code>KvsClient</code>。</p>
<p><code>KvsClient</code>的<code>connect</code>方法。</p>
<p>请注意，作为一个库，<code>KvsClient</code>可以提供基于futures的最高效率，但是我们的<code>kvs-client</code>可执行文件并没有利用它，所以这个可执行文件运行单个future就立刻退出的行为看起来有点傻。</p>
<p>TODO @sticnarf - 看看您是否可以编写与具体未来类型无关的测试用例，以便它们与以下所有策略一起使用。</p>
<h2 id="第2部分：将KvsClient转换为智能指针future"><a href="#第2部分：将KvsClient转换为智能指针future" class="headerlink" title="第2部分：将KvsClient转换为智能指针future"></a>第2部分：将<code>KvsClient</code>转换为智能指针future</h2><p>转为future类型时最省事的方式。</p>
<h2 id="第3部分：具有显式future类型的KvsClient"><a href="#第3部分：具有显式future类型的KvsClient" class="headerlink" title="第3部分：具有显式future类型的KvsClient"></a>第3部分：具有显式future类型的<code>KvsClient</code></h2><p>只是为了体验一下它是多么不靠谱。</p>
<h2 id="第4部分：具有匿名future类型的KvsClient"><a href="#第4部分：具有匿名future类型的KvsClient" class="headerlink" title="第4部分：具有匿名future类型的KvsClient"></a>第4部分：具有匿名future类型的<code>KvsClient</code></h2><p>最终的解决方案</p>
<h2 id="第5部分：使ThreadPool可共享"><a href="#第5部分：使ThreadPool可共享" class="headerlink" title="第5部分：使ThreadPool可共享"></a>第5部分：使<code>ThreadPool</code>可共享</h2><h2 id="第6部分：将KvsEngine转换为future"><a href="#第6部分：将KvsEngine转换为future" class="headerlink" title="第6部分：将KvsEngine转换为future"></a>第6部分：将<code>KvsEngine</code>转换为future</h2><p>对于服务器，我们将做在客户端中相反的事，为<code>KvsEngine</code>编写一个异步接口。这将表明future和底层运行时是相互独立的，并提供了一系列经验。</p>
<h2 id="第7部分：使用tokio驱动KvsEngine"><a href="#第7部分：使用tokio驱动KvsEngine" class="headerlink" title="第7部分：使用tokio驱动KvsEngine"></a>第7部分：使用tokio驱动<code>KvsEngine</code></h2><p>请注意，即使我们自己编写的异步代码很少，tokio本身也在<code>num_cpus</code>个线程间分发异步作业。权衡将CPU密集型作业直接放在网络线程或文件线程上的利弊，例如，将序列化操作放在哪里？</p>
<h2 id="扩展1：使用tokio-fs替换同步文件I-O"><a href="#扩展1：使用tokio-fs替换同步文件I-O" class="headerlink" title="扩展1：使用tokio-fs替换同步文件I/O"></a>扩展1：使用tokio-fs替换同步文件I/O</h2><p>干得漂亮，朋友。休息一下吧。</p>
<article class="message message-immersive is-success">
<div class="message-body">
<i class="fas fa-check-circle mr-2"></i>以下内容大多翻译自原文：<a target="_blank" rel="noopener" href="https://tokio.rs/tokio/tutorial">Tokio: Tutorial</a>，推荐阅读。
</div>
</article>

<h1 id="1-Tokio概述"><a href="#1-Tokio概述" class="headerlink" title="1 Tokio概述"></a>1 Tokio概述</h1><hr>
<p>Tokio是Rust的异步运行时，提供了编写网络应用程序所需的模块。Tokio可灵活部署在大多数系统中，从具有数十个内核的大型服务器到小型嵌入式设备。</p>
<p>概括的说，Tokio提供了几个主要组件：</p>
<ul>
<li>用于执行异步代码的多线程运行时。</li>
<li>标准库的异步版本。</li>
<li>一个庞大的相关库生态系统。</li>
</ul>
<h2 id="Tokio-在您的项目中的角色"><a href="#Tokio-在您的项目中的角色" class="headerlink" title="Tokio 在您的项目中的角色"></a>Tokio 在您的项目中的角色</h2><p>当您以异步方式编写应用程序时，您可以通过降低同时做许多事情的成本来提升性能。但是，异步Rust代码不会自行运行，因此您必须选择一个运行时来执行它们。Tokio库是应用最广泛的运行时，其使用量超过了所有其他运行时的总和。</p>
<p>此外，Tokio提供了许多有用的实用工具。编写异步代码时，不能使用Rust标准库提供的普通阻塞API，而必须使用它们的异步版本。这些替代版本由Tokio提供，在有意义时这些API将于Rust标准库API保持一致。</p>
<h2 id="Tokio的优势"><a href="#Tokio的优势" class="headerlink" title="Tokio的优势"></a>Tokio的优势</h2><p>本章将概述Tokio的一些优点。</p>
<h3 id="快速"><a href="#快速" class="headerlink" title="快速"></a>快速</h3><p>Tokio很<em>快</em>，基于Rust，而Rust本身也很快。遵循Rust精神，即目标是用户不应该通过手动编写等效代码来提高性能。</p>
<p>Tokio<em>可扩展</em>，基于async/await语言特性，本身就是可扩展的。在处理网络时，由于延迟，处理连接的速度受到限制，因此扩展的唯一方法是一次处理多个连接。使用async/await语言特性，可以非常方便的增加并发操作的数量，允许您扩展到大规模并发任务。</p>
<h3 id="可靠"><a href="#可靠" class="headerlink" title="可靠"></a>可靠</h3><p>Tokio基于Rust编写，而Rust是一种可以让开发者编写可靠且高效软件的语言。<a target="_blank" rel="noopener" href="https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/">大量</a><a target="_blank" rel="noopener" href="https://www.chromium.org/Home/chromium-security/memory-safety">研究</a>表明，大约70%的高危安全漏洞是由内存安全引起的。使用Rust可以消除应用程序中的这一类错误。</p>
<p>Tokio还非常注重提供一致的行为。Tokio的主要目标是允许用户部署行为可预测的软件，这些软件将日复一日地执行，具有可靠的响应时间，杜绝不可预测的延迟峰值。</p>
<h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><p>借助Rust的async/await特性，编写异步应用程序的复杂性已大大降低。结合Tokio的实用工具和充满活力的生态系统，编写应用程序变得轻而易举。</p>
<p>Tokio在有意义的情况下遵循标准库的命名约定，以使用户可以轻松地将使用标准库编写的代码转换为使用Tokio编写的代码。借助Rust的强大类型系统，轻松交付正确代码的能力是无与伦比的。</p>
<h3 id="灵活"><a href="#灵活" class="headerlink" title="灵活"></a>灵活</h3><p>Tokio提供了多种运行时架构。从多线程的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Work_stealing">工作窃取</a>运行时，到轻量级的单线程运行时，应有尽有。这些运行时中的每一个都带有许多可配置参数，以允许用户根据自己的需要调整它们。</p>
<h2 id="不适用Tokio的场景"><a href="#不适用Tokio的场景" class="headerlink" title="不适用Tokio的场景"></a>不适用Tokio的场景</h2><p>尽管Tokio对于许多需要同时做很多事情的项目很有用，但也有一些用例不适合Tokio。</p>
<ul>
<li>通过在多个线程上并发执行以提速的CPU密集型计算。Tokio专为IO密集型应用程序而设计，其中每个单独的任务大部分时间都在等待IO。如果您的应用程序唯一要做的就是并发计算，那么您应该使用<a target="_blank" rel="noopener" href="https://docs.rs/rayon/">rayon</a>。不过，如果您两种任务都做，仍然可以混合使用Tokio。</li>
<li>读取大量文件。尽管Tokio看上去对于只需要读取大量文件的项目很有用，但与普通线程池相比，Tokio在这里没有任何优势。因为操作系统通常不提供异步文件API。</li>
<li>发送单个Web请求。Tokio的优势是在需要同时做很多事情时。如果你需要使用一个用于异步Rust的库，例如<a target="_blank" rel="noopener" href="https://docs.rs/reqwest/">reqwest</a>，但你不需要一次做很多事情，你应该更喜欢那个库的阻塞版本，因为它会让你的项目更简单。当然，使用Tokio仍然有效，但与阻塞API相比并没有真正的优势。如果库不提供阻塞API，请参阅<a target="_blank" rel="noopener" href="https://tokio.rs/tokio/topics/bridging">桥接同步代码</a>章节。</li>
</ul>
<h2 id="获得帮助"><a href="#获得帮助" class="headerlink" title="获得帮助"></a>获得帮助</h2><p>在任何时候，如果您遇到困难，您总是可以在<a target="_blank" rel="noopener" href="https://discord.gg/tokio">Discord</a>或<a target="_blank" rel="noopener" href="https://github.com/tokio-rs/tokio/discussions">GitHub</a>讨论中获得帮助。请不要担心问“初学者”问题。我们都是从某个地方开始，并乐于提供帮助。</p>
<h1 id="2-环境设置"><a href="#2-环境设置" class="headerlink" title="2 环境设置"></a>2 环境设置</h1><hr>
<p>本教程将带您逐步完成构建Redis客户端和服务器的过程。我们将从使用Rust进行异步编程的基础知识开始，并从那里开始构建。我们将实现<a target="_blank" rel="noopener" href="https://redis.io/">Redis</a>命令的一个子集，以全面了解Tokio。</p>
<h2 id="Mini-Redis"><a href="#Mini-Redis" class="headerlink" title="Mini-Redis"></a>Mini-Redis</h2><p>您将在本教程中构建的项目在<a target="_blank" rel="noopener" href="https://github.com/tokio-rs/mini-redis">GitHub上以Mini-Redis</a> 的形式提供。Mini-Redis的主要目标是学习Tokio，也得到了很好的评价，但这也意味着Mini-Redis缺少一些您在真正的Redis库中需要的功能。您可以在<a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a>上找到可部署于生产环境的Redis库。</p>
<p>我们将在教程中直接使用Mini-Redis，也就是在教程后面部分实现Mini-Redis之前就提前使用。</p>
<h2 id="先修课"><a href="#先修课" class="headerlink" title="先修课"></a>先修课</h2><p>我们假设读者熟悉<a target="_blank" rel="noopener" href="https://rust-lang.org/">Rust</a>。<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/">《Rust Book》</a>就是很好的启蒙读物。</p>
<p>虽然不是必须的，但使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/">Rust标准库</a>或其他语言编写网络代码的经验将会有所帮助。</p>
<p>我们不需要读者熟悉Redis。</p>
<h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h3><p>在教程开始之前，您应该确保安装了Rust工具链。如果没有，最简单的安装方法是使用<a target="_blank" rel="noopener" href="https://rustup.rs/">rustup</a>。</p>
<p>教程需要不低于1.45.0的Rust版本，建议使用最新的Rust版本。</p>
<p>检查计算机上安装的Rust版本，执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustc --version</span><br></pre></td></tr></table></figure>

<p>您将会看到类似<code>rustc 1.46.0 (04488afe3 2020-08-24)</code>的输出。</p>
<h3 id="Mini-Redis-server"><a href="#Mini-Redis-server" class="headerlink" title="Mini-Redis server"></a>Mini-Redis server</h3><p>接下来，安装Mini-Redis server，以在我们完成客户端编写时进行测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo install mini-redis</span><br></pre></td></tr></table></figure>

<p>启动服务器以确定安装成功：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mini-redis-server</span><br></pre></td></tr></table></figure>

<p>然后，在另一个终端窗口中，尝试使用<code>mini-redis-cli</code>获取键<code>foo</code>的值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mini-redis-cli get foo</span><br></pre></td></tr></table></figure>

<p>你应该会看到输出为<code>(nil)</code>。</p>
<h2 id="万事俱备"><a href="#万事俱备" class="headerlink" title="万事俱备"></a>万事俱备</h2><p>如此，一切就绪。阅读下一章以编写您的第一个异步Rust应用程序。</p>
<h1 id="3-Hello-Tokio"><a href="#3-Hello-Tokio" class="headerlink" title="3 Hello Tokio"></a>3 Hello Tokio</h1><hr>
<p>作为开胃菜，我们将编写一个非常基础的Rust应用。它将连接到Mini-Redis server，将键<code>Hello</code>的值设置为<code>World</code>，然后再读回键。这将使用Mini-Redis client库完成。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="初始化新crate"><a href="#初始化新crate" class="headerlink" title="初始化新crate"></a>初始化新crate</h3><p>让我们从生成一个新的Rust App开始：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo new my-redis</span><br><span class="line"><span class="built_in">cd</span> my-redis</span><br></pre></td></tr></table></figure>

<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>然后，向<code>Cargo.toml</code>的<code>[dependencies]</code>中添加以下依赖：</p>
<figure class="highlight toml"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tokio</span> = &#123; version = <span class="string">&quot;1&quot;</span>, features = [<span class="string">&quot;full&quot;</span>] &#125;</span><br><span class="line"><span class="attr">mini-redis</span> = <span class="string">&quot;0.4&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><p>在<code>main.rs</code>编写如下代码：</p>
<figure class="highlight rust"><figcaption><span>main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> mini_redis::&#123;client, <span class="built_in">Result</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// Open a connection to the mini-redis address.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> client = client::connect(<span class="string">&quot;127.0.0.1:6379&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the key &quot;hello&quot; with value &quot;world&quot;</span></span><br><span class="line">    client.set(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>.into()).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get key &quot;hello&quot;</span></span><br><span class="line">    <span class="keyword">let</span> result = client.get(<span class="string">&quot;hello&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;got value from the server; result=&#123;:?&#125;&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确保Mini-Redis server正在运行，在单独的终端中执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mini-redis-server</span><br></pre></td></tr></table></figure>

<p>如果你还没有安装mini-redis，执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo install mini-redis</span><br></pre></td></tr></table></figure>

<p>现在，运行my-redis：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo run</span><br><span class="line">got value from the server; result=Some(b<span class="string">&quot;world&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>执行成功！</p>
<p>你可以在<a target="_blank" rel="noopener" href="https://github.com/tokio-rs/website/blob/master/tutorial-code/hello-tokio/src/main.rs">这里</a>找到全部代码。</p>
<h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><p>让我们花一些时间来理解刚刚做的事情。虽然没有太多代码，但执行了很多动作。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> client = client::connect(<span class="string">&quot;127.0.0.1:6379&quot;</span>).<span class="keyword">await</span>?;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://docs.rs/mini-redis/0.4/mini_redis/client/fn.connect.html"><code>client::connect</code></a>函数由<code>mini-Redis</code> Crate提供。它将异步的与指定的远端地址建立TCP连接，并在链接成功建立时返回<code>client</code>句柄。虽然这里执行了一个异步操作，但我们编写的代码<strong>看起来</strong>跟同步代码没什么区别。只有<code>.await</code>动作表明这个操作是异步的。</p>
<h3 id="什么是异步编程？"><a href="#什么是异步编程？" class="headerlink" title="什么是异步编程？"></a>什么是异步编程？</h3><p>大多数计算机程序会以与代码编写相同的顺序执行。先执行第一行，再执行下一行，依此类推。在同步编程中，当程序遇到无法立即完成的操作时，它将被阻塞直到操作完成。例如，建立TCP连接需要与网络上的其他节点交换数据，这可能需要大量时间，而在此期间，线程将被阻塞。</p>
<p>而在异步编程中，无法立即完成的操作在后台挂起。该线程没有被阻止，并且可以继续执行其他任务。一旦操作完成，挂起的任务就会恢复，并从挂起的位置继续执行。我们之前的示例中只有一个任务，因此在挂起时什么都没有发生，但是真正的异步程序通常具有大量此类任务。</p>
<p>尽管异步编程可以大幅提升应用程序的执行速度，但通常也会提升程序的复杂度。要求程序员在异步操作完成后跟踪所有可能的状态以恢复工作。以程序员的经验来说，这是一项繁琐且容易出错的任务。</p>
<h3 id="编译时绿色线程"><a href="#编译时绿色线程" class="headerlink" title="编译时绿色线程"></a>编译时绿色线程</h3><p>Rust使用称为<code>async/await</code>的特性来实现异步编程。执行异步操作的函数将用<code>async</code>关键字标记。在我们的示例中，<code>connect</code>函数是这样定义的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> mini_redis::<span class="built_in">Result</span>;</span><br><span class="line"><span class="keyword">use</span> mini_redis::client::Client;</span><br><span class="line"><span class="keyword">use</span> tokio::net::ToSocketAddrs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">connect</span></span>&lt;T: ToSocketAddrs&gt;(addr: T) -&gt; <span class="built_in">Result</span>&lt;Client&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>async fn</code>定义看起来像是常规的同步函数，但其实执行的是异步操作。Rust在<strong>编译时</strong>将<code>async fn</code>转换为一个异步运行的例程。在<code>async fn</code>中的任何<code>.await</code>动作都会将控制权转回线程，以使线程再异步操作挂起在后台的时间里继续执行其他工作。</p>
<article class="message is-danger">
<div class="message-body">
虽然其他语言也实现了<code>async/await</code>，但Rust采用了更独特的方法。最基础的，Rust的异步是惰性操作，这将会导致与其他语言不同的运行时语义。
</div>
</article>

<p>如果这个解释不够明确，请不要担心。在整个指南中，我们将探索更多关于<code>async/await</code>的内容。</p>
<h3 id="使用async-await"><a href="#使用async-await" class="headerlink" title="使用async/await"></a>使用<code>async/await</code></h3><p>在Rust中调用异步函数与调用普通函数没什么区别。但是，仅调用这些函数并不会执行函数体，而是会返回一个值用来表示<code>async fn</code>的操作。这在概念上类似于一个无参闭包。要实际运行该操作，您应该在返回值上使用<code>.await</code>运算符。</p>
<p>以下面的代码为例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">say_world</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Calling `say_world()` does not execute the body of `say_world()`.</span></span><br><span class="line">    <span class="keyword">let</span> op = say_world();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This println! comes first</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calling `.await` on `op` starts executing `say_world`.</span></span><br><span class="line">    op.<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>

<p><code>async fn</code>的返回值是一个实现了<code>Future</code> trait的匿名类型。</p>
<h3 id="异步main函数"><a href="#异步main函数" class="headerlink" title="异步main函数"></a>异步<code>main</code>函数</h3><p>用于启动异步应用程序的<code>main</code>函数，与大多数Rust crate中的常用<code>main</code>函数不同。</p>
<ol>
<li>这是一个<code>async fn</code></li>
<li>带有<code>#[tokio::main]</code>标记</li>
</ol>
<p>当我们想要进入异步上下文时，需要使用<code>async fn</code>。但是，异步函数必须由一个<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/runtime/index.html">运行时</a>执行。该运行时包含异步任务调度器，提供事件I/O、定时器等特性。运行时不会自动启动，所以需要main函数启动它。</p>
<p><code>#[tokio::main]</code>函数是一个宏。它将<code>async fn main()</code>转换为同步<code>fn main()</code>，初始化一个运行时实例并执行异步main函数。</p>
<p>例如，下面的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将转换为：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> rt = tokio::runtime::Runtime::new().unwrap();</span><br><span class="line">    rt.block_on(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面将会介绍关于Tokio运行时的详细信息。</p>
<h3 id="Cargo特性"><a href="#Cargo特性" class="headerlink" title="Cargo特性"></a>Cargo特性</h3><p>本教程依赖于Tokio，并启用了<code>full</code>特性：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tokio</span> = &#123; version = <span class="string">&quot;1&quot;</span>, features = [<span class="string">&quot;full&quot;</span>] &#125;</span><br></pre></td></tr></table></figure>

<p>Tokio有很多功能（TCP、UDP、Unix sockets、计时器、同步实用程序、多种调度程序等）。并非所有应用程序都需要完整的Tokio功能。在尝试优化编译时间或最终程序的大小时，用户可以只选择需要使用的功能。</p>
<p>在本教程中，选择Tokio依赖时将使用<code>full</code>功能。</p>
<h1 id="4-生成并发"><a href="#4-生成并发" class="headerlink" title="4 生成并发"></a>4 生成并发</h1><hr>
<p>我们将更换目标，开始研究Redis server端。</p>
<p>首先，将上一章客户端的<code>SET</code>/<code>GET</code>代码移至example文件。这样，就可以在我们的服务端上进行测试了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p examples</span><br><span class="line">mv src/main.rs examples/hello-redis.rs</span><br></pre></td></tr></table></figure>

<p>然后创建一个新的空<code>src/main.rs</code>文件。</p>
<h2 id="接受sockets"><a href="#接受sockets" class="headerlink" title="接受sockets"></a>接受sockets</h2><p>我们的Redis服务端需要做的第一件事是接受入站TCP sockets，即使用<code>tokio::net::TcpListener</code>。</p>
<article class="message">
<div class="message-body">
Tokio的许多类型的名称，与这些类型在Rust标准库中的同步版本相同。如果定义合理，Tokio将暴露与<code>std</code>完全相同的API，只不过是使用<code>async fn</code>。
</div>
</article>

<p><code>TcpListener</code>绑定到<code>6379</code>端口，并在循环中接受套sockets。每个socket都将被处理然后被关闭。现在，我们将读取命令，将其打印到标准输出并响应为一个错误。</p>
<figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::net::&#123;TcpListener, TcpStream&#125;;</span><br><span class="line"><span class="keyword">use</span> mini_redis::&#123;Connection, Frame&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Bind the listener to the address</span></span><br><span class="line">    <span class="keyword">let</span> listener = TcpListener::bind(<span class="string">&quot;127.0.0.1:6379&quot;</span>).<span class="keyword">await</span>.unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">// The second item contains the IP and port of the new connection.</span></span><br><span class="line">        <span class="keyword">let</span> (socket, _) = listener.accept().<span class="keyword">await</span>.unwrap();</span><br><span class="line">        process(socket).<span class="keyword">await</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">process</span></span>(socket: TcpStream) &#123;</span><br><span class="line">    <span class="comment">// The `Connection` lets us read/write redis **frames** instead of</span></span><br><span class="line">    <span class="comment">// byte streams. The `Connection` type is defined by mini-redis.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> connection = Connection::new(socket);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(frame) = connection.read_frame().<span class="keyword">await</span>.unwrap() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;GOT: &#123;:?&#125;&quot;</span>, frame);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Respond with an error</span></span><br><span class="line">        <span class="keyword">let</span> response = Frame::Error(<span class="string">&quot;unimplemented&quot;</span>.to_string());</span><br><span class="line">        connection.write_frame(&amp;response).<span class="keyword">await</span>.unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在运行这个循环：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure>

<p>在另一个终端里运行<code>hello-redis</code>的示例（即上一章那个<code>SET</code>/<code>GET</code>命令的例子）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run --example hello-redis</span><br></pre></td></tr></table></figure>

<p>输出应为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: <span class="string">&quot;unimplemented&quot;</span></span><br></pre></td></tr></table></figure>

<p>在服务端的终端窗口输出应为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOT: Array([Bulk(b<span class="string">&quot;set&quot;</span>), Bulk(b<span class="string">&quot;hello&quot;</span>), Bulk(b<span class="string">&quot;world&quot;</span>)])</span><br></pre></td></tr></table></figure>

<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>我们的服务端仍有个小问题（除了只响应错误）。它一次仅处理一个入站请求，当一个连接被接受时，服务器将停留在接受循环代码块内，直到响应完全写入socket。</p>
<p>我们希望Redis服务端能够并发处理<strong>大量</strong>请求，为此，我们需要添加一些并发性。</p>
<article class="message">
<div class="message-body">
并发和并行不是一回事。如果您在两个任务之间交替进行，那么您是在并发处理这两个任务，而不是并行处理。如果是并行，您需要两个人，每个人专门负责一项任务。
<br>
使用Tokio的优点之一，是异步代码允许您同时处理许多任务，而不必新建线程并行处理它们。事实上，Tokio可以在一个线程上并发运行多个任务！
</div>
</article>

<p>为了并发处理连接，我们将为每个入站连接生成一个新任务，并在此任务上处理连接。</p>
<p>接受连接的循环变为：</p>
<figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::net::TcpListener;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> listener = TcpListener::bind(<span class="string">&quot;127.0.0.1:6379&quot;</span>).<span class="keyword">await</span>.unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (socket, _) = listener.accept().<span class="keyword">await</span>.unwrap();</span><br><span class="line">        <span class="comment">// A new task is spawned for each inbound socket. The socket is</span></span><br><span class="line">        <span class="comment">// moved to the new task and processed there.</span></span><br><span class="line">        tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            process(socket).<span class="keyword">await</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>Tokio任务是一个异步绿色线程，通过将<code>async</code>块传给<code>tokio::spawn</code>创建。<code>tokio::spawn</code>函数返回一个<code>JoinHandle</code>，调用者可以使用它与生成的任务进行交互。<code>async</code>块可能会有返回值。调用者可以在<code>JoinHandle</code>上使用<code>.await</code>获取返回值。</p>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> handle = tokio::spawn(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="comment">// Do some async work</span></span><br><span class="line">        <span class="string">&quot;return value&quot;</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do some other work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> out = handle.<span class="keyword">await</span>.unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;GOT &#123;&#125;&quot;</span>, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等待<code>JoinHandle</code>返回一个<code>Result</code>。当任务在执行过程中遇到错误时，<code>JoinHandle</code>会返回一个<code>Err</code>，这将在任务panic、或任务因运行时关闭被强制取消时发生。</p>
<p>调度程序以任务为单位管理执行，生成任务将提交给Tokio调度程序，调度程序将确保在有工作要做时执行该任务。生成的任务可以在其生成的线程上执行，也可以在运行时其他线程上执行，该任务也可以在产生后在线程间移动。</p>
<p>Tokio中的任务非常轻量。实际上在底层，任务只需要一次64字节的内存分配。应用程序大可放心生成数千个乃至数百万个任务。</p>
<h3 id="39-static限制"><a href="#39-static限制" class="headerlink" title="&#39;static限制"></a><code>&#39;static</code>限制</h3><p>当您在Tokio运行时生成任务时，其类型的生命周期必须是<code>&#39;static</code>。这意味着生成的任务不得引用任务作用域外的任何数据。</p>
<article class="message">
<div class="message-body">
<code>'static</code>总是意味着“永远存在”是一个常见的误解，事实并非如此。仅仅因为一个值是<code>'static</code>并不意味着你有内存泄漏。你可以在<a target="_blank" rel="noopener" href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md#2-if-t-static-then-t-must-be-valid-for-the-entire-program"><b>常见的Rust生命周期误解</b></a>中了解到更多内容。
</div>
</article>

<p>比如下面的代码将无法通过编译：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::task;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    task::spawn(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Here&#x27;s a vec: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试编译将会产生如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">error[E0373]: async block may outlive the current function, but</span><br><span class="line">              it borrows `v`, which is owned by the current function</span><br><span class="line"> --&gt; src/main.rs:7:23</span><br><span class="line">  |</span><br><span class="line">7 |       task::spawn(async &#123;</span><br><span class="line">  |  _______________________^</span><br><span class="line">8 | |         println!(&quot;Here&#x27;s a vec: &#123;:?&#125;&quot;, v);</span><br><span class="line">  | |                                        - `v` is borrowed here</span><br><span class="line">9 | |     &#125;);</span><br><span class="line">  | |_____^ may outlive borrowed value `v`</span><br><span class="line">  |</span><br><span class="line">note: function requires argument type to outlive `&#x27;static`</span><br><span class="line"> --&gt; src/main.rs:7:17</span><br><span class="line">  |</span><br><span class="line">7 |       task::spawn(async &#123;</span><br><span class="line">  |  _________________^</span><br><span class="line">8 | |         println!(&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;, v);</span><br><span class="line">9 | |     &#125;);</span><br><span class="line">  | |_____^</span><br><span class="line">help: to force the async block to take ownership of `v` (and any other</span><br><span class="line">      referenced variables), use the `move` keyword</span><br><span class="line">  |</span><br><span class="line">7 |     task::spawn(async move &#123;</span><br><span class="line">8 |         println!(&quot;Here&#x27;s a vec: &#123;:?&#125;&quot;, v);</span><br><span class="line">9 |     &#125;);</span><br><span class="line">  |</span><br></pre></td></tr></table></figure>

<p>发生这种情况是因为默认情况下，变量所有权不会移动到异步代码块中。<code>v</code>向量仍然归主函数所有，而<code>println!</code>一行却借用<code>v</code>。rust编译器向我们解释这一点，甚至建议将第7行更改为<code>task::spawn(async move &#123;</code>，以告诉编译器将<code>v</code>移动到生成的任务中。如此，该任务拥有其需要的所有数据，使其成为<code>&#39;static</code>。</p>
<p>如果必须从多个任务同时访问单个数据，则该数据需要通过诸如<code>Arc</code>之类的同步原语来共享。</p>
<p>注意到错误消息说，参数类型超过了<code>&#39;static</code>生命周期。这个术语可能会相当迷惑，因为<code>&#39;static</code>生命周期一直持续到程序结束，所以如果超过它，不就是有内存泄漏吗？实际上这个消息说的是参数的类型，而不是其值必须超过<code>&#39;static</code>生命周期，并且值可能在其类型不再有效之前就被销毁。</p>
<p>当我们说一个值是<code>&#39;static</code>时，意味着永远保持该值不会是错的。这很重要，因为编译器无法推断新生成的任务会保留多长时间。我们必须确保允许任务永远存在，以便Tokio可以在需要时让任务运行起来。</p>
<p>上面信息框中链接的文章使用术语“受<code>&#39;static</code>限制”，而不是“它的类型比<code>&#39;static</code>寿命长”或“值是<code>&#39;static</code>”来指代<code>T: &#39;static</code>。这些都意味着同样的事情，但与<code>&amp;&#39;static T</code>中的“用<code>&#39;static&#39;</code>标识”不同。</p>
<h3 id="Send限制"><a href="#Send限制" class="headerlink" title="Send限制"></a><code>Send</code>限制</h3><p><code>tokio::spawn</code>生成的任务<strong>必须</strong>实现<code>Send</code>。这允许Tokio运行时在任务被<code>.await</code>挂起时，在线程之间移动它们。</p>
<p>当<code>.await</code>调用保存的所有数据都是<code>Send</code>时，任务也是<code>Send</code>的，这有点微妙。当调用<code>.await</code>时，任务将控制权转交给调度程序，在下次执行任务时，它会从上次转交的点恢复。为了确保这个策略生效，在<code>.await</code>之后使用的所有状态都必须由任务保存。如果这些状态为<code>Send</code>的，即可以跨线程移动，则任务本身就可以跨线程移动。相反，如果状态不是<code>Send</code>的，那么任务也不是。</p>
<p>这里的代码是有效的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::task::yield_now;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    tokio::spawn(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="comment">// The scope forces `rc` to drop before `.await`.</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> rc = Rc::new(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, rc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// `rc` is no longer used. It is **not** persisted when</span></span><br><span class="line">        <span class="comment">// the task yields to the scheduler</span></span><br><span class="line">        yield_now().<span class="keyword">await</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里则是无效的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::task::yield_now;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    tokio::spawn(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> rc = Rc::new(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// `rc` is used after `.await`. It must be persisted to</span></span><br><span class="line">        <span class="comment">// the task&#x27;s state.</span></span><br><span class="line">        yield_now().<span class="keyword">await</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, rc);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试编译会得到如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">error: future cannot be sent between threads safely</span><br><span class="line">   --&gt; src/main.rs:6:5</span><br><span class="line">    |</span><br><span class="line">6   |     tokio::spawn(async &#123;</span><br><span class="line">    |     ^^^^^^^^^^^^ future created by async block is not `Send`</span><br><span class="line">    | </span><br><span class="line">   ::: [..]spawn.rs:127:21</span><br><span class="line">    |</span><br><span class="line">127 |         T: Future + Send + &#x27;static,</span><br><span class="line">    |                     ---- required by this bound in</span><br><span class="line">    |                          `tokio::task::spawn::spawn`</span><br><span class="line">    |</span><br><span class="line">    = help: within `impl std::future::Future`, the trait</span><br><span class="line">    |       `std::marker::Send` is not  implemented for</span><br><span class="line">    |       `std::rc::Rc&lt;&amp;str&gt;`</span><br><span class="line">note: future is not `Send` as this value is used across an await</span><br><span class="line">   --&gt; src/main.rs:10:9</span><br><span class="line">    |</span><br><span class="line">7   |         let rc = Rc::new(&quot;hello&quot;);</span><br><span class="line">    |             -- has type `std::rc::Rc&lt;&amp;str&gt;` which is not `Send`</span><br><span class="line">...</span><br><span class="line">10  |         yield_now().await;</span><br><span class="line">    |         ^^^^^^^^^^^^^^^^^ await occurs here, with `rc` maybe</span><br><span class="line">    |                           used later</span><br><span class="line">11  |         println!(&quot;&#123;&#125;&quot;, rc);</span><br><span class="line">12  |     &#125;);</span><br><span class="line">    |     - `rc` is later dropped here</span><br></pre></td></tr></table></figure>

<p>我们将在下一章更深入地讨论这个错误的一个特例。</p>
<h2 id="保存值"><a href="#保存值" class="headerlink" title="保存值"></a>保存值</h2><p>我们现在将实现<code>process</code>函数来处理传入的命令，使用<code>HashMap</code>来存储值。<code>SET</code>命令将值插入到<code>HashMap</code>中，而<code>GET</code>值将读取这些值。此外，我们将使用循环从而让每个连接能够接受多个命令。</p>
<figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::net::TcpStream;</span><br><span class="line"><span class="keyword">use</span> mini_redis::&#123;Connection, Frame&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">process</span></span>(socket: TcpStream) &#123;</span><br><span class="line">    <span class="keyword">use</span> mini_redis::Command::&#123;<span class="keyword">self</span>, Get, Set&#125;;</span><br><span class="line">    <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A hashmap is used to store data</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> db = HashMap::new();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Connection, provided by `mini-redis`, handles parsing frames from</span></span><br><span class="line">    <span class="comment">// the socket</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> connection = Connection::new(socket);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use `read_frame` to receive a command from the connection.</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(frame) = connection.read_frame().<span class="keyword">await</span>.unwrap() &#123;</span><br><span class="line">        <span class="keyword">let</span> response = <span class="keyword">match</span> Command::from_frame(frame).unwrap() &#123;</span><br><span class="line">            Set(cmd) =&gt; &#123;</span><br><span class="line">                <span class="comment">// The value is stored as `Vec&lt;u8&gt;`</span></span><br><span class="line">                db.insert(cmd.key().to_string(), cmd.value().to_vec());</span><br><span class="line">                Frame::Simple(<span class="string">&quot;OK&quot;</span>.to_string())</span><br><span class="line">            &#125;</span><br><span class="line">            Get(cmd) =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(value) = db.get(cmd.key()) &#123;</span><br><span class="line">                    <span class="comment">// `Frame::Bulk` expects data to be of type `Bytes`. This</span></span><br><span class="line">                    <span class="comment">// type will be covered later in the tutorial. For now,</span></span><br><span class="line">                    <span class="comment">// `&amp;Vec&lt;u8&gt;` is converted to `Bytes` using `into()`.</span></span><br><span class="line">                    Frame::Bulk(value.clone().into())</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Frame::Null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cmd =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;unimplemented &#123;:?&#125;&quot;</span>, cmd),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write the response to the client</span></span><br><span class="line">        connection.write_frame(&amp;response).<span class="keyword">await</span>.unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，启动服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure>

<p>在另一个终端里运行<code>hello-redis</code>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run --example hello-redis</span><br></pre></td></tr></table></figure>

<p>现在的输出应为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">got value from server; result=Some(b<span class="string">&quot;world&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>我们现在可以查询和设置键值了，但是有一个问题：这些键值并不能在连接之间共享。如果另一个套接字连接并尝试<code>GET</code>键<code>hello</code>，它将查询不到任何东西。</p>
<p>你可以在<a target="_blank" rel="noopener" href="https://github.com/tokio-rs/website/blob/master/tutorial-code/spawning/src/main.rs">这里</a>找到完整的代码。</p>
<p>在下一章中，我们将为所有套接字实现数据持久化。</p>
<h1 id="5-共享状态"><a href="#5-共享状态" class="headerlink" title="5 共享状态"></a>5 共享状态</h1><hr>
<p>到目前为止，我们有了键值服务端，但却存在一个缺陷：状态并未在连接之间共享。本文将解决这个问题。</p>
<h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>在Tokio中共享状态通常有以下几种方式。</p>
<ol>
<li>使用互斥锁封装共享状态。</li>
<li>再生成一个任务，专门用于管理状态，并使用消息传递操作状态。</li>
</ol>
<p>第一种方法通常用于简单数据，而第二种方法用于需要异步工作（例如I/O原语）的场景。在本章中，共享状态是一个<code>hashmap</code>，并且操作是<code>insert</code>和<code>get</code>。这些操作都不是异步的，因此我们将使用互斥锁<code>Mutex</code>。</p>
<p>下一章将介绍后一种方法。</p>
<h2 id="添加bytes依赖"><a href="#添加bytes依赖" class="headerlink" title="添加bytes依赖"></a>添加<code>bytes</code>依赖</h2><p>Mini-Redis crate将使用<a target="_blank" rel="noopener" href="https://docs.rs/bytes/1/bytes/struct.Bytes.html"><code>bytes</code></a> crate的<code>Bytes</code>代替<code>Vec&lt;u8&gt;</code>。<code>Bytes</code>专门用于为网络编程提供强大的字节阵列结构。相较于<code>Vec&lt;u8&gt;</code>，它添加了强大的浅拷贝功能。换句话说，在<code>Bytes</code>实例上调用<code>clone()</code>将不会复制底层数据，只会让实例的引用计数器加一，即<code>Byte</code>实例仅是某个底层数据的引用计数器句柄，类似于添加了新功能的<code>Arc&lt;Vec&lt;u8&gt;&gt;</code>。</p>
<p>要使用<code>bytes</code>，请在<code>Cargo.toml</code>的<code>[dependencies]</code>中添加以下内容：</p>
<figure class="highlight toml"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">bytes</span> = <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="初始化HashMap"><a href="#初始化HashMap" class="headerlink" title="初始化HashMap"></a>初始化<code>HashMap</code></h2><p>为了让<code>hashmap</code>能够在许多任务和许多线程中共享，需要将其封装在<code>Arc&lt;Mutex&lt;_&gt;&gt;</code>中。</p>
<p>首先，为方便使用，在<code>use</code>之后给该类型起别名。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> bytes::Bytes;</span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Db</span></span> = Arc&lt;Mutex&lt;HashMap&lt;<span class="built_in">String</span>, Bytes&gt;&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p>然后，更新<code>main</code>函数以初始化<code>Hashmap</code>并将<code>Arc</code>的句柄传给<code>process</code>函数。使用<code>Arc</code>允许从许多任务中同时引用<code>Hashmap</code>，并可能在许多线程上运行。在整个Tokio中，术语<strong>句柄</strong>指的是那些可以访问某些共享状态的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::net::TcpListener;</span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> listener = TcpListener::bind(<span class="string">&quot;127.0.0.1:6379&quot;</span>).<span class="keyword">await</span>.unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Listening&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> db = Arc::new(Mutex::new(HashMap::new()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (socket, _) = listener.accept().<span class="keyword">await</span>.unwrap();</span><br><span class="line">        <span class="comment">// Clone the handle to the hash map.</span></span><br><span class="line">        <span class="keyword">let</span> db = db.clone();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Accepted&quot;</span>);</span><br><span class="line">        tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            process(socket, db).<span class="keyword">await</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关于使用std-sync-Mutex"><a href="#关于使用std-sync-Mutex" class="headerlink" title="关于使用std::sync::Mutex"></a>关于使用<code>std::sync::Mutex</code></h3><p>注意这里使用了<code>std::sync::mutex</code>而不是<code>tokio::sync::Mutex</code>来封装<code>Hashmap</code>。一个常见的错误是在异步代码中无条件使用<code>tokio::sync::mutex</code>。异步互斥锁用于锁住所有<code>.await</code>操作。</p>
<p>同步互斥锁在等待获取锁定时会阻塞当前线程，于是，将阻止其他任务处理。而如果使用<code>tokio::sync::Mutex</code>通常没有作用，因为异步互斥锁的在内部也使用同步互斥锁。</p>
<p>根据经验，只要竞争不高，并且不会在调用<code>.await</code>时保持锁，则使用异步代码内的同步互斥锁也是可以的。此外，也可以考虑使用<a target="_blank" rel="noopener" href="https://docs.rs/parking_lot/0.10.2/parking_lot/type.Mutex.html"><code>parking_lot::mutex</code></a>作为<code>std::sync::Mutex</code>的更快替代方案。</p>
<h2 id="修改process"><a href="#修改process" class="headerlink" title="修改process()"></a>修改<code>process()</code></h2><p><code>process()</code>函数不再需要初始化<code>Hashmap</code>，现在，它将接受一个共享的句柄作为参数，并且需要在使用前锁定该<code>Hashmap</code>。要注意的是<code>Hashmap</code>的值现在是<code>Bytes</code>类型（可以高效的复制），因此也需要修改。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::net::TcpStream;</span><br><span class="line"><span class="keyword">use</span> mini_redis::&#123;Connection, Frame&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">process</span></span>(socket: TcpStream, db: Db) &#123;</span><br><span class="line">    <span class="keyword">use</span> mini_redis::Command::&#123;<span class="keyword">self</span>, Get, Set&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Connection, provided by `mini-redis`, handles parsing frames from</span></span><br><span class="line">    <span class="comment">// the socket</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> connection = Connection::new(socket);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(frame) = connection.read_frame().<span class="keyword">await</span>.unwrap() &#123;</span><br><span class="line">        <span class="keyword">let</span> response = <span class="keyword">match</span> Command::from_frame(frame).unwrap() &#123;</span><br><span class="line">            Set(cmd) =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut</span> db = db.lock().unwrap();</span><br><span class="line">                db.insert(cmd.key().to_string(), cmd.value().clone());</span><br><span class="line">                Frame::Simple(<span class="string">&quot;OK&quot;</span>.to_string())</span><br><span class="line">            &#125;           </span><br><span class="line">            Get(cmd) =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> db = db.lock().unwrap();</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(value) = db.get(cmd.key()) &#123;</span><br><span class="line">                    Frame::Bulk(value.clone())</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Frame::Null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cmd =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;unimplemented &#123;:?&#125;&quot;</span>, cmd),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write the response to the client</span></span><br><span class="line">        connection.write_frame(&amp;response).<span class="keyword">await</span>.unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="任务、线程与竞争"><a href="#任务、线程与竞争" class="headerlink" title="任务、线程与竞争"></a>任务、线程与竞争</h2><p>当竞争较少时，使用互斥锁阻保护少量关键变量是可行的策略。当出现锁竞争时，执行任务的线程将会阻塞并等待互斥锁释放。这不仅会阻塞当前任务，而且还将阻止在当前线程上调度任何其他任务。</p>
<p>默认情况下，Tokio运行时使用多线程调度程序。任务被安排在由运行时管理的任意数量的线程上。如果需要调度执行大量任务，并且他们都需要访问互斥锁，则将产生竞争。不过，如果启用了<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/runtime/index.html#current-thread-scheduler"><code>current_thread</code></a>运行时，则永远不会产生互斥锁竞争。</p>
<article class="message">
<div class="message-body">
<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/runtime/struct.Builder.html#method.new_current_thread"><code>current_thread</code><b>运行时</b></a>是一个轻量级的单线程运行时。当仅需生成少量任务并打开少量sockets时，这是一个不错的选择。例如，当在异步客户端库之上提供同步API时，就可以使用这个选项。
</div>
</article>

<p>即使同步互斥锁竞争成为问题，也很少使用Tokio的互斥锁，而是应当考虑：</p>
<ol>
<li>使用一个专用任务，以管理状态并使用消息传递。</li>
<li>互斥锁分片。</li>
<li>重组代码以避免使用互斥锁。</li>
</ol>
<p>在我们的例子中，由于各个<em>键</em>相互独立，因此可以选择将互斥锁分片。因此，我们将用<code>N</code>个不同的实例代替例子中的单个<code>Mutex&lt;HashMap&lt;_, _&gt;&gt;</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">ShardedDb</span></span> = Arc&lt;<span class="built_in">Vec</span>&lt;Mutex&lt;HashMap&lt;<span class="built_in">String</span>, <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;&gt;&gt;&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">new_sharded_db</span></span>(num_shards: <span class="built_in">usize</span>) -&gt; ShardedDb &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> db = <span class="built_in">Vec</span>::with_capacity(num_shards);</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..num_shards &#123;</span><br><span class="line">        db.push(Mutex::new(HashMap::new()));</span><br><span class="line">    &#125;</span><br><span class="line">    Arc::new(db)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此，找到任何给定键就需要两个步骤：先是要确定该键在哪个分片中，再在这个<code>HashMap</code>中查找该键。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shard = db[hash(key) % db.len()].lock().unwrap();</span><br><span class="line">shard.insert(key, value);</span><br></pre></td></tr></table></figure>

<p>上面的这段简单实现要求确定的分片数量，而且一旦创建了分片映射分片数量就不能更改。<a target="_blank" rel="noopener" href="https://docs.rs/dashmap"><code>dashmap</code></a> crate提供了一个更复杂的分片哈希映射的实现。</p>
<h2 id="在-await上持有MutexGuard"><a href="#在-await上持有MutexGuard" class="headerlink" title="在.await上持有MutexGuard"></a>在<code>.await</code>上持有<code>MutexGuard</code></h2><p>你可能会编写这样的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Mutex, MutexGuard&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">increment_and_do_stuff</span></span>(mutex: &amp;Mutex&lt;<span class="built_in">i32</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> lock: MutexGuard&lt;<span class="built_in">i32</span>&gt; = mutex.lock().unwrap();</span><br><span class="line">    *lock += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    do_something_async().<span class="keyword">await</span>;</span><br><span class="line">&#125; <span class="comment">// lock goes out of scope here</span></span><br></pre></td></tr></table></figure>

<p>当你尝试并发调用那些调用此函数的代码时，将遇到以下错误消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">error: future cannot be sent between threads safely</span><br><span class="line">   --&gt; src/lib.rs:13:5</span><br><span class="line">    |</span><br><span class="line">13  |     tokio::spawn(async move &#123;</span><br><span class="line">    |     ^^^^^^^^^^^^ future created by async block is not `Send`</span><br><span class="line">    |</span><br><span class="line">   ::: /playground/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-0.2.21/src/task/spawn.rs:127:21</span><br><span class="line">    |</span><br><span class="line">127 |         T: Future + Send + &#x27;static,</span><br><span class="line">    |                     ---- required by this bound in `tokio::task::spawn::spawn`</span><br><span class="line">    |</span><br><span class="line">    = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `std::sync::MutexGuard&lt;&#x27;_, i32&gt;`</span><br><span class="line">note: future is not `Send` as this value is used across an await</span><br><span class="line">   --&gt; src/lib.rs:7:5</span><br><span class="line">    |</span><br><span class="line">4   |     let mut lock: MutexGuard&lt;i32&gt; = mutex.lock().unwrap();</span><br><span class="line">    |         -------- has type `std::sync::MutexGuard&lt;&#x27;_, i32&gt;` which is not `Send`</span><br><span class="line">...</span><br><span class="line">7   |     do_something_async().await;</span><br><span class="line">    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ await occurs here, with `mut lock` maybe used later</span><br><span class="line">8   | &#125;</span><br><span class="line">    | - `mut lock` is later dropped here</span><br></pre></td></tr></table></figure>

<p>这是因为<code>std::sync::MutexGuard</code>类型不可<code>Send</code>，即你不能将互斥锁发送到另一个线程，于是这将导致错误，因为Tokio运行时可以在每个<code>.await</code>时在线程间移动任务。为避免这种情况，你应该重组代码，使互斥锁在<code>.await</code>之前析构：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This works!</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">increment_and_do_stuff</span></span>(mutex: &amp;Mutex&lt;<span class="built_in">i32</span>&gt;) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> lock: MutexGuard&lt;<span class="built_in">i32</span>&gt; = mutex.lock().unwrap();</span><br><span class="line">        *lock += <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="comment">// lock goes out of scope here</span></span><br><span class="line"></span><br><span class="line">    do_something_async().<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意这样也不行：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Mutex, MutexGuard&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This fails too.</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">increment_and_do_stuff</span></span>(mutex: &amp;Mutex&lt;<span class="built_in">i32</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> lock: MutexGuard&lt;<span class="built_in">i32</span>&gt; = mutex.lock().unwrap();</span><br><span class="line">    *lock += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">drop</span>(lock);</span><br><span class="line"></span><br><span class="line">    do_something_async().<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前，编译器仅根据作用域推断future是否为<code>Send</code>。将来，编译器可能会支持显式析构，但现在，您只能使用显式作用域。</p>
<p>请注意，这里讨论的错误也在<a href=".#Send%E9%99%90%E5%88%B6">并发一章的<code>Send</code>限制小节</a>中讨论过。</p>
<p>如果您想尝试某种方式，通过生成不需要<code>Send</code>的并发任务来绕过此问题，是不可行的。因为如果Tokio在任务持有锁时将任务挂起在<code>.await</code>处，则可能会在同一线程上调度运行其他任务，而这里的其他任务也可能尝试获取该互斥锁，这将导致死锁，即等待获取互斥锁的任务会阻塞持有互斥锁的任务释放锁。</p>
<p>下面我们将讨论一些上述错误消息的方法：</p>
<h3 id="重构你的代码，不跨-await持锁"><a href="#重构你的代码，不跨-await持锁" class="headerlink" title="重构你的代码，不跨.await持锁"></a>重构你的代码，不跨<code>.await</code>持锁</h3><p>我们已经在上面的代码片段中看到了一个例子，但是还有一些更健壮的代码实现。例如，你可以将互斥锁包装在一个结构体中，并只在非异步方法中锁定互斥锁：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CanIncrement</span></span> &#123;</span><br><span class="line">    mutex: Mutex&lt;<span class="built_in">i32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> CanIncrement &#123;</span><br><span class="line">    <span class="comment">// This function is not marked async.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">increment</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> lock = <span class="keyword">self</span>.mutex.lock().unwrap();</span><br><span class="line">        *lock += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">increment_and_do_stuff</span></span>(can_incr: &amp;CanIncrement) &#123;</span><br><span class="line">    can_incr.increment();</span><br><span class="line">    do_something_async().<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种模式保证你不会遇到<code>Send</code>错误，因为<code>MutexGuard</code>不会出现在异步函数中。</p>
<h3 id="生成一个任务来管理状态并使用消息传递对其进行操作"><a href="#生成一个任务来管理状态并使用消息传递对其进行操作" class="headerlink" title="生成一个任务来管理状态并使用消息传递对其进行操作"></a>生成一个任务来管理状态并使用消息传递对其进行操作</h3><p>这是本章开头提到的第二种方法，通常在共享的资源是I/O资源时使用。有关详细信息，请参阅下一章。</p>
<h3 id="使用Tokio的异步互斥锁"><a href="#使用Tokio的异步互斥锁" class="headerlink" title="使用Tokio的异步互斥锁"></a>使用Tokio的异步互斥锁</h3><p>也可以使用Tokio提供的<code>tokio::sync::Mutex</code>类型。Tokio互斥锁的主要特性是它可以跨<code>.await</code> 保存而不会出现任何问题。也就是说，异步互斥锁比普通互斥锁开销更大，因此一般建议从前面两种方法中选一种实现。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::sync::Mutex; <span class="comment">// note! This uses the Tokio mutex</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This compiles!</span></span><br><span class="line"><span class="comment">// (but restructuring the code would be better in this case)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">increment_and_do_stuff</span></span>(mutex: &amp;Mutex&lt;<span class="built_in">i32</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> lock = mutex.lock().<span class="keyword">await</span>;</span><br><span class="line">    *lock += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    do_something_async().<span class="keyword">await</span>;</span><br><span class="line">&#125; <span class="comment">// lock goes out of scope here</span></span><br></pre></td></tr></table></figure>

<h1 id="6-消息通道"><a href="#6-消息通道" class="headerlink" title="6 消息通道"></a>6 消息通道</h1><hr>
<p>现在我们已经了解了一些关于Tokio的并发性，现在让我们在客户端上应用它。把我们之前写的服务端代码放到一个显式的二进制文件中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir src/bin</span><br><span class="line">mv src/main.rs src/bin/server.rs</span><br></pre></td></tr></table></figure>

<p>创建一个包含客户端代码的新二进制文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch src/bin/client.rs</span><br></pre></td></tr></table></figure>

<p>在此文件中，您将编写本章的代码。要记住在运行客户端前，必须首先在单独的终端中启动服务端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run --bin server</span><br></pre></td></tr></table></figure>

<p>再用<strong>单独</strong>的终端里运行客户端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run --bin client</span><br></pre></td></tr></table></figure>

<p>让我们开始编码！</p>
<p>假设我们要并发执行两个Redis命令。我们可以为每个命令生成一个任务，然后这两个命令将同时发生。</p>
<p>起初，我们可能会进行如下尝试：</p>
<figure class="highlight rust"><figcaption><span>src/bin/client.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> mini_redis::client;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Establish a connection to the server</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> client = client::connect(<span class="string">&quot;127.0.0.1:6379&quot;</span>).<span class="keyword">await</span>.unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spawn two tasks, one gets a key, the other sets a key</span></span><br><span class="line">    <span class="keyword">let</span> t1 = tokio::spawn(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> res = client.get(<span class="string">&quot;hello&quot;</span>).<span class="keyword">await</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> t2 = tokio::spawn(<span class="keyword">async</span> &#123;</span><br><span class="line">        client.set(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>.into()).<span class="keyword">await</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.<span class="keyword">await</span>.unwrap();</span><br><span class="line">    t2.<span class="keyword">await</span>.unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码无法通过编译，因为这两个任务都需要以某种方式访问<code>client</code>。由于<code>Client</code>没有实现<code>Copy</code>，所以如果没有一些代码来实现共享，就无法编译。此外，<code>Client::set</code>采用<code>&amp;mut self</code>，这意味着需要互斥存取才能调用。我们可以为每个任务打开一个连接，但这并不理想。我们不能使用<code>std::sync::Mutex</code>因为<code>.await</code>需要在持有锁的情况下调用。我们可以使用<code>tokio::sync::Mutex</code>，但这只会允许一个运行中的请求。如果客户端实现了<a target="_blank" rel="noopener" href="https://redis.io/topics/pipelining">流水线</a>，异步互斥锁还将导致连接不能被充分利用。</p>
<h2 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h2><p>解决方案是使用消息传递。该模式需要生成一个专门的任务来管理<code>client</code>资源。任何希望发出请求的任务，都会向<code>client</code>任务发送消息。<code>client</code>任务代理发送者发出请求，并将响应返回给发送者。</p>
<p>使用此策略，可以只建立一个连接。<code>client</code>管理任务能够获得互斥存取权限，以便调用<code>get</code>和<code>set</code>。此外，通道也起到了缓冲区的作用。即使<code>client</code>任务忙时，操作也可能会被发送到<code>client</code>任务。当<code>client</code>任务可用于处理新请求时，它就会从通道中获取下一个请求。这可以带来更好的吞吐量，并可扩展以支持连接池。</p>
<h2 id="Tokio的通道原语"><a href="#Tokio的通道原语" class="headerlink" title="Tokio的通道原语"></a>Tokio的通道原语</h2><p>Tokio提供了<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/sync/index.html">许多通道</a>，每个通道都有不同的用途。</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/sync/mpsc/index.html">mpsc</a>：多生产者，单消费者通道。可以发送许多值。</li>
<li><a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/sync/oneshot/index.html">oneshot</a>：单生产者，单消费者渠道。可以发送单个值。</li>
<li><a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/sync/broadcast/index.html">broadcast</a>：多生产者，多消费者。可以发送许多值，每个消费者都能看到每个值。</li>
<li><a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/sync/watch/index.html">watch</a>：单生产者，多消费者。可以发送许多值，但不保留任何历史记录。消费者只能看到最新的值。</li>
</ol>
<p>如果您需要一个多生产者多消费者通道，其中只有一个消费者可以看到每条消息，您可以使用<a target="_blank" rel="noopener" href="https://docs.rs/async-channel/"><code>async-channel</code></a> crate。在异步Rust之外还有一些通道可以使用，例如<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/sync/mpsc/index.html"><code>std::sync::mpsc</code></a>和<a target="_blank" rel="noopener" href="https://docs.rs/crossbeam/latest/crossbeam/channel/index.html"><code>crossbeam::channel</code></a>。这些通道在等待消息时将阻塞线程，这在异步代码中是不允许的。</p>
<p>在本节中，我们将使用<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/sync/mpsc/index.html">mpsc</a>和<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/sync/oneshot/index.html">oneshot</a>，其他类型的消息传递通道将在后面的章节中探讨。你可在<a target="_blank" rel="noopener" href="https://github.com/tokio-rs/website/blob/master/tutorial-code/channels/src/main.rs">这里</a>找到本节的完整代码。</p>
<h2 id="定义消息类型"><a href="#定义消息类型" class="headerlink" title="定义消息类型"></a>定义消息类型</h2><p>在大多数情况下，当使用消息传递时，接收消息的任务会响应多个命令。在我们的例子中，任务将响应<code>GET</code>和<code>SET</code>命令。为了对此建模，我们首先定义一个<code>Command</code>枚举并为每个命令指定一个成员变量。</p>
<figure class="highlight rust"><figcaption><span>src/bin/client.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> bytes::Bytes;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Command</span></span> &#123;</span><br><span class="line">    Get &#123;</span><br><span class="line">        key: <span class="built_in">String</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    Set &#123;</span><br><span class="line">        key: <span class="built_in">String</span>,</span><br><span class="line">        val: Bytes,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建通道"><a href="#创建通道" class="headerlink" title="创建通道"></a>创建通道</h2><p>在<code>main</code>函数中新建一个<code>mpsc</code>通道：</p>
<figure class="highlight rust"><figcaption><span>src/bin/client.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Create a new channel with a capacity of at most 32.</span></span><br><span class="line">    <span class="keyword">let</span> (tx, <span class="keyword">mut</span> rx) = mpsc::channel(<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... Rest comes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mpsc</code>通道用于向管理redis连接的任务发送命令，多生产者特性允许从多个任务发送消息。创建通道返回两个值，一个发送端和一个接收端，两个句柄各有用处。他们可能会被转移到不同的任务中。</p>
<p>创建通道的容量为32，如果消息的发送速度快于接收速度，通道将存储它们。一旦有32条消息存储在通道中，调用<code>send(...).await</code>就将进入睡眠状态，直到接收方取走了一条消息为止。</p>
<p>从多个任务发送是通过<strong>克隆</strong><code>Sender</code>来完成的。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, <span class="keyword">mut</span> rx) = mpsc::channel(<span class="number">32</span>);</span><br><span class="line">    <span class="keyword">let</span> tx2 = tx.clone();</span><br><span class="line"></span><br><span class="line">    tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        tx.send(<span class="string">&quot;sending from first handle&quot;</span>).<span class="keyword">await</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        tx2.send(<span class="string">&quot;sending from second handle&quot;</span>).<span class="keyword">await</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(message) = rx.recv().<span class="keyword">await</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;GOT = &#123;&#125;&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两条消息都发送到同一个<code>Receiver</code>句柄。<code>mpsc</code>通道的接收端无法被克隆。</p>
<p>当所有<code>Sender</code>超出作用域或是被析构时，就无法再向通道发送更多消息。此时，在<code>Receiver</code>上调用<code>recv</code>会返回<code>None</code>，表示所有发送端都不在了，通道已关闭。</p>
<p>在我们管理Redis连接的任务中，当通道关闭时该任务就将关闭Redis连接，因为该连接将不再被使用。</p>
<h2 id="生成管理任务"><a href="#生成管理任务" class="headerlink" title="生成管理任务"></a>生成管理任务</h2><p>接下来，生成一个专门处理通道的消息的任务。首先，客户端建立到Redis服务端的连接；然后，通过Redis连接发送收到的命令。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> mini_redis::client;</span><br><span class="line"><span class="comment">// The `move` keyword is used to **move** ownership of `rx` into the task.</span></span><br><span class="line"><span class="keyword">let</span> manager = tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">    <span class="comment">// Establish a connection to the server</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> client = client::connect(<span class="string">&quot;127.0.0.1:6379&quot;</span>).<span class="keyword">await</span>.unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start receiving messages</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(cmd) = rx.recv().<span class="keyword">await</span> &#123;</span><br><span class="line">        <span class="keyword">use</span> Command::*;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">match</span> cmd &#123;</span><br><span class="line">            Get &#123; key &#125; =&gt; &#123;</span><br><span class="line">                client.get(&amp;key).<span class="keyword">await</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Set &#123; key, val &#125; =&gt; &#123;</span><br><span class="line">                client.set(&amp;key, val).<span class="keyword">await</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>现在可以修改任务，使用通道发送命令，以代替直接使用Redis连接发送命令。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The `Sender` handles are moved into the tasks. As there are two</span></span><br><span class="line"><span class="comment">// tasks, we need a second `Sender`.</span></span><br><span class="line"><span class="keyword">let</span> tx2 = tx.clone();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spawn two tasks, one gets a key, the other sets a key</span></span><br><span class="line"><span class="keyword">let</span> t1 = tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cmd = Command::Get &#123;</span><br><span class="line">        key: <span class="string">&quot;hello&quot;</span>.to_string(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    tx.send(cmd).<span class="keyword">await</span>.unwrap();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> t2 = tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cmd = Command::Set &#123;</span><br><span class="line">        key: <span class="string">&quot;foo&quot;</span>.to_string(),</span><br><span class="line">        val: <span class="string">&quot;bar&quot;</span>.into(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    tx2.send(cmd).<span class="keyword">await</span>.unwrap();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在<code>main</code>函数最后，在join句柄上使用<code>.await</code>，以确保命令在进程退出前能够执行完毕。</p>
<h2 id="接收响应"><a href="#接收响应" class="headerlink" title="接收响应"></a>接收响应</h2><p>最后一步是从管理任务接收响应。<code>GET</code>命令需要获取值，而<code>SET</code>命令需要知道操作是否成功完成。</p>
<p>我们使用<code>oneshot</code>通道，以传递响应。<code>oneShot</code>通道是一种单次生产、单次消费的通道，专门针对对发送单个值的场景进行了优化。在我们的例子中，这单个值就是响应。</p>
<p>和<code>MPSC</code>类似，<code>oneShot::Channel()</code>返回一对发送端、接收端句柄。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::sync::oneshot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> (tx, rx) = oneshot::channel();</span><br></pre></td></tr></table></figure>

<p>与<code>mpsc</code>不同的是，它无需指定通道数量，因为始终是一，此外，这两个句柄都不能克隆。</p>
<p>要从管理任务接收响应，在发送命令之前，就应创建<code>oneshot</code>通道。通道的发送端包含在命令中传给管理任务，接收端则用于接收响应结果。</p>
<p>首先，修改<code>Command</code>以包含<code>Sender</code>。为了方便起见，使用类型别名来指代<code>Sender</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::sync::oneshot;</span><br><span class="line"><span class="keyword">use</span> bytes::Bytes;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Multiple different commands are multiplexed over a single channel.</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Command</span></span> &#123;</span><br><span class="line">    Get &#123;</span><br><span class="line">        key: <span class="built_in">String</span>,</span><br><span class="line">        resp: Responder&lt;<span class="built_in">Option</span>&lt;Bytes&gt;&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">    Set &#123;</span><br><span class="line">        key: <span class="built_in">String</span>,</span><br><span class="line">        val: Bytes,</span><br><span class="line">        resp: Responder&lt;()&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Provided by the requester and used by the manager task to send</span></span><br><span class="line"><span class="comment">/// the command response back to the requester.</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Responder</span></span>&lt;T&gt; = oneshot::Sender&lt;mini_redis::<span class="built_in">Result</span>&lt;T&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p>然后，修改管理任务以能够发送包含<code>oneshot::Sender</code>的命令。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t1 = tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> (resp_tx, resp_rx) = oneshot::channel();</span><br><span class="line">    <span class="keyword">let</span> cmd = Command::Get &#123;</span><br><span class="line">        key: <span class="string">&quot;hello&quot;</span>.to_string(),</span><br><span class="line">        resp: resp_tx,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send the GET request</span></span><br><span class="line">    tx.send(cmd).<span class="keyword">await</span>.unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Await the response</span></span><br><span class="line">    <span class="keyword">let</span> res = resp_rx.<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;GOT = &#123;:?&#125;&quot;</span>, res);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> t2 = tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> (resp_tx, resp_rx) = oneshot::channel();</span><br><span class="line">    <span class="keyword">let</span> cmd = Command::Set &#123;</span><br><span class="line">        key: <span class="string">&quot;foo&quot;</span>.to_string(),</span><br><span class="line">        val: <span class="string">&quot;bar&quot;</span>.into(),</span><br><span class="line">        resp: resp_tx,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send the SET request</span></span><br><span class="line">    tx2.send(cmd).<span class="keyword">await</span>.unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Await the response</span></span><br><span class="line">    <span class="keyword">let</span> res = resp_rx.<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;GOT = &#123;:?&#125;&quot;</span>, res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>最后，修改管理任务，以使用<code>oneshot</code>通道返回响应。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(cmd) = rx.recv().<span class="keyword">await</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> cmd &#123;</span><br><span class="line">        Command::Get &#123; key, resp &#125; =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> res = client.get(&amp;key).<span class="keyword">await</span>;</span><br><span class="line">            <span class="comment">// Ignore errors</span></span><br><span class="line">            <span class="keyword">let</span> _ = resp.send(res);</span><br><span class="line">        &#125;</span><br><span class="line">        Command::Set &#123; key, val, resp &#125; =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> res = client.set(&amp;key, val).<span class="keyword">await</span>;</span><br><span class="line">            <span class="comment">// Ignore errors</span></span><br><span class="line">            <span class="keyword">let</span> _ = resp.send(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>oneshot::Sender</code>的<code>send</code>会立即完成，<strong>不需要</strong>使用<code>.await</code>。这是因为在<code>oneshot</code>通道上<code>send</code>总是立刻失败或成功，不会有任何等待。</p>
<p>在<code>oneshot</code>通道上发送值时，如果接收端被析构则将返回<code>Err</code>，以表明接收端不再关注响应。在我们的例子中，接收端可以不接收响应，因此无需处理<code>resp.send(...)</code>返回的<code>Err</code>。</p>
<p>你可以在<a target="_blank" rel="noopener" href="https://github.com/tokio-rs/website/blob/master/tutorial-code/channels/src/main.rs">这里</a>找到完整代码。</p>
<h2 id="背压调节和通道限制"><a href="#背压调节和通道限制" class="headerlink" title="背压调节和通道限制"></a>背压调节和通道限制</h2><p>当引入并发或队列时，一定要确保队列是有限的，以使系统能优雅地处理负载。无限的队列最终将耗尽所有可用的内存，并导致系统以不可预测的方式宕机。</p>
<p>Tokio能够避免定义不明确的队列，主要也是因为Tokio中的异步操作是惰性求值。考虑以下代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    async_op();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果异步操作立即求值，则此循环会不停的将新的<code>async_op</code>排入队列，且并不关心之前的操作是否完成，如此则会隐式的产生无限制队列。基于回调和立即求future的系统尤其容易受到上述影响。</p>
<p>但是，使用Tokio和异步Rust，上述代码片段的<code>async_op</code>根本不会运行，因为<code>.await</code>从未被调用。如果修改上述代码，加入<code>.await</code>，则循环会等待操作完成才进入下一次循环。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="comment">// Will not repeat until `async_op` completes</span></span><br><span class="line">    async_op().<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用并发和队列时必须明确引入。这样做的方法包括：</p>
<ul>
<li><code>tokio::Spawn</code></li>
<li><code>select!</code></li>
<li><code>join!</code></li>
<li><code>mpsc::channel</code></li>
</ul>
<p>这样做时，请注意确保并发的总数有上限。例如，在编写接受TCP连接的循环时，请确保打开的sockets的总数有上限。使用<code>mpsc::channel</code>时，选择合适的通道容量。针对特定的应用程序选择特定的约束限制。</p>
<p>编写可靠的Tokio应用程序的一个关键，就是留意并挑选良好的限制值。</p>
<h1 id="7-I-O"><a href="#7-I-O" class="headerlink" title="7 I/O"></a>7 I/O</h1><hr>
<p>Tokio中的I/O以与<code>std</code>中的运行方式几乎一样，只不过是异步的。有一个读trait（<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/io/trait.AsyncRead.html"><code>AsyncRead</code></a>）和一个写trait（<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/io/trait.AsyncWrite.html"><code>AsyncWrite</code></a>）。一些类型已经良好的地实现了这些trait（<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/net/struct.TcpStream.html"><code>TCPStream</code></a>、<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/fs/struct.File.html"><code>File</code></a>，<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/io/struct.Stdout.html"><code>Stdout</code></a>）。许多数据结构也实现了<code>AsyncRead</code>和<code>AsyncWrite</code>（如<code>Vec&lt;u8&gt;</code>和<code>&amp;[u8]</code>），这使得我们可以在需要用到reader和writer的地方使用字节数组。</p>
<p>本章将通过一些例子演示使用Tokio时的基本I/O读写操作。下一章江更加深入的介绍高级的I/O示例。</p>
<h2 id="AsyncRead和AsyncWrite"><a href="#AsyncRead和AsyncWrite" class="headerlink" title="AsyncRead和AsyncWrite"></a><code>AsyncRead</code>和<code>AsyncWrite</code></h2><p>这两个trait为异步读写字节流提供了基础工具。我们通常不直接调用这些trait上的方法，类似于你不会手动调用<code>future</code> trait的<code>poll</code>方法，而是使用<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/io/trait.AsyncReadExt.html"><code>AsyncReadExt</code></a>和<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/io/trait.AsyncWriteExt.html"><code>AsyncWriteExt</code></a>提供的工具方法。</p>
<p>让我们简要看一下其中的一些方法，所有这些函数都是异步的，必须与配合<code>.await</code>使用。</p>
<h3 id="async-fn-read"><a href="#async-fn-read" class="headerlink" title="async fn read()"></a><code>async fn read()</code></h3><p><code>AsyncReadExt::read</code>提供了一种将数据读取到缓冲区的异步方法，返回值为读到的字节数。</p>
<p>注意：当<code>read()</code>返回<code>Ok(0)</code>时，意味着该流已关闭。任何调用<code>read()</code>的future江立即完成并返回<code>Ok(0)</code>。比如对<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/net/struct.TcpStream.html"><code>TcpStream</code></a>的实例，这表示socket的读端已关闭。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::fs::File;</span><br><span class="line"><span class="keyword">use</span> tokio::io::&#123;<span class="keyword">self</span>, AsyncReadExt&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> f = File::open(<span class="string">&quot;foo.txt&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buffer = [<span class="number">0</span>; <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read up to 10 bytes</span></span><br><span class="line">    <span class="keyword">let</span> n = f.read(&amp;<span class="keyword">mut</span> buffer[..]).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The bytes: &#123;:?&#125;&quot;</span>, &amp;buffer[..n]);</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="async-fn-read-to-end"><a href="#async-fn-read-to-end" class="headerlink" title="async fn read_to_end()"></a><code>async fn read_to_end()</code></h3><p><a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/io/trait.AsyncReadExt.html#method.read_to_end"><code>AsyncReadExt::read_to_end</code></a>将读取流中的所有字节，直到遇到EOF。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::io::&#123;<span class="keyword">self</span>, AsyncReadExt&#125;;</span><br><span class="line"><span class="keyword">use</span> tokio::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> f = File::open(<span class="string">&quot;foo.txt&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buffer = <span class="built_in">Vec</span>::new();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the whole file</span></span><br><span class="line">    f.read_to_end(&amp;<span class="keyword">mut</span> buffer).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="async-fn-write"><a href="#async-fn-write" class="headerlink" title="async fn write()"></a><code>async fn write()</code></h3><p><a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/io/trait.AsyncWriteExt.html#method.write"><code>AsyncWriteExt::write</code></a>将一个缓冲区写入writer，返回值为写入的字节数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::io::&#123;<span class="keyword">self</span>, AsyncWriteExt&#125;;</span><br><span class="line"><span class="keyword">use</span> tokio::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file = File::create(<span class="string">&quot;foo.txt&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Writes some prefix of the byte string, but not necessarily all of it.</span></span><br><span class="line">    <span class="keyword">let</span> n = file.write(<span class="string">b&quot;some bytes&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Wrote the first &#123;&#125; bytes of &#x27;some bytes&#x27;.&quot;</span>, n);</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="async-fn-write-all"><a href="#async-fn-write-all" class="headerlink" title="async fn write_all()"></a><code>async fn write_all()</code></h3><p><a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/io/trait.AsyncWriteExt.html#method.write_all"><code>AsyncWriteExt::write_all</code></a>将整个缓冲区写入writer。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::io::&#123;<span class="keyword">self</span>, AsyncWriteExt&#125;;</span><br><span class="line"><span class="keyword">use</span> tokio::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file = File::create(<span class="string">&quot;foo.txt&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    file.write_all(<span class="string">b&quot;some bytes&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个trait都包括许多其他有用的方法，详情请参阅API文档。</p>
<h2 id="帮助函数"><a href="#帮助函数" class="headerlink" title="帮助函数"></a>帮助函数</h2><p>此外，就像<code>std</code>，<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/io/index.html"><code>tokio::io</code></a>模块也包含许多实用的工具函数，以及用于<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/io/fn.stdin.html">标准输入</a>、<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/io/fn.stdout.html">标准输出</a>和<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/io/fn.stderr.html">标准错误</a>的API。例如，使用<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/io/fn.copy.html"><code>tokio::io::copy</code></a>异步将读端的所有内容复制到写端。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::fs::File;</span><br><span class="line"><span class="keyword">use</span> tokio::io;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> reader: &amp;[<span class="built_in">u8</span>] = <span class="string">b&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file = File::create(<span class="string">&quot;foo.txt&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    io::copy(&amp;<span class="keyword">mut</span> reader, &amp;<span class="keyword">mut</span> file).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>留意到上例实际上利用了实现了<code>AsyncRead</code>的字节数组。</p>
<h2 id="回音服务端"><a href="#回音服务端" class="headerlink" title="回音服务端"></a>回音服务端</h2><p>让我们上手试一下异步I/O，来编写一个简单的回音服务端。</p>
<p>回音服务端绑定一个<code>TcpListener</code>，使用一个循环接收入站连接。对于每个入站连接，从socket读取数据，然后立即将读到的数据写回socket。客户端将数据发送到服务器，然后接收完全相同的数据。</p>
<p>我们将使用两种稍微不同的策略分别实现回音服务端。</p>
<h3 id="使用io-copy"><a href="#使用io-copy" class="headerlink" title="使用io::copy()"></a>使用<code>io::copy()</code></h3><p>首先，我们将使用<code>io:copy</code>实现回音逻辑。</p>
<p>您可以在新的二进制文件中写入此代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch src/bin/echo-server-copy.rs</span><br></pre></td></tr></table></figure>

<p>您可以通过以下方式启动（或仅检查编译）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run --bin echo-server-copy</span><br></pre></td></tr></table></figure>

<p>您将可以直接使用标准命令行工具（例如<code>telnet</code>）测试服务端，或使用<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/net/struct.TcpStream.html#examples"><code>tokio::net::TcpStream</code></a>的文档中示例的简单客户测试服务端。</p>
<p>TCP服务端使用循环接受请求，每接受一个socket就生成一个新任务。</p>
<figure class="highlight rust"><figcaption><span>src/bin/echo-server-copy.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::io;</span><br><span class="line"><span class="keyword">use</span> tokio::net::TcpListener;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> listener = TcpListener::bind(<span class="string">&quot;127.0.0.1:6142&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> socket, _) = listener.accept().<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">        tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="comment">// Copy data here</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前提到过，该工具函数将接受一个读端和一个写端，并将数据从一端拷贝到另一端，但此处我们只有一个<code>Tcpstream</code>，而这一个值同时实现了<code>AsyncRead</code>和<code>AsyncWrite</code>。由于<code>io::copy</code>要求读端和写端均为<code>&amp;mut</code>，如果这两个参数都写成socket的话就不能通过编译。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This fails to compile</span></span><br><span class="line">io::copy(&amp;<span class="keyword">mut</span> socket, &amp;<span class="keyword">mut</span> socket).<span class="keyword">await</span></span><br></pre></td></tr></table></figure>

<h3 id="拆分读端和写端"><a href="#拆分读端和写端" class="headerlink" title="拆分读端和写端"></a>拆分读端和写端</h3><p>要解决问题，我们需要将socket拆分为读句柄和写句柄，特定的类型有特定的最佳读/写端拆分方式。</p>
<p>任何读端+写端的类型，均可用<code>io::split</code>工具函数拆分，函数接受一个参数，返回一对读句柄/写句柄。这两个句柄可以独立使用，比如用在不同的任务中。</p>
<p>例如，回音客户端可以按如下的方式处理的并发读取：</p>
<figure class="highlight rust"><figcaption><span>echo-client.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::io::&#123;<span class="keyword">self</span>, AsyncReadExt, AsyncWriteExt&#125;;</span><br><span class="line"><span class="keyword">use</span> tokio::net::TcpStream;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> socket = TcpStream::connect(<span class="string">&quot;127.0.0.1:6142&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> rd, <span class="keyword">mut</span> wr) = io::split(socket);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write data in the background</span></span><br><span class="line">    tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        wr.write_all(<span class="string">b&quot;hello\r\n&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line">        wr.write_all(<span class="string">b&quot;world\r\n&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Sometimes, the rust type inferencer needs</span></span><br><span class="line">        <span class="comment">// a little help</span></span><br><span class="line">        Ok::&lt;_, io::Error&gt;(())</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buf = <span class="built_in">vec!</span>[<span class="number">0</span>; <span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> n = rd.read(&amp;<span class="keyword">mut</span> buf).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;GOT &#123;:?&#125;&quot;</span>, &amp;buf[..n]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>io::split</code>能够接受<strong>任何</strong>实现了<code>AsyncRead + AsyncWrite</code>的类型并返回独立的句柄，是因为<code>io::split</code>内部使用一个<code>Arc</code>和一个<code>Mutex</code>。我们可以使用<code>TcpStream</code>避免使用此开销。<code>TcpStream</code>提供了两个专用的拆分函数。</p>
<p><a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/net/struct.TcpStream.html#method.split"><code>TcpStream::split</code></a>接受一个流的<strong>引用</strong>，返回一对读/写句柄。由于使用了引用，因此两个句柄都必须<strong>呆在这个</strong>调用<code>split()</code>的任务中。这种专用拆分为零成本，不需要<code>Arc</code>或<code>Mutex</code>。<code>TcpStream</code>还提供了<code>into_split</code>函数，以仅使用一个<code>Arc</code>为代价，让句柄能够在任务间移动。</p>
<p>由于调用<code>io::copy()</code>的任务就拥有<code>TcpStream</code>的所有权，因此我们可以使用<code>TcpStream::split</code>。服务端中处理回音逻辑的任务变成：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> rd, <span class="keyword">mut</span> wr) = socket.split();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> io::copy(&amp;<span class="keyword">mut</span> rd, &amp;<span class="keyword">mut</span> wr).<span class="keyword">await</span>.is_err() &#123;</span><br><span class="line">        eprintln!(<span class="string">&quot;failed to copy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>你可以在<a target="_blank" rel="noopener" href="https://github.com/tokio-rs/website/blob/master/tutorial-code/io/src/echo-server-copy.rs">这里</a>找到完整的代码。</p>
<h3 id="手动拷贝"><a href="#手动拷贝" class="headerlink" title="手动拷贝"></a>手动拷贝</h3><p>现在，让我们来了解一下如何通过手动复制数据的方式编写回音服务端。这里，我们需要使用<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/io/trait.AsyncReadExt.html#method.read"><code>AsyncReadExt::read</code></a>和<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/io/trait.AsyncWriteExt.html#method.write_all"><code>AsyncWriteExt::write_all</code></a>。</p>
<p>完整的回音服务端如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::io::&#123;<span class="keyword">self</span>, AsyncReadExt, AsyncWriteExt&#125;;</span><br><span class="line"><span class="keyword">use</span> tokio::net::TcpListener;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> listener = TcpListener::bind(<span class="string">&quot;127.0.0.1:6142&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> socket, _) = listener.accept().<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">        tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> buf = <span class="built_in">vec!</span>[<span class="number">0</span>; <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="keyword">match</span> socket.read(&amp;<span class="keyword">mut</span> buf).<span class="keyword">await</span> &#123;</span><br><span class="line">                    <span class="comment">// Return value of `Ok(0)` signifies that the remote has</span></span><br><span class="line">                    <span class="comment">// closed</span></span><br><span class="line">                    <span class="literal">Ok</span>(<span class="number">0</span>) =&gt; <span class="keyword">return</span>,</span><br><span class="line">                    <span class="literal">Ok</span>(n) =&gt; &#123;</span><br><span class="line">                        <span class="comment">// Copy the data back to socket</span></span><br><span class="line">                        <span class="keyword">if</span> socket.write_all(&amp;buf[..n]).<span class="keyword">await</span>.is_err() &#123;</span><br><span class="line">                            <span class="comment">// Unexpected socket error. There isn&#x27;t much we can</span></span><br><span class="line">                            <span class="comment">// do here so just stop processing.</span></span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="literal">Err</span>(_) =&gt; &#123;</span><br><span class="line">                        <span class="comment">// Unexpected socket error. There isn&#x27;t much we can do</span></span><br><span class="line">                        <span class="comment">// here so just stop processing.</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（您可以将此代码放入<code>src/bin/echo-server.rs</code>中，并使用<code>cargo run --bin echo-server</code>运行）。</p>
<p>我们来逐行理解代码。首先，由于使用<code>AsyncRead</code>和<code>AsyncWrite</code>实用工具，因此必须引入这些扩展trait。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::io::&#123;<span class="keyword">self</span>, AsyncReadExt, AsyncWriteExt&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="分配缓冲区"><a href="#分配缓冲区" class="headerlink" title="分配缓冲区"></a>分配缓冲区</h3><p>我们的策略是将一些从socket中读取的数据放入缓冲区，然后将缓冲区的内容写回到socket中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> buf = <span class="built_in">vec!</span>[<span class="number">0</span>; <span class="number">1024</span>];</span><br></pre></td></tr></table></figure>

<p>这里显式禁止使用栈缓冲区。回想<a href=".#Send%E9%99%90%E5%88%B6">前面</a>，我们注意到，跨<code>.await</code>调用存活的所有任务数据都必须保存在任务中。上面的代码中，<code>buf</code>跨<code>.await</code>调用使用。所有任务数据都存储在这单个分配中。您可以将其视为一个<code>enum</code>，其中每个成员变量都是需要保存在任务中以便特定的<code>.await</code>调用的数据。</p>
<p>如果缓冲区是一个栈数组，则为每个接受的socket生成的任务内部结构可能看起来像：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Task</span></span> &#123;</span><br><span class="line">    <span class="comment">// internal task fields here</span></span><br><span class="line">    task: <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        AwaitingRead &#123;</span><br><span class="line">            socket: TcpStream,</span><br><span class="line">            buf: [BufferType],</span><br><span class="line">        &#125;,</span><br><span class="line">        AwaitingWriteAll &#123;</span><br><span class="line">            socket: TcpStream,</span><br><span class="line">            buf: [BufferType],</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果将栈数组当做缓冲区，则它将<em>内联</em>存储在任务结构体中。这将使任务结构体变得非常大。另外，缓冲的大小通常是页大小，于是，这将使任务大小变得很尴尬：<code>$页大小 + 一些额外字节</code>。</p>
<p>当然，编译器将异步代码块进行了优化，性能远超基本的<code>enmu</code>。实际上，变量并不会像<code>enum</code>可能需要的那样，在成员间移动。但是，任务结构体大小至少与最大的变量一样大。</p>
<p>因此，为缓冲区使用专用的分配通常能更加高效。</p>
<h3 id="处理EOF"><a href="#处理EOF" class="headerlink" title="处理EOF"></a>处理EOF</h3><p>当关闭了TCP流的读端后，再调用<code>read()</code>将返回<code>Ok(0)</code>，此时必须让读循环终止。忘记在已经EOF的内容上继续循环读取，是一个常见的错误。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> socket.read(&amp;<span class="keyword">mut</span> buf).<span class="keyword">await</span> &#123;</span><br><span class="line">        <span class="comment">// Return value of `Ok(0)` signifies that the remote has</span></span><br><span class="line">        <span class="comment">// closed</span></span><br><span class="line">        <span class="literal">Ok</span>(<span class="number">0</span>) =&gt; <span class="keyword">return</span>,</span><br><span class="line">        <span class="comment">// ... other cases handled here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>忘记停止读循环，通常会导致CPU使用率100％的无限循环。当socket关闭时，<code>socket.read()</code>将立即返回，然后不停的重复循环。</p>
<p>你可以在<a target="_blank" rel="noopener" href="https://github.com/tokio-rs/website/blob/master/tutorial-code/io/src/echo-server.rs">这里</a>找到完整的代码。</p>
<h1 id="8-组帧"><a href="#8-组帧" class="headerlink" title="8 组帧"></a>8 组帧</h1><hr>
<p>现在，我们将使用我们刚刚学到的I/O相关知识，实现Mini-Redis组帧层。组帧是获取字节流并将其转换为帧流的过程，帧是两节点间传输数据的单位。Redis协议帧定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> bytes::Bytes;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Frame</span></span> &#123;</span><br><span class="line">    Simple(<span class="built_in">String</span>),</span><br><span class="line">    Error(<span class="built_in">String</span>),</span><br><span class="line">    Integer(<span class="built_in">u64</span>),</span><br><span class="line">    Bulk(Bytes),</span><br><span class="line">    Null,</span><br><span class="line">    Array(<span class="built_in">Vec</span>&lt;Frame&gt;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请留意该帧定义是如何使用没有语义的数据组成的，命令解析和实现位于更上层。</p>
<p>对于HTTP，帧可能看起来像：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">HttpFrame</span></span> &#123;</span><br><span class="line">    RequestHead &#123;</span><br><span class="line">        method: Method,</span><br><span class="line">        uri: Uri,</span><br><span class="line">        version: Version,</span><br><span class="line">        headers: HeaderMap,</span><br><span class="line">    &#125;,</span><br><span class="line">    ResponseHead &#123;</span><br><span class="line">        status: StatusCode,</span><br><span class="line">        version: Version,</span><br><span class="line">        headers: HeaderMap,</span><br><span class="line">    &#125;,</span><br><span class="line">    BodyChunk &#123;</span><br><span class="line">        chunk: Bytes,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了实现Mini-Redis的帧，我们将实现<code>Connection</code>结构体，里面封装了一个<code>TcpStream</code>用以读/写<code>mini_redis::Frame</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::net::TcpStream;</span><br><span class="line"><span class="keyword">use</span> mini_redis::&#123;Frame, <span class="built_in">Result</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Connection</span></span> &#123;</span><br><span class="line">    stream: TcpStream,</span><br><span class="line">    <span class="comment">// ... other fields here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Connection &#123;</span><br><span class="line">    <span class="comment">/// Read a frame from the connection.</span></span><br><span class="line">    <span class="comment">/// </span></span><br><span class="line">    <span class="comment">/// Returns `None` if EOF is reached</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_frame</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)</span><br><span class="line">        -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">Option</span>&lt;Frame&gt;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// implementation here</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Write a frame to the connection.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">write_frame</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, frame: &amp;Frame)</span><br><span class="line">        -&gt; <span class="built_in">Result</span>&lt;()&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// implementation here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以在<a target="_blank" rel="noopener" href="https://redis.io/topics/protocol">这里</a>找到Redis Wire协议的详细信息，可以在<a target="_blank" rel="noopener" href="https://github.com/tokio-rs/mini-redis/blob/tutorial/src/connection.rs">这里</a>找到完整的代码。</p>
<h2 id="缓冲读"><a href="#缓冲读" class="headerlink" title="缓冲读"></a>缓冲读</h2><p><code>read_frame</code>方法会等待收到整个帧才返回，而调用一次<code>TcpStream::read()</code>返回的数据长度不确定，可能包含整个帧，或是部分帧，也可能包含了多个帧。如果收到的是部分帧，则应缓冲数据并从socket中读取更多数据。如果收到的是多个帧，则应返回第一帧，缓冲其余数据，以等待下一次<code>read_frame</code>调用。</p>
<p>为了实现上述功能，需要给<code>Connection</code>添加一个读缓冲区字段，以数据将从socket读取到读缓冲区。解析帧时，再从缓冲区中返回并删除相应的数据即可。</p>
<p>我们选用<a target="_blank" rel="noopener" href="https://docs.rs/bytes/1/bytes/struct.BytesMut.html"><code>BytesMut</code></a>作为缓冲区类型，即<a target="_blank" rel="noopener" href="https://docs.rs/bytes/1/bytes/struct.Bytes.html"><code>Bytes</code></a>的可变版本。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> bytes::BytesMut;</span><br><span class="line"><span class="keyword">use</span> tokio::net::TcpStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Connection</span></span> &#123;</span><br><span class="line">    stream: TcpStream,</span><br><span class="line">    buffer: BytesMut,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Connection &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(stream: TcpStream) -&gt; Connection &#123;</span><br><span class="line">        Connection &#123;</span><br><span class="line">            stream,</span><br><span class="line">            <span class="comment">// Allocate the buffer with 4kb of capacity.</span></span><br><span class="line">            buffer: BytesMut::with_capacity(<span class="number">4096</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来实现<code>read_frame()</code>方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::io::AsyncReadExt;</span><br><span class="line"><span class="keyword">use</span> bytes::Buf;</span><br><span class="line"><span class="keyword">use</span> mini_redis::<span class="built_in">Result</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_frame</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)</span><br><span class="line">    -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">Option</span>&lt;Frame&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">// Attempt to parse a frame from the buffered data. If</span></span><br><span class="line">        <span class="comment">// enough data has been buffered, the frame is</span></span><br><span class="line">        <span class="comment">// returned.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(frame) = <span class="keyword">self</span>.parse_frame()? &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">Ok</span>(<span class="literal">Some</span>(frame));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// There is not enough buffered data to read a frame.</span></span><br><span class="line">        <span class="comment">// Attempt to read more data from the socket.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// On success, the number of bytes is returned. `0`</span></span><br><span class="line">        <span class="comment">// indicates &quot;end of stream&quot;.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> == <span class="keyword">self</span>.stream.read_buf(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.buffer).<span class="keyword">await</span>? &#123;</span><br><span class="line">            <span class="comment">// The remote closed the connection. For this to be</span></span><br><span class="line">            <span class="comment">// a clean shutdown, there should be no data in the</span></span><br><span class="line">            <span class="comment">// read buffer. If there is, this means that the</span></span><br><span class="line">            <span class="comment">// peer closed the socket while sending a frame.</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.buffer.is_empty() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">Ok</span>(<span class="literal">None</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">Err</span>(<span class="string">&quot;connection reset by peer&quot;</span>.into());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们逐行分析这段代码。<code>read_frame</code>方法内是一个循环：首先调用<code>self.parse_frame()</code>，以将尝试从<code>self.buffer</code>中解析出一个完整的redis帧，如果有足够的数据来解析出一个完整帧，则将该帧返回给<code>read_frame()</code>的调用者；反之，则尝试将从socket读更多的数据取到缓冲区中。读取更多数据后将再次调用<code>parse_frame()</code>，此时，如果收到足够的数据，解析可能会成功。</p>
<p>从流中读取数据时，返回值为<code>0</code>表示将不能从对端收到更多数据，此时，如果读缓冲区仍有数据，则表明收到了部分帧，但该连接突然终止。这是一个错误，应返回<code>Err</code>。</p>
<h3 id="Buf-trait"><a href="#Buf-trait" class="headerlink" title="Buf trait"></a><code>Buf</code> trait</h3><p>从流中读取数据时调用了<code>read_buf</code>。此读函数接受的参数，需要实现<a target="_blank" rel="noopener" href="https://docs.rs/bytes/"><code>bytes</code></a> crate的<a target="_blank" rel="noopener" href="https://docs.rs/bytes/1/bytes/trait.BufMut.html"><code>BufMut</code></a> trait。</p>
<p>这里先思考如果使用<code>read()</code>实现相同的读循环，该怎么写。（可以先用<code>Vec&lt;u8&gt;</code>代替上面的<code>BytesMut</code>）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::net::TcpStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Connection</span></span> &#123;</span><br><span class="line">    stream: TcpStream,</span><br><span class="line">    buffer: <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;,</span><br><span class="line">    cursor: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Connection &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(stream: TcpStream) -&gt; Connection &#123;</span><br><span class="line">        Connection &#123;</span><br><span class="line">            stream,</span><br><span class="line">            <span class="comment">// Allocate the buffer with 4kb of capacity.</span></span><br><span class="line">            buffer: <span class="built_in">vec!</span>[<span class="number">0</span>; <span class="number">4096</span>],</span><br><span class="line">            cursor: <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再给<code>Conneciont</code>添加<code>read_frame()</code>函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> mini_redis::&#123;Frame, <span class="built_in">Result</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_frame</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)</span><br><span class="line">    -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">Option</span>&lt;Frame&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(frame) = <span class="keyword">self</span>.parse_frame()? &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">Ok</span>(<span class="literal">Some</span>(frame));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure the buffer has capacity</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.buffer.len() == <span class="keyword">self</span>.cursor &#123;</span><br><span class="line">            <span class="comment">// Grow the buffer</span></span><br><span class="line">            <span class="keyword">self</span>.buffer.resize(<span class="keyword">self</span>.cursor * <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read into the buffer, tracking the number</span></span><br><span class="line">        <span class="comment">// of bytes read</span></span><br><span class="line">        <span class="keyword">let</span> n = <span class="keyword">self</span>.stream.read(</span><br><span class="line">            &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.buffer[<span class="keyword">self</span>.cursor..]).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> == n &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.cursor == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">Ok</span>(<span class="literal">None</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">Err</span>(<span class="string">&quot;connection reset by peer&quot;</span>.into());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Update our cursor</span></span><br><span class="line">            <span class="keyword">self</span>.cursor += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用字节数组<code>read</code>时，需要手动维护一个游标用来跟踪缓冲了多少数据，还必须确保将缓冲区仍为空的部分传给<code>read()</code>；否则，将覆盖掉缓冲的数据。而当缓冲区用完时，还要手动扩大缓冲区以能够继续读到缓冲区。在<code>parse_frame()</code>（尚未提到）中，还需要指定解析位于<code>self.buffer[..self.cursor]</code>中的数据。</p>
<p>因为于将字节数组与游标搭配使用的场景很常见，<code>bytes</code> crate提供了表示字节数组和游标的抽象。<code>Buf</code> trait由那些可以从中读取数据的源头类型来实现。<code>BufMut</code>由那些可以进将数据写入的目的类型来实现。当把<code>T: BufMut</code>的参数传给<code>read_buf()</code>时，缓冲区内部的游标将被<code>read_buf()</code>自动更新。因此，在我们的<code>read_frame</code>，不再需要自己手动管理游标。</p>
<p>另外，使用<code>vec&lt;u8&gt;</code>时，必须初始化缓冲区。<code>vec![0; 4096]</code>将分配4096字节的数组，并将每个字节都置为零。调整缓冲区大小时，新增部分还必须使用零来初始化。而初始化操作是有代价的。使用<code>BytesMut</code>和<code>BufMut</code>时，缓冲区是未初始化的。<code>BytesMut</code>抽象会防止我们从未初始化的内存中读取数据，这就避免了初始化操作。</p>
<h2 id="解析帧"><a href="#解析帧" class="headerlink" title="解析帧"></a>解析帧</h2><p>现在，让我们看一下<code>parse_frame()</code>，解析分两个步骤进行。</p>
<ol>
<li>确保全帧被缓冲，并索引到到帧的末尾。</li>
<li>解析帧。</li>
</ol>
<p><code>mini-redis</code> crate为我们提供了这两个步骤所需的函数：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://docs.rs/mini-redis/0.4/mini_redis/frame/enum.Frame.html#method.check"><code>Frame::check</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.rs/mini-redis/0.4/mini_redis/frame/enum.Frame.html#method.parse"><code>Frame::parse</code></a></li>
</ol>
<p>这里又需要使用到<code>Buf</code>抽象。一个实现了<code>Buf</code>的对象会被传递给<code>Frame::check</code>，而在<code>check</code>函数检查传入的缓冲对象时，内部的游标会随着移动。当<code>check</code>返回时，缓冲区内部的游标就自动指向帧的末端了。</p>
<p>我们将使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/io/struct.Cursor.html"><code>std::io::Cursor&lt;&amp;[u8]&gt;</code></a>类型实现<code>Buf</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> mini_redis::&#123;Frame, <span class="built_in">Result</span>&#125;;</span><br><span class="line"><span class="keyword">use</span> mini_redis::frame::Error::Incomplete;</span><br><span class="line"><span class="keyword">use</span> bytes::Buf;</span><br><span class="line"><span class="keyword">use</span> std::io::Cursor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_frame</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)</span><br><span class="line">    -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">Option</span>&lt;Frame&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create the `T: Buf` type.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buf = Cursor::new(&amp;<span class="keyword">self</span>.buffer[..]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check whether a full frame is available</span></span><br><span class="line">    <span class="keyword">match</span> Frame::check(&amp;<span class="keyword">mut</span> buf) &#123;</span><br><span class="line">        <span class="literal">Ok</span>(_) =&gt; &#123;</span><br><span class="line">            <span class="comment">// Get the byte length of the frame</span></span><br><span class="line">            <span class="keyword">let</span> len = buf.position() <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset the internal cursor for the</span></span><br><span class="line">            <span class="comment">// call to `parse`.</span></span><br><span class="line">            buf.set_position(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Parse the frame</span></span><br><span class="line">            <span class="keyword">let</span> frame = Frame::parse(&amp;<span class="keyword">mut</span> buf)?;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Discard the frame from the buffer</span></span><br><span class="line">            <span class="keyword">self</span>.buffer.advance(len);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Return the frame to the caller.</span></span><br><span class="line">            <span class="literal">Ok</span>(<span class="literal">Some</span>(frame))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Not enough data has been buffered</span></span><br><span class="line">        <span class="literal">Err</span>(Incomplete) =&gt; <span class="literal">Ok</span>(<span class="literal">None</span>),</span><br><span class="line">        <span class="comment">// An error was encountered</span></span><br><span class="line">        <span class="literal">Err</span>(e) =&gt; <span class="literal">Err</span>(e.into()),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的<a target="_blank" rel="noopener" href="https://github.com/tokio-rs/mini-redis/blob/tutorial/src/frame.rs#L65-L103"><code>Frame::check</code></a>函数可以在<a target="_blank" rel="noopener" href="https://github.com/tokio-rs/mini-redis/blob/tutorial/src/frame.rs#L65-L103">这里</a>找到，此处就不贴上它的完整代码了。</p>
<p>值得注意的是<code>Buf</code>使用了“字节迭代器”风格的API，以读取数据并移动内部游标。例如，解析帧时，检查第一个字节以确定帧的类型，使用的函数是<a target="_blank" rel="noopener" href="https://docs.rs/bytes/1/bytes/buf/trait.Buf.html#method.get_u8"><code>Buf::get_u8</code></a>，可以获取游标当前位置的字节，并将游标后移一位。</p>
<p><a target="_blank" rel="noopener" href="https://docs.rs/bytes/1/bytes/buf/trait.Buf.html"><code>Buf</code></a> trait还有更多有用的方，可以查看<a target="_blank" rel="noopener" href="https://docs.rs/bytes/1/bytes/buf/trait.Buf.html">API文档</a>获取更多信息。</p>
<h2 id="缓冲写"><a href="#缓冲写" class="headerlink" title="缓冲写"></a>缓冲写</h2><p>帧相关API的另一半是<code>write_frame(frame)</code>函数，它会将一个完整的帧写入socket。为了最大程度地减少<code>write</code>系统调用，写将被缓冲。我们维护一个写缓冲区，并在写入socket之前将帧编码到该缓冲区。不过，与<code>read_frame()</code>不同，完整的帧并不总是在写入socket前缓冲到字节数组。</p>
<p>比如对一个大块流帧，要写入的值为<code>Frame::Bulk(Bytes)</code>。大块帧的的物理格式是一个帧头，即<code>$</code>符后接以字节计算的数据长度。帧的主体是内容的<code>Bytes</code>。如果数据量很大，则将其复制到中间缓冲区将非常耗资源。</p>
<p>为了实现缓冲写，我们将使用<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/io/struct.BufWriter.html"><code>BufWriter</code>结构体</a>，它用<code>T: AsyncWrite</code>初始化并自己实现<code>AsyncWrite</code>。当在<code>BufWriter</code>上调用<code>write</code>时，并非直接调用内部的写操作，而是提交给缓冲区。当缓冲区满时，内容才一次性交给内部写操作，然后清理缓冲区。当然，在某些情况下，还有一些可以绕过缓冲区的优化操作。</p>
<p>这里的教程不会贴上完整的<code>write_frame()</code>实现了，你可以在<a target="_blank" rel="noopener" href="https://github.com/tokio-rs/mini-redis/blob/tutorial/src/connection.rs#L159-L184">这里</a>找到完整代码。</p>
<p>首先，修改<code>Connection</code>结构体：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::io::BufWriter;</span><br><span class="line"><span class="keyword">use</span> tokio::net::TcpStream;</span><br><span class="line"><span class="keyword">use</span> bytes::BytesMut;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Connection</span></span> &#123;</span><br><span class="line">    stream: BufWriter&lt;TcpStream&gt;,</span><br><span class="line">    buffer: BytesMut,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Connection &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(stream: TcpStream) -&gt; Connection &#123;</span><br><span class="line">        Connection &#123;</span><br><span class="line">            stream: BufWriter::new(stream),</span><br><span class="line">            buffer: BytesMut::with_capacity(<span class="number">4096</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后实现<code>write_frame()</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::io::&#123;<span class="keyword">self</span>, AsyncWriteExt&#125;;</span><br><span class="line"><span class="keyword">use</span> mini_redis::Frame;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">write_frame</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, frame: &amp;Frame)</span><br><span class="line">    -&gt; io::<span class="built_in">Result</span>&lt;()&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">match</span> frame &#123;</span><br><span class="line">        Frame::Simple(val) =&gt; &#123;</span><br><span class="line">            <span class="keyword">self</span>.stream.write_u8(<span class="string">b&#x27;+&#x27;</span>).<span class="keyword">await</span>?;</span><br><span class="line">            <span class="keyword">self</span>.stream.write_all(val.as_bytes()).<span class="keyword">await</span>?;</span><br><span class="line">            <span class="keyword">self</span>.stream.write_all(<span class="string">b&quot;\r\n&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line">        &#125;</span><br><span class="line">        Frame::Error(val) =&gt; &#123;</span><br><span class="line">            <span class="keyword">self</span>.stream.write_u8(<span class="string">b&#x27;-&#x27;</span>).<span class="keyword">await</span>?;</span><br><span class="line">            <span class="keyword">self</span>.stream.write_all(val.as_bytes()).<span class="keyword">await</span>?;</span><br><span class="line">            <span class="keyword">self</span>.stream.write_all(<span class="string">b&quot;\r\n&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line">        &#125;</span><br><span class="line">        Frame::Integer(val) =&gt; &#123;</span><br><span class="line">            <span class="keyword">self</span>.stream.write_u8(<span class="string">b&#x27;:&#x27;</span>).<span class="keyword">await</span>?;</span><br><span class="line">            <span class="keyword">self</span>.write_decimal(*val).<span class="keyword">await</span>?;</span><br><span class="line">        &#125;</span><br><span class="line">        Frame::Null =&gt; &#123;</span><br><span class="line">            <span class="keyword">self</span>.stream.write_all(<span class="string">b&quot;$-1\r\n&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line">        &#125;</span><br><span class="line">        Frame::Bulk(val) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> len = val.len();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.stream.write_u8(<span class="string">b&#x27;$&#x27;</span>).<span class="keyword">await</span>?;</span><br><span class="line">            <span class="keyword">self</span>.write_decimal(len <span class="keyword">as</span> <span class="built_in">u64</span>).<span class="keyword">await</span>?;</span><br><span class="line">            <span class="keyword">self</span>.stream.write_all(val).<span class="keyword">await</span>?;</span><br><span class="line">            <span class="keyword">self</span>.stream.write_all(<span class="string">b&quot;\r\n&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line">        &#125;</span><br><span class="line">        Frame::Array(_val) =&gt; <span class="built_in">unimplemented!</span>(),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.stream.flush().<span class="keyword">await</span>;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用的诸多函数均由<code>AsyncWriteExt</code> trait提供，该trait也被<code>TcpStream</code>实现，但是不建议在没有中间缓冲区的情况下发送写单个字节的命令（译注：即直接在<code>TcpStream</code>上调用这些<code>write_*</code>函数会产生大量系统调用，建议的做法是在有缓冲包装的写对象上调用，如文中的<code>stream</code>是一个<code>BufWriter&lt;TcpStream&gt;</code>对象）。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/io/trait.AsyncWriteExt.html#method.write_u8"><code>write_u8</code></a>将单个字节送入写端。</li>
<li><a target="_blank" rel="noopener" href="https://tokio.rs/tokio/tutorial/framing"><code>write_all</code></a>将整个切片送入写端。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/tokio-rs/mini-redis/blob/tutorial/src/connection.rs#L225-L238"><code>write_decimal</code></a>由mini-redis实现。</li>
</ul>
<p>该函数结束时将调用<code>self.stream.flush().await</code>。由于<code>BufWriter</code>在中间缓冲区保存写内容，因此调用<code>write</code>不能保证数据立即写入socket。在返回之前，我们希望将帧写入socket，手动调用<code>flush()</code>以将缓冲区中等待的所有数据写入socket。</p>
<p>另一种实现是在<code>Connection</code>上提供一个<code>flush()</code>方法，来代替在<code>write_frame()</code>中调用<code>flush()</code>。这将允许调用者将多个小帧排队写入写缓冲区，然后只用一个<code>write</code>系统调用将它们全部写入socket。不过这样会使<code>Connection</code>的API复杂化。简单也是Mini-Redis的目标，因此我们决定在<code>fn write_frame()</code>中调用<code>flush().await</code>。</p>
<h1 id="9-深入异步"><a href="#9-深入异步" class="headerlink" title="9 深入异步"></a>9 深入异步</h1><hr>
<p>至此，我们已经较为全面的了解了关于异步Rust和Tokio的知识。现在，让我们更深入了研究Rust的异步运行时模型。在本教程的最开始，我们暗示异步Rust采用了一种独特的实现方法。本章，我们就解释一下这意味着什么。</p>
<h2 id="Futures"><a href="#Futures" class="headerlink" title="Futures"></a>Futures</h2><p>我们用一个非常基本的异步函数，来快速回顾一下了解到的异步相关知识，在这个例子中并没有超出前几章的知识点。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::net::TcpStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">my_async_fn</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello from async&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> _socket = TcpStream::connect(<span class="string">&quot;127.0.0.1:3000&quot;</span>).<span class="keyword">await</span>.unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;async TCP operation complete&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们调用该函数，它返回一些值。我们又在该值上调用<code>.await</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> what_is_this = my_async_fn();</span><br><span class="line">    <span class="comment">// Nothing has been printed yet.</span></span><br><span class="line">    what_is_this.<span class="keyword">await</span>;</span><br><span class="line">    <span class="comment">// Text has been printed and socket has been</span></span><br><span class="line">    <span class="comment">// established and closed.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>my_async_fn()</code>的返回值是一个future。实现了标准库<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>std::future::Future</code></a> trait的值就是future。这些值里包含了正在执行的异步计算。</p>
<p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>std::future::Future</code></a> trait的定义为：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"><span class="keyword">use</span> std::task::&#123;Context, Poll&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Future</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context)</span><br><span class="line">        -&gt; Poll&lt;Self::Output&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types">关联类型</a><code>Output</code>是future执行完毕后返回的类型。<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/pin/index.html"><code>Pin</code></a>类型使Rust能够支持异步函数内的借用。有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/pin/index.html">标准库文档</a>。</p>
<p>与用其他语言实现future的方式不同，Rust的future并不是正在后台执行的计算过程，<strong>而是</strong>计算本身。future的所有者负责通过轮询未来来推进计算。这是通过调用<code>Future::poll</code>来实现的。</p>
<p>（译注，本教程因主要关注tokio的应用，所以本章关于深入Rust异步机制的介绍篇幅并不大，更深入的讨论可以参考 <a href="/2021/04/14/writing-an-os-in-rust-4.1/#Rust%E7%9A%84async-await">使用Rust编写操作系统 - 4.1 - Async/Await</a>）</p>
<h3 id="实现Future"><a href="#实现Future" class="headerlink" title="实现Future"></a>实现<code>Future</code></h3><p>让我们实现一个非常简单的future。 这个future将：</p>
<ol>
<li>等待，直到某个特定的时刻才执行。</li>
<li>将一些文本输出到标准输出。</li>
<li>生成一个字符串。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::future::Future;</span><br><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"><span class="keyword">use</span> std::task::&#123;Context, Poll&#125;;</span><br><span class="line"><span class="keyword">use</span> std::time::&#123;Duration, Instant&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Delay</span></span> &#123;</span><br><span class="line">    when: Instant,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Future <span class="keyword">for</span> Delay &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;)</span><br><span class="line">        -&gt; Poll&lt;&amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> Instant::now() &gt;= <span class="keyword">self</span>.when &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">            Poll::Ready(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Ignore this line for now.</span></span><br><span class="line">            cx.waker().wake_by_ref();</span><br><span class="line">            Poll::Pending</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> when = Instant::now() + Duration::from_millis(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> future = Delay &#123; when &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> out = future.<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(out, <span class="string">&quot;done&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将异步函数当做Future"><a href="#将异步函数当做Future" class="headerlink" title="将异步函数当做Future"></a>将异步函数当做Future</h3><p>在<code>main</code>函数中，我们实例化future并在其上调用<code>.await</code>。从异步函数中，我们可以在任何实现了<code>Future</code>的值上调用<code>.await</code>。反过来，调用<code>async</code>函数会返回一个实现了<code>Future</code>的匿名类型。在<code>async fn main()</code>的情况下，生成的future大致为：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::future::Future;</span><br><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"><span class="keyword">use</span> std::task::&#123;Context, Poll&#125;;</span><br><span class="line"><span class="keyword">use</span> std::time::&#123;Duration, Instant&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MainFuture</span></span> &#123;</span><br><span class="line">    <span class="comment">// Initialized, never polled</span></span><br><span class="line">    State0,</span><br><span class="line">    <span class="comment">// Waiting on `Delay`, i.e. the `future.await` line.</span></span><br><span class="line">    State1(Delay),</span><br><span class="line">    <span class="comment">// The future has completed.</span></span><br><span class="line">    Terminated,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Future <span class="keyword">for</span> MainFuture &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = ();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">mut</span> <span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;)</span><br><span class="line">        -&gt; Poll&lt;()&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">use</span> MainFuture::*;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">                State0 =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> when = Instant::now() +</span><br><span class="line">                        Duration::from_millis(<span class="number">10</span>);</span><br><span class="line">                    <span class="keyword">let</span> future = Delay &#123; when &#125;;</span><br><span class="line">                    *<span class="keyword">self</span> = State1(future);</span><br><span class="line">                &#125;</span><br><span class="line">                State1(<span class="keyword">ref</span> <span class="keyword">mut</span> my_future) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">match</span> Pin::new(my_future).poll(cx) &#123;</span><br><span class="line">                        Poll::Ready(out) =&gt; &#123;</span><br><span class="line">                            <span class="built_in">assert_eq!</span>(out, <span class="string">&quot;done&quot;</span>);</span><br><span class="line">                            *<span class="keyword">self</span> = Terminated;</span><br><span class="line">                            <span class="keyword">return</span> Poll::Ready(());</span><br><span class="line">                        &#125;</span><br><span class="line">                        Poll::Pending =&gt; &#123;</span><br><span class="line">                            <span class="keyword">return</span> Poll::Pending;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Terminated =&gt; &#123;</span><br><span class="line">                    <span class="built_in">panic!</span>(<span class="string">&quot;future polled after completion&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rust future实际上是<strong>状态机</strong>。这里用一个包含了三种future可能状态的<code>enum</code>来表示<code>MainFuture</code>。future状态机始于<code>State0</code>状态。当调用<code>poll</code>时，future会尽可能地推进其内部状态。如果future能够完成，则返回包含了异步计算输出的<code>Poll::Ready</code>。</p>
<p>如果future无法完成，通常是由于它正在等待的资源尚未准备好，则返回<code>Poll::Pending</code>。若调用者收到<code>Poll::Pending</code>，则表明future将在稍后完成，调用者应该稍后再次调用<code>poll</code>。</p>
<p>我们还看到future也包含了其他future。调用外部future的<code>poll</code>会导致调用内部future的<code>poll</code>函数。</p>
<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>异步Rust函数返回future，而future必须依靠不断的<code>poll</code>调用来推进器状态。Future包含了其他future，那么问题来了，是谁在最外层的future调用<code>poll</code>呢？</p>
<p>回想一下，要运行异步函数，要么必须传递给<code>tokio::spawn</code>，要么使用带有<code>#[tokio::main]</code>标识的main函数。这实际上这是将生成的外层future提交给了Tokio执行器。执行器负责在外部<code>future</code>上调用<code>Future::poll</code>，以驱动异步计算完成执行。</p>
<h3 id="迷你Tokio"><a href="#迷你Tokio" class="headerlink" title="迷你Tokio"></a>迷你Tokio</h3><p>为了更好地理解这一切是如何组合在一起的，让我们实现我们自己的最小版本的Tokio！你可以在<a target="_blank" rel="noopener" href="https://github.com/tokio-rs/website/blob/master/tutorial-code/mini-tokio/src/main.rs">这里</a>找到完整的代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"><span class="keyword">use</span> std::future::Future;</span><br><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"><span class="keyword">use</span> std::task::&#123;Context, Poll&#125;;</span><br><span class="line"><span class="keyword">use</span> std::time::&#123;Duration, Instant&#125;;</span><br><span class="line"><span class="keyword">use</span> futures::task;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> mini_tokio = MiniTokio::new();</span><br><span class="line"></span><br><span class="line">    mini_tokio.spawn(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> when = Instant::now() + Duration::from_millis(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">let</span> future = Delay &#123; when &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> out = future.<span class="keyword">await</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(out, <span class="string">&quot;done&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    mini_tokio.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MiniTokio</span></span> &#123;</span><br><span class="line">    tasks: VecDeque&lt;Task&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Task</span></span> = Pin&lt;<span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Future&lt;Output = ()&gt; + <span class="built_in">Send</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> MiniTokio &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; MiniTokio &#123;</span><br><span class="line">        MiniTokio &#123;</span><br><span class="line">            tasks: VecDeque::new(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// Spawn a future onto the mini-tokio instance.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">spawn</span></span>&lt;F&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, future: F)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: Future&lt;Output = ()&gt; + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.tasks.push_back(<span class="built_in">Box</span>::pin(future));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> waker = task::noop_waker();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> cx = Context::from_waker(&amp;waker);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="keyword">mut</span> task) = <span class="keyword">self</span>.tasks.pop_front() &#123;</span><br><span class="line">            <span class="keyword">if</span> task.as_mut().poll(&amp;<span class="keyword">mut</span> cx).is_pending() &#123;</span><br><span class="line">                <span class="keyword">self</span>.tasks.push_back(task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里执行了一个异步代码块。使用给定的延迟创建了一个<code>Delay</code>实例，并处于等待状态。但是现在的实现存在一个<strong>问题</strong>，即执行器不会休眠。这个执行器会在生成的<strong>所有</strong>future上不断调用轮询。大多数时间里，future都不会就绪，只会继续返回<code>Poll::Pending</code>。这一过程将吃满CPU周期，所以通常效率不高。</p>
<p>理想情况下，我们希望mini-tokio只在future就绪时才去调用轮询。这种情况发生在任务所需的被阻塞资源转为可用，从而能够执任务所求情的操作时，例如，若任务想从TCP socket读取数据，则我们只希望在TCP socket收到数据时才进行轮询。在mini-tokio中，任务在给定的<code>Instant</code>时间内被阻塞，所以理想情况下，mini-tokio应只在任务给定的<code>Instance</code>时间过去后，再执行一次轮询。</p>
<p>为了实现这一目标，当轮询了某资源，且<strong>尚未</strong>就绪时，该资源应在过度到就绪状态后立即发送通知。</p>
<h2 id="唤醒器"><a href="#唤醒器" class="headerlink" title="唤醒器"></a>唤醒器</h2><p>现在我们还缺少唤醒器，即用于在资源就绪时，通知等待的任务资源已就绪，可以继续后面的操作。</p>
<p>再次观察<code>Future:poll</code>的函数签名：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context)</span><br><span class="line">    -&gt; Poll&lt;Self::Output&gt;;</span><br></pre></td></tr></table></figure>

<p><code>poll</code>的<code>Context</code>参数有一个<code>waker()</code>方法，它返回一个绑定当前任务的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/task/struct.Waker.html"><code>Waker</code></a>。<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/task/struct.Waker.html"><code>Waker</code></a>有一个<code>wake()</code>方法，调用此方法将通知执行器以安排执行相关任务。当资源过度到就绪状态时就会调用<code>wake()</code>，通知执行器轮询该任务以推进作业的执行。</p>
<h3 id="修改Delay"><a href="#修改Delay" class="headerlink" title="修改Delay"></a>修改<code>Delay</code></h3><p>给<code>Delay</code>代码加上唤醒器：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::future::Future;</span><br><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"><span class="keyword">use</span> std::task::&#123;Context, Poll&#125;;</span><br><span class="line"><span class="keyword">use</span> std::time::&#123;Duration, Instant&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Delay</span></span> &#123;</span><br><span class="line">    when: Instant,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Future <span class="keyword">for</span> Delay &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;)</span><br><span class="line">        -&gt; Poll&lt;&amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> Instant::now() &gt;= <span class="keyword">self</span>.when &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">            Poll::Ready(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Get a handle to the waker for the current task</span></span><br><span class="line">            <span class="keyword">let</span> waker = cx.waker().clone();</span><br><span class="line">            <span class="keyword">let</span> when = <span class="keyword">self</span>.when;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Spawn a timer thread.</span></span><br><span class="line">            thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">                <span class="keyword">let</span> now = Instant::now();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> now &lt; when &#123;</span><br><span class="line">                    thread::sleep(when - now);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                waker.wake();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            Poll::Pending</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，一旦等待到了指定的延时，就会通知调用的任务，执行器就可以再次安排轮询任务了。接下来我们修改mini-tokio的代码，从而能够接受唤醒通知。</p>
<p>这里的<code>Delay</code>实现仍存在一些问题，我们会稍后修复。</p>
<article class="message is-danger">
<div class="message-body">
<p>当future返回<code>Poll:Pending</code>时，<b>必须</b>确保在某个时刻通知唤醒器，若忘记执行此操作，会导致任务永久挂起。</p>
<p>在任务返回<code>Poll:Pending</code>后忘记唤醒是一个常见的bug。</p>
</div>
</article>

<p>回忆我们的第一版<code>Delay</code>，是这样实现future的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Future <span class="keyword">for</span> Delay &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;)</span><br><span class="line">        -&gt; Poll&lt;&amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> Instant::now() &gt;= <span class="keyword">self</span>.when &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">            Poll::Ready(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Ignore this line for now.</span></span><br><span class="line">            cx.waker().wake_by_ref();</span><br><span class="line">            Poll::Pending</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在返回<code>Poll:Pending</code>之前，我们调用了<code>cx.waker().wake_by_ref()</code>。这是为了符合future协议。由于返回了<code>Poll::Pending</code>，我们得负责通知唤醒器。由于此时我们还没实现计时器线程，所以我们在内部通知了唤醒器。这将导致该future被立刻安排轮询，从而再次执行，并且此刻的future依然没有就绪。</p>
<p>这里可以注意到，你确实可以比非必要不通知的理想状态，更频繁的通知唤醒器。比如上面的代码中，我们确实在未就绪的情况下通知了唤醒器。这也没什么大问题，只是浪费了点CPU周期，不过这种实现确实使得循环更加繁忙。</p>
<h3 id="修改Mini-Tokio"><a href="#修改Mini-Tokio" class="headerlink" title="修改Mini Tokio"></a>修改Mini Tokio</h3><p>接下来是修改Mini Tokio的代码，以接收唤醒器通知。我们希望执行器仅在任务唤醒时运行它们，为此，需要给Mini Tokio实现唤醒器。调用唤醒器时，其关联的任务将被排入执行队列。Mini-Tokio在轮询future时会将该唤醒器传给该future。</p>
<p>新的Mini Tokio将使用通道存储排入计划的任务。通道能够让排入队列的任务在任意线程上执行。唤醒器必须是<code>Send</code>且<code>Sync</code>的，所以我们使用crossbeam提供的通道，因为标准库的通道不是<code>Sync</code>的。</p>
<article class="message">
<div class="message-body">
<p><code>Send</code>和<code>Sync</code>是Rust提供的并发相关的标记trait。能够被**发送**到其他线程的类型就是<code>Send</code>的，除了<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a>之类的类型不是外，大多数类型都是<code>Send</code>的。能够通过不可变引用并发访问的类型就是<code>Sync</code>的。可以<code>Send</code>却不能<code>Sync</code>的类型，比如<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/cell/struct.Cell.html"><code>Cell</code></a>，就可以通过不可变引用修改，却不能被安全的并发访问。
</p>
<p>有关更多详情请参阅 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch16-04-extensible-concurrency-sync-and-send.html">Rust Book的相关章节</a>。</div></p>
</article>

<p>将以下依赖项添加到您的<code>Cargo.toml</code>，引入通道。</p>
<figure class="highlight toml"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">crossbeam</span> = <span class="string">&quot;0.8&quot;</span></span><br></pre></td></tr></table></figure>

<p>再更新<code>MiniTikio</code>结构体：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crossbeam::channel;</span><br><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MiniTokio</span></span> &#123;</span><br><span class="line">    scheduled: channel::Receiver&lt;Arc&lt;Task&gt;&gt;,</span><br><span class="line">    sender: channel::Sender&lt;Arc&lt;Task&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Task</span></span> &#123;</span><br><span class="line">    <span class="comment">// 将在下文中实现此结构体。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Wakers</code>既<code>Sync</code>又可被克隆。调用<code>wake</code>时，任务必须被安排执行。为了实现这一点，我们建立一个通道。当唤醒器调用<code>wake()</code>时，任务被推送到通道的发送端，我们的<code>Task</code>结构体将实现这个唤醒逻辑。为此，它需要同时包含生成的future和通道的发送端。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Task</span></span> &#123;</span><br><span class="line">    <span class="comment">// `Mutux`用以让`Task`实现`Sync`。同时只允许一个线程访问`future`。</span></span><br><span class="line">    <span class="comment">// `Mutex`在此处并不是为了保证正确性。实际上Tokio在这里也并没使用什么互斥锁，</span></span><br><span class="line">    <span class="comment">// 而是使用了大量其他代码实现这一功能。</span></span><br><span class="line">    future: Mutex&lt;Pin&lt;<span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Future&lt;Output = ()&gt; + <span class="built_in">Send</span>&gt;&gt;&gt;,</span><br><span class="line">    executor: channel::Sender&lt;Arc&lt;Task&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Task &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">schedule</span></span>(<span class="keyword">self</span>: &amp;Arc&lt;<span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.executor.send(<span class="keyword">self</span>.clone());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了安排任务，将<code>Arc</code>克隆并使用通道发送。现在，我们需要将<code>schedule</code>函数与<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/task/struct.Waker.html"><code>std::task::Waker</code></a>挂钩。标准库提供了一个低级API，让我们能够<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/task/struct.RawWakerVTable.html">手动构造vtable</a>以执行此操作。这种策略为实现者提供了最大的灵活性，但需要大量非安全的样板代码。这里，我们将使用<a target="_blank" rel="noopener" href="https://docs.rs/futures/"><code>futures</code></a> crate提供的<a target="_blank" rel="noopener" href="https://docs.rs/futures/0.3/futures/task/trait.ArcWake.html"><code>ArcWake</code></a>实用程序，以替代直接用 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/task/struct.RawWakerVTable.html"><code>RawWakerVTable</code></a>。这允许我们通过实现一个简单的trait来将<code>Task</code>结构体呈现为一个唤醒器。</p>
<p>将以下依赖项添加到<code>Cargo.toml</code>中以引入<code>futures</code>。</p>
<figure class="highlight toml"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">futures</span> = <span class="string">&quot;0.3&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后，实现<a target="_blank" rel="noopener" href="https://docs.rs/futures/0.3/futures/task/trait.ArcWake.html"><code>futures::task::ArcWake</code></a>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> futures::task::&#123;<span class="keyword">self</span>, ArcWake&#125;;</span><br><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">impl</span> ArcWake <span class="keyword">for</span> Task &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">wake_by_ref</span></span>(arc_self: &amp;Arc&lt;<span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">        arc_self.schedule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的定时器线程调用<code>waker.wake()</code>时，任务被推送到通道。接下来，我们在<code>MiniTokio::run()</code>函数中实现任务的接收和执行。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> MiniTokio &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Ok</span>(task) = <span class="keyword">self</span>.scheduled.recv() &#123;</span><br><span class="line">            task.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 初始化一个新的mini-tokio实例。</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; MiniTokio &#123;</span><br><span class="line">        <span class="keyword">let</span> (sender, scheduled) = channel::unbounded();</span><br><span class="line"></span><br><span class="line">        MiniTokio &#123; scheduled, sender &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 在mini-tokio中生成一个future</span></span><br><span class="line">    <span class="comment">/// </span></span><br><span class="line">    <span class="comment">/// 给定的future将包装在`Task`中并被送入`scheduled`队列。调用`run`时将执行此future。</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">spawn</span></span>&lt;F&gt;(&amp;<span class="keyword">self</span>, future: F)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: Future&lt;Output = ()&gt; + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        Task::spawn(future, &amp;<span class="keyword">self</span>.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Task &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Arc&lt;<span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">        <span class="comment">// 使用`Task`的实例创建一个唤醒器。这用到了上面的`ArcWake`实现。</span></span><br><span class="line">        <span class="keyword">let</span> waker = task::waker(<span class="keyword">self</span>.clone());</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> cx = Context::from_waker(&amp;waker);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有其他线程尝试获取future的锁。</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> future = <span class="keyword">self</span>.future.try_lock().unwrap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 轮询future</span></span><br><span class="line">        <span class="keyword">let</span> _ = future.as_mut().poll(&amp;<span class="keyword">mut</span> cx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用给定future生成一个新的task。</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 初始化一个包裹着给定future的新Task，并将其推送至`sender`。通道的接收端将获取这个task并执行。</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">spawn</span></span>&lt;F&gt;(future: F, sender: &amp;channel::Sender&lt;Arc&lt;Task&gt;&gt;)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: Future&lt;Output = ()&gt; + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> task = Arc::new(Task &#123;</span><br><span class="line">            future: Mutex::new(<span class="built_in">Box</span>::pin(future)),</span><br><span class="line">            executor: sender.clone(),</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> _ = sender.send(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码做了很多事，首先，首先，实现<code>MiniTokio::run()</code>，该函数执行一个从通道接收计划任务的循环。由于任务在被唤醒后推送到通道，因此这些任务在执行时能够取得进展。</p>
<p>此外，<code>MiniTokio::new()</code>和<code>MiniTokio::spawn()</code>函数现在改为使用通道，而不是之前的<code>VecDeque</code>。当生成新任务时，它们会得到一份通道发送端的克隆，从而让任务在在运行时自行使用。</p>
<p><code>Task::poll()</code>函数使用<code>futures</code> crate中的<a target="_blank" rel="noopener" href="https://docs.rs/futures/0.3/futures/task/trait.ArcWake.html"><code>ArcWake</code></a>实用程序创建唤醒器。唤醒器用于创建<code>task::Context</code>，<code>task::Context</code>将传递给<code>poll</code>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们现在已经看到了异步Rust如何工作的端到端示例。Rust的<code>async/await</code>特性通过多个trait共同实现。这允许第三方crate使用自定义的执行细节，如Tokio。</p>
<ul>
<li>异步Rust操作是惰性的，需要被调用者轮询。</li>
<li>唤醒器被传递给future，使得future能够找到到调用它的任务。</li>
<li>当资源尚未就绪时，返回<code>Poll::Pending</code>并记录任务的唤醒器。</li>
<li>当资源准备就绪时，通知任务的唤醒器。</li>
<li>执行器收到通知并安排任务执行。</li>
<li>再次轮询任务，这次资源就绪，任务取得进展。</li>
</ul>
<h2 id="一些未解决的问题"><a href="#一些未解决的问题" class="headerlink" title="一些未解决的问题"></a>一些未解决的问题</h2><p>回忆实现<code>Delay</code> future时，我们提到还有一些事情需要解决。Rust的异步模型允许单个future跨任务执行。考虑以下情形：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> futures::future::poll_fn;</span><br><span class="line"><span class="keyword">use</span> std::future::Future;</span><br><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> when = Instant::now() + Duration::from_millis(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> delay = <span class="literal">Some</span>(Delay &#123; when &#125;);</span><br><span class="line"></span><br><span class="line">    poll_fn(<span class="keyword">move</span> |cx| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> delay = delay.take().unwrap();</span><br><span class="line">        <span class="keyword">let</span> res = Pin::new(&amp;<span class="keyword">mut</span> delay).poll(cx);</span><br><span class="line">        <span class="built_in">assert!</span>(res.is_pending());</span><br><span class="line">        tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            delay.<span class="keyword">await</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Poll::Ready(())</span><br><span class="line">    &#125;).<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>poll_fn</code>函数使用闭包创建一个<code>Future</code>实例。上面的代码片段创建了一个<code>Delay</code>实例，轮询它一次，然后将<code>Delay</code>实例发送到新任务并执行<code>.await</code>。在这个例子中，<code>Delay::poll</code>被<strong>不同</strong>的<code>Waker</code>实例调用了不止一次。发生这种情况时，您必须确保在<em>最近一次</em>调用<code>poll</code>的<code>Waker</code>上调用<code>wake</code>。</p>
<p>在实现future时，应当假设每次调用<code>poll</code>都<strong>可能</strong>返回不同的<code>Waker</code>实例，轮询函数必须使用新的唤醒器代替旧的唤醒器。</p>
<p>我们早期的<code>Delay</code>实现在每次轮询时都会生成一个新线程。这没什么问题，但如果轮询过于频繁，效率可能会非常低（例如，如果您<code>select!</code>该future和其他future，只要其中之一有事件发生，则两者都会被轮询）。一种方法是记住你是否已经生成了一个线程，并只有在未生成线程时才执行生成。但是如果这样做，则必须确保在之后调用轮询时更新线程的唤醒器，否则你执行唤醒时将可能使用旧的唤醒器。</p>
<p>为了修复之前的实现，我们可以这样做：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::future::Future;</span><br><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::task::&#123;Context, Poll, Waker&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::&#123;Duration, Instant&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Delay</span></span> &#123;</span><br><span class="line">    when: Instant,</span><br><span class="line">    <span class="comment">// 当我们生一个新线程时为`Some`，否则为`None`。</span></span><br><span class="line">    waker: <span class="built_in">Option</span>&lt;Arc&lt;Mutex&lt;Waker&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Future <span class="keyword">for</span> Delay &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = ();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">mut</span> <span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;()&gt; &#123;</span><br><span class="line">        <span class="comment">// 首先，如果这是第一次调用future，则生成一个计时器线程。</span></span><br><span class="line">        <span class="comment">// 如果计时器线程已经存在，则应确保我们保存的`Waker`就是当前任务的唤醒器。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(waker) = &amp;<span class="keyword">self</span>.waker &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> waker = waker.lock().unwrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测保存的唤醒器是否匹配当前线程的唤醒器。</span></span><br><span class="line">            <span class="comment">// 这一步是必要的，因为`Delay` future的实例可能在两次轮询间隔内移动到另一个任务中。</span></span><br><span class="line">            <span class="comment">// 如果发生移动，则给定的`Context`中包含的唤醒器将会不同，</span></span><br><span class="line">            <span class="comment">// 我们必须更新之前存储的唤醒器，以对此变化做出反应。</span></span><br><span class="line">            <span class="keyword">if</span> !waker.will_wake(cx.waker()) &#123;</span><br><span class="line">                *waker = cx.waker().clone();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> when = <span class="keyword">self</span>.when;</span><br><span class="line">            <span class="keyword">let</span> waker = Arc::new(Mutex::new(cx.waker().clone()));</span><br><span class="line">            <span class="keyword">self</span>.waker = <span class="literal">Some</span>(waker.clone());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此处为第一次调用`poll`，生成计时器线程</span></span><br><span class="line">            thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">                <span class="keyword">let</span> now = Instant::now();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> now &lt; when &#123;</span><br><span class="line">                    thread::sleep(when - now);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当持续时间过去之后，调用唤醒器以通知调用者。</span></span><br><span class="line">                <span class="keyword">let</span> waker = waker.lock().unwrap();</span><br><span class="line">                waker.wake_by_ref();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在保存了唤醒器并启动了计时器线程后，就该检查给定的延时是否到达。</span></span><br><span class="line">        <span class="comment">// 这可以通过检测当前时刻来实现，如果持续时间已经过去，则future完成并返回`Poll::Ready``。</span></span><br><span class="line">        <span class="keyword">if</span> Instant::now() &gt;= <span class="keyword">self</span>.when &#123;</span><br><span class="line">            Poll::Ready(())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果持续时间没到，则future未完成，应返回`Poll:Pending`。</span></span><br><span class="line">            <span class="comment">// `Future` trait协议规定，返回`Pending`时，future应通知一次给定唤醒器，</span></span><br><span class="line">            <span class="comment">// future应被再次轮询。在我们的例子中，此处返回`Pending`，</span></span><br><span class="line">            <span class="comment">// 我们承诺一旦持续时间过去，就将调用参数`Context`中给定的唤醒器。</span></span><br><span class="line">            <span class="comment">// 我们能够做出承诺，是依靠上面生成的计时器线程。</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 如果我们忘记调用唤醒器，任务将永久挂起</span></span><br><span class="line">            Poll::Pending</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这有点复杂，不过基本思路是，在每次调用<code>poll</code>时，future检查提供的唤醒器是否与先前保存的唤醒器一致，若不一致，则必须保存新的唤醒器。</p>
<h3 id="Notify实用程序"><a href="#Notify实用程序" class="headerlink" title="Notify实用程序"></a><code>Notify</code>实用程序</h3><p>我们演示了如何使用唤醒器手动实现<code>Delay</code> future。唤醒器是是异步Rust工作的基础。通常，没有必要深入到那个程度。例如，在<code>Delay</code>中，我们完全可以通过使用<code>async/await</code>配合<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/sync/struct.Notify.html"><code>tokio::sync::Notify</code></a>实用程序来实现。该实用程序提供了一个基础的任务通知机制。它负责处理唤醒器的相关细节，包括确保保存的唤醒器与当前任务的唤醒器一致。</p>
<p>使用<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/sync/struct.Notify.html"><code>Notify</code></a>，我们可以像这样使用<code>async/await</code>实现<code>delay</code>函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::sync::Notify;</span><br><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> std::time::&#123;Duration, Instant&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">delay</span></span>(dur: Duration) &#123;</span><br><span class="line">    <span class="keyword">let</span> when = Instant::now() + dur;</span><br><span class="line">    <span class="keyword">let</span> notify = Arc::new(Notify::new());</span><br><span class="line">    <span class="keyword">let</span> notify2 = notify.clone();</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> now = Instant::now();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> now &lt; when &#123;</span><br><span class="line">            thread::sleep(when - now);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        notify2.notify_one();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    notify.notified().<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-Select"><a href="#10-Select" class="headerlink" title="10 Select"></a>10 Select</h1><hr>
<p>现在，当想要向系统添加并发时，我们就生成一个新任务。下面，我们将介绍一些使用Tokio并发执行异步代码的其他方法。</p>
<h2 id="tokio-select"><a href="#tokio-select" class="headerlink" title="tokio::select!"></a><code>tokio::select!</code></h2><p><code>tokio::select!</code>宏允许等待多个异步计算，并在某个计算完成时返回。</p>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::sync::oneshot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx1, rx1) = oneshot::channel();</span><br><span class="line">    <span class="keyword">let</span> (tx2, rx2) = oneshot::channel();</span><br><span class="line"></span><br><span class="line">    tokio::spawn(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> _ = tx1.send(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    tokio::spawn(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> _ = tx2.send(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    tokio::<span class="built_in">select!</span> &#123;</span><br><span class="line">        val = rx1 =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;rx1 completed first with &#123;:?&#125;&quot;</span>, val);</span><br><span class="line">        &#125;</span><br><span class="line">        val = rx2 =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;rx2 completed first with &#123;:?&#125;&quot;</span>, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于两个oneshot通道，任一通道都可能先完成。<code>select!</code>语句在两个通道上等待并将<code>val</code>绑定到任务返回的值。当<code>tx1</code>或<code>tx2</code>完成时，执行相关的代码块。</p>
<p><strong>未完成</strong>的分支将被丢弃。在示例中，程序等待每个通道的<code>oneshot::Receiver</code>。未完成通道的<code>oneshot::Receiver</code>会被丢弃。</p>
<h3 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h3><p>异步Rust的取消操作，是通过放弃future来执行的。回顾“<a href="./#9-%E6%B7%B1%E5%85%A5%E5%BC%82%E6%AD%A5">深入异步</a>”章节，异步Rust使用future实现，而future是惰性的，操作只有被轮询时才会进行。如果如果future被丢弃，由于所有相关状态都已删除，因此无法进行操作。</p>
<p>也就是说，有时异步操作会生成后台任务，或启动在后台运行的其他操作。例如，在上面的示例中，生成了一个任务以发送消息。通常，任务将执行一些计算以生成值。</p>
<p>Future或其他类型可以实现<code>Drop</code>以清理后台资源。<code>Tokio</code>的<code>oneshot::Receiver</code>通过向<code>Sender</code>端发送一条关闭消息来实现<code>Drop</code>。发送端可以收到此消息并取消进行中的操作。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::sync::oneshot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">some_operation</span></span>() -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="comment">// Compute value here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> tx1, rx1) = oneshot::channel();</span><br><span class="line">    <span class="keyword">let</span> (tx2, rx2) = oneshot::channel();</span><br><span class="line"></span><br><span class="line">    tokio::spawn(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="comment">// Select on the operation and the oneshot&#x27;s</span></span><br><span class="line">        <span class="comment">// `closed()` notification.</span></span><br><span class="line">        tokio::<span class="built_in">select!</span> &#123;</span><br><span class="line">            val = some_operation() =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> _ = tx1.send(val);</span><br><span class="line">            &#125;</span><br><span class="line">            _ = tx1.closed() =&gt; &#123;</span><br><span class="line">                <span class="comment">// `some_operation()` is canceled, the</span></span><br><span class="line">                <span class="comment">// task completes and `tx1` is dropped.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    tokio::spawn(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> _ = tx2.send(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    tokio::<span class="built_in">select!</span> &#123;</span><br><span class="line">        val = rx1 =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;rx1 completed first with &#123;:?&#125;&quot;</span>, val);</span><br><span class="line">        &#125;</span><br><span class="line">        val = rx2 =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;rx2 completed first with &#123;:?&#125;&quot;</span>, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="future的实现"><a href="#future的实现" class="headerlink" title="future的实现"></a><code>future</code>的实现</h3><p>为了更好的理解<code>select!</code>是如何工作的，让我们看看一个假想的<code>Future</code>实现会是什么样子。这是一个简化版本，现实中的<code>select!</code>还包含其他功能，例如随机选择首先轮询的分支。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::sync::oneshot;</span><br><span class="line"><span class="keyword">use</span> std::future::Future;</span><br><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"><span class="keyword">use</span> std::task::&#123;Context, Poll&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MySelect</span></span> &#123;</span><br><span class="line">    rx1: oneshot::Receiver&lt;&amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>&gt;,</span><br><span class="line">    rx2: oneshot::Receiver&lt;&amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Future <span class="keyword">for</span> MySelect &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = ();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">mut</span> <span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;()&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> Poll::Ready(val) = Pin::new(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.rx1).poll(cx) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;rx1 completed first with &#123;:?&#125;&quot;</span>, val);</span><br><span class="line">            <span class="keyword">return</span> Poll::Ready(());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> Poll::Ready(val) = Pin::new(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.rx2).poll(cx) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;rx2 completed first with &#123;:?&#125;&quot;</span>, val);</span><br><span class="line">            <span class="keyword">return</span> Poll::Ready(());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Poll::Pending</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx1, rx1) = oneshot::channel();</span><br><span class="line">    <span class="keyword">let</span> (tx2, rx2) = oneshot::channel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use tx1 and tx2</span></span><br><span class="line"></span><br><span class="line">    MySelect &#123;</span><br><span class="line">        rx1,</span><br><span class="line">        rx2,</span><br><span class="line">    &#125;.<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MySelect</code> future包含两个分支的future。轮询<code>MySelect</code>时，将轮询第一个分支。若就绪，则使用该值，<code>MySelect</code>完成。在<code>.await</code>收到future的输出后，future将被丢弃，这导致两个分支的futures均被删除。由于一个分支没有完成，操作实际上被取消了。</p>
<p>回忆上一节的内容：</p>
<article class="message is-danger">
<div class="message-body">
<p>当future返回<code>Poll:Pending</code>时，<b>必须</b>确保在某个时刻通知唤醒器，若忘记执行此操作，会导致任务永久挂起。</p>
<p>在任务返回<code>Poll:Pending</code>后忘记唤醒是一个常见的bug。</p>
</div>
</article>

<p><code>MySelect</code>实现中并没用显式使用<code>Context</code>参数，而是通过将<code>cx</code>传给内部的future来满足唤醒器的要求。通过仅在从内部future收到<code>Poll::Pending</code>时才返回<code>Poll::Pending</code>，来使内部future也满足唤醒器的要求，<code>MySelect</code>也满足唤醒器的要求。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>select!</code>宏可以处理多个分支，目前的限制为64个分支。每个分支的结构如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;pattern&gt; = &lt;<span class="keyword">async</span> expression&gt; =&gt; &lt;handler&gt;,</span><br></pre></td></tr></table></figure>

<p>当select宏求值时，所有<code>&lt;async expression&gt;</code>都会聚合并同时执行。当表达式完成时，结果与<code>&lt;pattern&gt;</code>匹配，若结果匹配，则取消所有剩余的异步表达式并执行<code>&lt;handler&gt;</code>。<code>&lt;handler&gt;</code>表达式可以访问<code>&lt;pattern&gt;</code>绑定的变量。</p>
<p><code>&lt;pattern&gt;</code>的基本用法是给一个变量名赋值，即异步表达式的结果绑定到该变量名，使<code>&lt;handler&gt;</code>可以访问该变量。这就是为什么在上面的示例中，<code>val</code>用于<code>&lt;pattern&gt;</code>，<code>&lt;handler&gt;</code>能够访问<code>val</code>。</p>
<p>如果<code>&lt;pattern&gt;</code>与异步计算的结果不匹配，则剩余的异步表达式将继续并发执行，直到下一个完成。这时，上面的逻辑继续应用作用于该结果。</p>
<p><code>select!</code>中可以使用任意异步表达式，因此可以定义更复杂的选择计算。</p>
<p>下面的例子中，我们在<code>oneshot</code>通道的输出和<code>TCP</code>连接上进行选择操作。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::net::TcpStream;</span><br><span class="line"><span class="keyword">use</span> tokio::sync::oneshot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = oneshot::channel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成一个使用oneshot发送信息的任务</span></span><br><span class="line">    tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        tx.send(<span class="string">&quot;done&quot;</span>).unwrap();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    tokio::<span class="built_in">select!</span> &#123;</span><br><span class="line">        socket = TcpStream::connect(<span class="string">&quot;localhost:3465&quot;</span>) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Socket connected &#123;:?&#125;&quot;</span>, socket);</span><br><span class="line">        &#125;</span><br><span class="line">        msg = rx =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;received message first &#123;:?&#125;&quot;</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的例子中，我们在<code>oneshot</code>通道和<code>TcpListener</code>socket间进行选择操作。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::net::TcpListener;</span><br><span class="line"><span class="keyword">use</span> tokio::sync::oneshot;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = oneshot::channel();</span><br><span class="line"></span><br><span class="line">    tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        tx.send(()).unwrap();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> listener = TcpListener::bind(<span class="string">&quot;localhost:3465&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    tokio::<span class="built_in">select!</span> &#123;</span><br><span class="line">        _ = <span class="keyword">async</span> &#123;</span><br><span class="line">            <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> (socket, _) = listener.accept().<span class="keyword">await</span>?;</span><br><span class="line">                tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123; process(socket) &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Help the rust type inferencer out</span></span><br><span class="line">            Ok::&lt;_, io::Error&gt;(())</span><br><span class="line">        &#125; =&gt; &#123;&#125;</span><br><span class="line">        _ = rx =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;terminating accept loop&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环将一直运行，直到遇到错误，或<code>rx</code>收到值。<code>_</code>模式表示我们对异步计算的返回值不感兴趣。</p>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p><code>tokio::select!</code>宏返回<code>&lt;handler&gt;</code>表达式求值的结果。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">computation1</span></span>() -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="comment">// .. computation</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">computation2</span></span>() -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="comment">// .. computation</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> out = tokio::<span class="built_in">select!</span> &#123;</span><br><span class="line">        res1 = computation1() =&gt; res1,</span><br><span class="line">        res2 = computation2() =&gt; res2,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got = &#123;&#125;&quot;</span>, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，<strong>每个</strong>分支的<code>&lt;handler&gt;</code>表达式的求值结果应为相同的类型。如果某个<code>select!</code>表达式不需要输出，最好将表达式的求值结果写为<code>()</code>。</p>
<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>使用<code>?</code>运算符从表达式中传播错误，具体的行为取决于<code>?</code>是用在异步表达式（<code>&lt;async expression&gt;</code>）中，还是用在处理程序（<code>&lt;handelr&gt;</code>）中。在异步表达式中使用<code>?</code>会将错误传播到异步表达式之外，这使得异步表达式的输出为<code>Result</code>类型；在处理程序中使用<code>?</code>会立刻将错误传播到<code>select!</code>表达式之外。让我们再看一遍上面接受socket循环的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::net::TcpListener;</span><br><span class="line"><span class="keyword">use</span> tokio::sync::oneshot;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// [setup `rx` oneshot channel]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> listener = TcpListener::bind(<span class="string">&quot;localhost:3465&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    tokio::<span class="built_in">select!</span> &#123;</span><br><span class="line">        res = <span class="keyword">async</span> &#123;</span><br><span class="line">            <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> (socket, _) = listener.accept().<span class="keyword">await</span>?;</span><br><span class="line">                tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123; process(socket) &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Help the rust type inferencer out</span></span><br><span class="line">            Ok::&lt;_, io::Error&gt;(())</span><br><span class="line">        &#125; =&gt; &#123;</span><br><span class="line">            res?;</span><br><span class="line">        &#125;</span><br><span class="line">        _ = rx =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;terminating accept loop&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意<code>listener.accept().await?</code>，<code>?</code>运算符将错误从该表达式传播到<code>res</code>绑定变量。出现错误时，<code>res</code>将被设置为<code>Err(_)</code>。处理程序中再次使用了<code>?</code>运算符，<code>res?</code>语句将错误传播到<code>main</code>函数之外。</p>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>回忆<code>select!</code>宏的分支定义语法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;pattern&gt; = &lt;<span class="keyword">async</span> expression&gt; =&gt; &lt;handler&gt;,</span><br></pre></td></tr></table></figure>

<p>到目前为止，我们只在<code>&lt;pattern&gt;</code>处用了变量绑定。实际上，我们可以使用任何Rust模式匹配。例如，假设我们从多个MPSC通道接收数据，就可以这样写：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> tx1, <span class="keyword">mut</span> rx1) = mpsc::channel(<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> tx2, <span class="keyword">mut</span> rx2) = mpsc::channel(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="comment">// Do something w/ `tx1` and `tx2`</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    tokio::<span class="built_in">select!</span> &#123;</span><br><span class="line">        <span class="literal">Some</span>(v) = rx1.recv() =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Got &#123;:?&#125; from rx1&quot;</span>, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">Some</span>(v) = rx2.recv() =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Got &#123;:?&#125; from rx2&quot;</span>, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Both channels closed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>select!</code>表达式等待从<code>rx1</code>和<code>rx2</code>接收值。如果一个通道关闭，<code>recv()</code>返回<code>None</code>，则无法满足匹配，此分支将失效。于是<code>select!</code>表达式继续等待剩余的分支。</p>
<p>注意这个<code>select!</code>表达式包含一个<code>else</code>分支，即<code>select!</code>表达式必须返回一个值。使用模式匹配时，可能<strong>没有</strong>分支能够匹配其的关联模式，如果发生这种情况，则由<code>else</code>分支求值。</p>
<h2 id="借用"><a href="#借用" class="headerlink" title="借用"></a>借用</h2><p>当生成任务时，产生异步表达式必持有其所需数据的所有权，而<code>select!</code>宏并没有这种限制，每个分支的异步表达式可以借用数据且同时运行。遵循Rust的借用规则，多个异步表达式可以同时对某块数据进行不可变借用，<strong>或者</strong>，仅一个异步表达式可以对某块数据进行可变借用。</p>
<p>下面的例子中，我们同时将相同的数据发送到两个不同的TCP目的地址。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::io::AsyncWriteExt;</span><br><span class="line"><span class="keyword">use</span> tokio::net::TcpStream;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::net::SocketAddr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">race</span></span>(</span><br><span class="line">    data: &amp;[<span class="built_in">u8</span>],</span><br><span class="line">    addr1: SocketAddr,</span><br><span class="line">    addr2: SocketAddr</span><br><span class="line">) -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    tokio::<span class="built_in">select!</span> &#123;</span><br><span class="line">        <span class="literal">Ok</span>(_) = <span class="keyword">async</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> socket = TcpStream::connect(addr1).<span class="keyword">await</span>?;</span><br><span class="line">            socket.write_all(data).<span class="keyword">await</span>?;</span><br><span class="line">            Ok::&lt;_, io::Error&gt;(())</span><br><span class="line">        &#125; =&gt; &#123;&#125;</span><br><span class="line">        <span class="literal">Ok</span>(_) = <span class="keyword">async</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> socket = TcpStream::connect(addr2).<span class="keyword">await</span>?;</span><br><span class="line">            socket.write_all(data).<span class="keyword">await</span>?;</span><br><span class="line">            Ok::&lt;_, io::Error&gt;(())</span><br><span class="line">        &#125; =&gt; &#123;&#125;</span><br><span class="line">        <span class="keyword">else</span> =&gt; &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个异步表达式都使用了<code>data</code>变量这一不可变借用。当其中一个操作成功完成时，另一个操作将被丢弃。因为我们需要匹配<code>Ok(_)</code>，如果一个表达式失败，另一个则将继续执行。</p>
<p>当执行到每个分支的<code>&lt;handler&gt;</code>时，<code>select!</code>保证只会有一个<code>&lt;handler&gt;</code>执行。因此，每个<code>&lt;handler&gt;</code>可以对同一块数据进行可变借用。</p>
<p>下面的例子中，两个处理程序都尝试对<code>out</code>进行修改：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::sync::oneshot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx1, rx1) = oneshot::channel();</span><br><span class="line">    <span class="keyword">let</span> (tx2, rx2) = oneshot::channel();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> out = <span class="built_in">String</span>::new();</span><br><span class="line"></span><br><span class="line">    tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="comment">// Send values on `tx1` and `tx2`.</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    tokio::<span class="built_in">select!</span> &#123;</span><br><span class="line">        _ = rx1 =&gt; &#123;</span><br><span class="line">            out.push_str(<span class="string">&quot;rx1 completed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        _ = rx2 =&gt; &#123;</span><br><span class="line">            out.push_str(<span class="string">&quot;rx2 completed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p><code>select!</code>宏经常用在循环中，本节将介绍一些例子，以展示在循环中使用<code>select!</code>宏的常见方法。第一个例子是在多个通道上进行选择：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx1, <span class="keyword">mut</span> rx1) = mpsc::channel(<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">let</span> (tx2, <span class="keyword">mut</span> rx2) = mpsc::channel(<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">let</span> (tx3, <span class="keyword">mut</span> rx3) = mpsc::channel(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> msg = tokio::<span class="built_in">select!</span> &#123;</span><br><span class="line">            <span class="literal">Some</span>(msg) = rx1.recv() =&gt; msg,</span><br><span class="line">            <span class="literal">Some</span>(msg) = rx2.recv() =&gt; msg,</span><br><span class="line">            <span class="literal">Some</span>(msg) = rx3.recv() =&gt; msg,</span><br><span class="line">            <span class="keyword">else</span> =&gt; &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Got &#123;:?&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;All channels have been closed.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子在三个通道的接收端上选择，当任一通道的接收端收到信息，就输出到STDOUT。当一个通道关闭时，<code>recv()</code>返回<code>None</code>，由于模式匹配，<code>select!</code>宏将继续等待其余通道。当所有通道关闭时，<code>else</code>分支将求值从而终止循环。</p>
<p><code>select!</code>宏以随机的方式决定首先检查哪个分支是否就绪，当多个通道的值均未就绪时，将随机选择一个通道接受信息。这是为了处理接收循环的处理速度，慢于消息推入通道的速度的情况，这意味着通道可能被填满。如果<code>select!</code>首选检查的分支不是随机的，而是每次循环都首选检查<code>rx1</code>，若<code>rx1</code>始终都有一条新消息，则其他通道将永远不会被检查。</p>
<p>如果选择时！ 进行评估，多个通道有未决消息，只有一个通道弹出一个值。 所有其他频道都没有受到影响，他们的消息一直在这些频道中，直到下一次循环迭代为止。 没有消息丢失。</p>
<article class="message is-danger">
<div class="message-body">
<p>当<code>select!</code>求值，只有一个通道有就绪值，其余通道都在等待时，其余通道的代码不会被执行，其余通道的信息将停留在通道内知道下一次迭代。因此不会有信息丢失。</p>
</div>
</article>

<h3 id="恢复一个异步操作"><a href="#恢复一个异步操作" class="headerlink" title="恢复一个异步操作"></a>恢复一个异步操作</h3><p>下面的例子将展示如何在多个<code>select!</code>调用间执行同一个异步操作。在此示例中，我们有一个类型为<code>i32</code>的MPSC通道和一个异步函数。我们希望一直运行异步函数，直到任务完成，或在通道上接收到一个偶数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">action</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Some asynchronous logic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> tx, <span class="keyword">mut</span> rx) = tokio::sync::mpsc::channel(<span class="number">128</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> operation = action();</span><br><span class="line">    tokio::pin!(operation);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        tokio::<span class="built_in">select!</span> &#123;</span><br><span class="line">            _ = &amp;<span class="keyword">mut</span> operation =&gt; <span class="keyword">break</span>,</span><br><span class="line">            <span class="literal">Some</span>(v) = rx.recv() =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> v % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里是如何再循环外，而不是在<code>select!</code>宏内调用<code>action()</code>的。<code>aciont()</code>的返回值被赋给<code>operation</code>，且<strong>不执行</strong><code>.await</code>。然后我们在<code>operation</code>上调用<code>tokio:pin!</code>。</p>
<p>在<code>select!</code>循环内，我们传入<code>&amp;mut operation</code>，而不是<code>operation</code>。<code>operation</code>变量正在跟踪执行中的异步操作，循环的每次迭代都使用同一个变量，而不是调用一个新的<code>action()</code>。</p>
<p>另一个<code>select!</code>分支从通道接收数据，如果是一个偶数，则终止循环，否则再次<code>select!</code>。</p>
<p>此处是我们第一次使用<code>tokio::pin!</code>，这里我们并不介绍关于内存固定的细节，只需要注意，如果要<code>.await</code>一个引用，被引用的值必须是被固定的，或是实现了<code>Unpin</code>的。</p>
<p>如果我们删除<code>tokio::pin!</code>一行并尝试编译，就会收到以下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">error[E0599]: no method named `poll` found for struct</span><br><span class="line">     `std::pin::Pin&lt;&amp;mut &amp;mut impl std::future::Future&gt;`</span><br><span class="line">     in the current scope</span><br><span class="line">  --&gt; src/main.rs:16:9</span><br><span class="line">   |</span><br><span class="line">16 | /         tokio::select! &#123;</span><br><span class="line">17 | |             _ = &amp;mut operation =&gt; break,</span><br><span class="line">18 | |             Some(v) = rx.recv() =&gt; &#123;</span><br><span class="line">19 | |                 if v % 2 == 0 &#123;</span><br><span class="line">...  |</span><br><span class="line">22 | |             &#125;</span><br><span class="line">23 | |         &#125;</span><br><span class="line">   | |_________^ method not found in</span><br><span class="line">   |             `std::pin::Pin&lt;&amp;mut &amp;mut impl std::future::Future&gt;`</span><br><span class="line">   |</span><br><span class="line">   = note: the method `poll` exists but the following trait bounds</span><br><span class="line">            were not satisfied:</span><br><span class="line">           `impl std::future::Future: std::marker::Unpin`</span><br><span class="line">           which is required by</span><br><span class="line">           `&amp;mut impl std::future::Future: std::future::Future`</span><br></pre></td></tr></table></figure>

<p>虽然我们在<a href="./#9-%E6%B7%B1%E5%85%A5%E5%BC%82%E6%AD%A5">上一章</a>介绍了<code>Future</code>，但仍然不能明白这个错误。如果你尝试在一个<strong>引用</strong>上调用<code>.await</code>时，遇到了这种关于<code>Future</code>未被实现的错误，那么你可能需要固定该future。</p>
<p>在<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/pin/index.html">标准库</a>上阅读更多有关<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/pin/index.html"><code>Pin</code></a>的信息。</p>
<h3 id="修改一个分支"><a href="#修改一个分支" class="headerlink" title="修改一个分支"></a>修改一个分支</h3><p>再看一个稍微复杂一点的循环，其中有：</p>
<ol>
<li>一个<code>i32</code>类型的通道。</li>
<li>在<code>i32</code>值上执行的异步操作。</li>
</ol>
<p>我们想要实现的逻辑是：</p>
<ol>
<li>在通道上等待一个偶数。</li>
<li>使用该偶数作为输入以启动异步操作。</li>
<li>等待操作完成，但同时监听通道上的其他偶数。</li>
<li>如果在现有操作完成之前收到新的偶数，则终止现有操作并使用新偶数重新开始。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">action</span></span>(input: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 若输入为`None`则返回`None`。</span></span><br><span class="line">    <span class="comment">// 此处也可以简写为`let i = input?；`</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="keyword">match</span> input &#123;</span><br><span class="line">        <span class="literal">Some</span>(input) =&gt; input,</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="keyword">return</span> <span class="literal">None</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// async logic here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> tx, <span class="keyword">mut</span> rx) = tokio::sync::mpsc::channel(<span class="number">128</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> done = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> operation = action(<span class="literal">None</span>);</span><br><span class="line">    tokio::pin!(operation);</span><br><span class="line">    </span><br><span class="line">    tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> _ = tx.send(<span class="number">1</span>).<span class="keyword">await</span>;</span><br><span class="line">        <span class="keyword">let</span> _ = tx.send(<span class="number">3</span>).<span class="keyword">await</span>;</span><br><span class="line">        <span class="keyword">let</span> _ = tx.send(<span class="number">2</span>).<span class="keyword">await</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        tokio::<span class="built_in">select!</span> &#123;</span><br><span class="line">            res = &amp;<span class="keyword">mut</span> operation, <span class="keyword">if</span> !done =&gt; &#123;</span><br><span class="line">                done = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(v) = res &#123;</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;GOT = &#123;&#125;&quot;</span>, v);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">Some</span>(v) = rx.recv() =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> v % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// `.set` is a method on `Pin`.</span></span><br><span class="line">                    operation.set(action(<span class="literal">Some</span>(v)));</span><br><span class="line">                    done = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用与上一个例子类似的策略，在循环外调用异步函数并将结果赋给<code>operation</code>，再将<code>operation</code>变量固定。循环中的选择操作同事在<code>operation</code>上与通道接收端上进行。</p>
<p>留意<code>action</code>是如何将<code>Option&lt;i32&gt;</code>作为参数的。在我们收到第一个偶数之前，我们需要将<code>operation</code>实例化，此处通过接收一个<code>Option</code>并返回一个<code>Option</code>来创建<code>action</code>，而如果传入为<code>None</code>则返回也为<code>None</code>。第一次循环迭代，<code>operation</code>返回<code>None</code>后立即完成。</p>
<p>例子中还使用了一些新的语法，第一个分支中的<code>, if !done</code>，即设置分支的前置条件。在解释它是如何工作之前，让我们看看如果删掉前置条件会发生什么。删除<code>, if !done</code>再运行例子会产生以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at &#x27;`async fn` resumed after completion&#x27;, src/main.rs:1:55</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br></pre></td></tr></table></figure>

<p>在<code>operation</code>完成后再次尝试调用就会发生此错误。通常，在使用<code>.await</code>时，被等待的值会被使用掉，而在这个例子中，我们等待的是一个引用。这意味着<code>operation</code>在完成后仍然存在。</p>
<p>为避免这种panic，我们必须要在操作完成后禁用第一个分支，此处<code>done</code>变量用于跟踪操作是否完成。一个<code>select!</code>分支可能包含一个前置条件，<code>select!</code>在等待分支之前会检查这个前提条件，如果前置条件求值为<code>false</code>，则分支被禁用。<code>done</code>变量初始化时为<code>false</code>，当操作完成时，<code>done</code>设置为<code>true</code>，在下一个循环迭代中将禁用<code>operation</code>分支。当从通道接收到的消息为偶数时，<code>operation</code>将被重置，<code>done</code>也将置为<code>false</code>。</p>
<h2 id="单任务并发"><a href="#单任务并发" class="headerlink" title="单任务并发"></a>单任务并发</h2><p><code>tokio::spawn</code>和<code>select!</code>都可以运行异步并发操作，但是，它们运行并发操作时使用的策略并不相同。<code>tokio::spawn</code>函数接受一个异步操作后生成一个新任务以运行该操作，即Tokio运行时调度的对象是任务。Tokio分别安排了两个不同的任务，它们可能运行在不同的系统线程上，因此，生成任务与生成线程具有相同的限制：禁止借用。</p>
<p>而<code>select!</code>宏在同一任务上同时运行所有分支。由于<code>select!</code>宏的所有分支在同一个任务上执行，它们永远不会同时运行。即<code>slect!</code>宏在单个任务上复用了异步操作。</p>
<h1 id="流"><a href="#流" class="headerlink" title="流"></a>流</h1><hr>
<p>流，就是一系列异步值，是Rust的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch13-02-iterators.html"><code>std::iter::Iterator</code></a>的异步版本，用<a target="_blank" rel="noopener" href="https://docs.rs/futures-core/0.3/futures_core/stream/trait.Stream.html"><code>Stream</code></a> trait表示。在异步函数中可以迭代遍历流，也可以使用适配器转换流。Tokio在<a target="_blank" rel="noopener" href="https://docs.rs/tokio-stream/0.1/tokio_stream/trait.StreamExt.html"><code>StreamExt</code></a> trait上提供了许多通用适配器。</p>
<p>Tokio在一个独立的crate中提供流支持：<code>tokio-stream</code>。</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tokio-stream</span> = <span class="string">&quot;0.1&quot;</span></span><br></pre></td></tr></table></figure>

<article class="message is-danger">
<div class="message-body">
<p>目前，Tokio的Stream实用程序放在<code>tokio-stream</code> crate 中。一旦<code>Steam</code> triat在Rust标准库中稳定下来，Tokio的流实用程序将被移动到<code>tokio</code>中。</p>
</div>
</article>

<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>目前，Rust语言还不支持异步<code>for</code>循环，代替方案是使用<code>while let</code>循环配合<a target="_blank" rel="noopener" href="https://docs.rs/tokio-stream/0.1/tokio_stream/trait.StreamExt.html#method.next"><code>StreamExt::next()</code></a>在流上进行迭代。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio_stream::StreamExt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> stream = tokio_stream::iter(&amp;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(v) = stream.next().<span class="keyword">await</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;GOT = &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与迭代器类似，<code>next()</code>方法返回<code>Option&lt;T&gt;</code>，<code>T</code>为流内值的类型，若收到<code>None</code>则表示流迭代终止。</p>
<h3 id="Mini-Redis广播"><a href="#Mini-Redis广播" class="headerlink" title="Mini-Redis广播"></a>Mini-Redis广播</h3><p>让我们来再看一个使用Mini-Redis客户端的稍微复杂的例子。</p>
<p>你可以在<a target="_blank" rel="noopener" href="https://github.com/tokio-rs/website/blob/master/tutorial-code/streams/src/main.rs">这里</a>找到完整的代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio_stream::StreamExt;</span><br><span class="line"><span class="keyword">use</span> mini_redis::client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">publish</span></span>() -&gt; mini_redis::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> client = client::connect(<span class="string">&quot;127.0.0.1:6379&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Publish some data</span></span><br><span class="line">    client.publish(<span class="string">&quot;numbers&quot;</span>, <span class="string">&quot;1&quot;</span>.into()).<span class="keyword">await</span>?;</span><br><span class="line">    client.publish(<span class="string">&quot;numbers&quot;</span>, <span class="string">&quot;two&quot;</span>.into()).<span class="keyword">await</span>?;</span><br><span class="line">    client.publish(<span class="string">&quot;numbers&quot;</span>, <span class="string">&quot;3&quot;</span>.into()).<span class="keyword">await</span>?;</span><br><span class="line">    client.publish(<span class="string">&quot;numbers&quot;</span>, <span class="string">&quot;four&quot;</span>.into()).<span class="keyword">await</span>?;</span><br><span class="line">    client.publish(<span class="string">&quot;numbers&quot;</span>, <span class="string">&quot;five&quot;</span>.into()).<span class="keyword">await</span>?;</span><br><span class="line">    client.publish(<span class="string">&quot;numbers&quot;</span>, <span class="string">&quot;6&quot;</span>.into()).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">subscribe</span></span>() -&gt; mini_redis::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> client = client::connect(<span class="string">&quot;127.0.0.1:6379&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="keyword">let</span> subscriber = client.subscribe(<span class="built_in">vec!</span>[<span class="string">&quot;numbers&quot;</span>.to_string()]).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="keyword">let</span> messages = subscriber.into_stream();</span><br><span class="line"></span><br><span class="line">    tokio::pin!(messages);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(msg) = messages.next().<span class="keyword">await</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;got = &#123;:?&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; mini_redis::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    tokio::spawn(<span class="keyword">async</span> &#123;</span><br><span class="line">        publish().<span class="keyword">await</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    subscribe().<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;DONE&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成一个任务以在Mini-Redis服务器的“number”频道上发布消息。然后，在主任务中订阅“numbers”频道并打印收到的消息。</p>
<p>订阅后，在返回的订阅者上调用<code>into_stream()</code>。如此将消耗掉该<code>Subscriber</code>，并返回一个能够在消息到达时产生消息的流。请注意，在开始迭代消息之前，我们用<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1/tokio/macro.pin.html"><code>tokio::pin!</code></a>将流<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/pin/index.html">固定</a>在栈上，因为在流上调用<code>next()</code>需要固定该流。<code>into_stream()</code>函数返回一个<em>未固定</em>的流，我们必须显式固定后才能迭代它。</p>
<p>固定值的一个关键属性是可以将指针指向固定数据，并且调用者可以确信指针保持有效。 async/await 使用此功能来支持跨 .await 点借用数据。</p>
<article class="message is-danger">
<div class="message-body">
<p>当一个Rust值不能再在内存中移动时，就称为被“固定”了。对于被固定的值，其中一个关键属性是可以将指针指向该数据，而调用者可以确信指针始终有效。<code>async/await</code>使用此特性来支持跨<code>.await</code>时对借用数据进行调用。</p>
</div>
</article>

<p>如果我们忘记固定流，就会看到类似下面的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: `from_generator::GenFuture&lt;[static generator@Subscriber::into_stream::&#123;closure#0&#125; for&lt;&#x27;r, &#x27;s, &#x27;t0, &#x27;t1, &#x27;t2, &#x27;t3, &#x27;t4, &#x27;t5, &#x27;t6&gt; &#123;ResumeTy, &amp;&#x27;r mut Subscriber, Subscriber, impl Future, (), std::result::Result&lt;Option&lt;Message&gt;, Box&lt;(dyn std::error::Error + Send + Sync + &#x27;t0)&gt;&gt;, Box&lt;(dyn std::error::Error + Send + Sync + &#x27;t1)&gt;, &amp;&#x27;t2 mut async_stream::yielder::Sender&lt;std::result::Result&lt;Message, Box&lt;(dyn std::error::Error + Send + Sync + &#x27;t3)&gt;&gt;&gt;, async_stream::yielder::Sender&lt;std::result::Result&lt;Message, Box&lt;(dyn std::error::Error + Send + Sync + &#x27;t4)&gt;&gt;&gt;, std::result::Result&lt;Message, Box&lt;(dyn std::error::Error + Send + Sync + &#x27;t5)&gt;&gt;, impl Future, Option&lt;Message&gt;, Message&#125;]&gt;` cannot be unpinned</span><br><span class="line">  --&gt; streams/src/main.rs:29:36</span><br><span class="line">   |</span><br><span class="line">29 |     while let Some(msg) = messages.next().await &#123;</span><br><span class="line">   |                                    ^^^^ within `tokio_stream::filter::_::__Origin&lt;&#x27;_, impl Stream, [closure@streams/src/main.rs:22:17: 25:10]&gt;`, the trait `Unpin` is not implemented for `from_generator::GenFuture&lt;[static generator@Subscriber::into_stream::&#123;closure#0&#125; for&lt;&#x27;r, &#x27;s, &#x27;t0, &#x27;t1, &#x27;t2, &#x27;t3, &#x27;t4, &#x27;t5, &#x27;t6&gt; &#123;ResumeTy, &amp;&#x27;r mut Subscriber, Subscriber, impl Future, (), std::result::Result&lt;Option&lt;Message&gt;, Box&lt;(dyn std::error::Error + Send + Sync + &#x27;t0)&gt;&gt;, Box&lt;(dyn std::error::Error + Send + Sync + &#x27;t1)&gt;, &amp;&#x27;t2 mut async_stream::yielder::Sender&lt;std::result::Result&lt;Message, Box&lt;(dyn std::error::Error + Send + Sync + &#x27;t3)&gt;&gt;&gt;, async_stream::yielder::Sender&lt;std::result::Result&lt;Message, Box&lt;(dyn std::error::Error + Send + Sync + &#x27;t4)&gt;&gt;&gt;, std::result::Result&lt;Message, Box&lt;(dyn std::error::Error + Send + Sync + &#x27;t5)&gt;&gt;, impl Future, Option&lt;Message&gt;, Message&#125;]&gt;`</span><br><span class="line">   |</span><br><span class="line">   = note: required because it appears within the type `impl Future`</span><br><span class="line">   = note: required because it appears within the type `async_stream::async_stream::AsyncStream&lt;std::result::Result&lt;Message, Box&lt;(dyn std::error::Error + Send + Sync + &#x27;static)&gt;&gt;, impl Future&gt;`</span><br><span class="line">   = note: required because it appears within the type `impl Stream`</span><br><span class="line">   = note: required because it appears within the type `tokio_stream::filter::_::__Origin&lt;&#x27;_, impl Stream, [closure@streams/src/main.rs:22:17: 25:10]&gt;`</span><br><span class="line">   = note: required because of the requirements on the impl of `Unpin` for `tokio_stream::filter::Filter&lt;impl Stream, [closure@streams/src/main.rs:22:17: 25:10]&gt;`</span><br><span class="line">   = note: required because it appears within the type `tokio_stream::map::_::__Origin&lt;&#x27;_, tokio_stream::filter::Filter&lt;impl Stream, [closure@streams/src/main.rs:22:17: 25:10]&gt;, [closure@streams/src/main.rs:26:14: 26:40]&gt;`</span><br><span class="line">   = note: required because of the requirements on the impl of `Unpin` for `tokio_stream::map::Map&lt;tokio_stream::filter::Filter&lt;impl Stream, [closure@streams/src/main.rs:22:17: 25:10]&gt;, [closure@streams/src/main.rs:26:14: 26:40]&gt;`</span><br><span class="line">   = note: required because it appears within the type `tokio_stream::take::_::__Origin&lt;&#x27;_, tokio_stream::map::Map&lt;tokio_stream::filter::Filter&lt;impl Stream, [closure@streams/src/main.rs:22:17: 25:10]&gt;, [closure@streams/src/main.rs:26:14: 26:40]&gt;&gt;`</span><br><span class="line">   = note: required because of the requirements on the impl of `Unpin` for `tokio_stream::take::Take&lt;tokio_stream::map::Map&lt;tokio_stream::filter::Filter&lt;impl Stream, [closure@streams/src/main.rs:22:17: 25:10]&gt;, [closure@streams/src/main.rs:26:14: 26:40]&gt;&gt;`</span><br></pre></td></tr></table></figure>

<p>如果你遇到类似上面这样的错误，请尝试固定该值。</p>
<p>在运行上面的代码之前，先启动Mini-Redis服务端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mini-redis-server</span><br></pre></td></tr></table></figure>

<p>再尝试运行代码，我们就会在STDOUT中看到如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">got = Ok(Message &#123; channel: &quot;numbers&quot;, content: b&quot;1&quot; &#125;)</span><br><span class="line">got = Ok(Message &#123; channel: &quot;numbers&quot;, content: b&quot;two&quot; &#125;)</span><br><span class="line">got = Ok(Message &#123; channel: &quot;numbers&quot;, content: b&quot;3&quot; &#125;)</span><br><span class="line">got = Ok(Message &#123; channel: &quot;numbers&quot;, content: b&quot;four&quot; &#125;)</span><br><span class="line">got = Ok(Message &#123; channel: &quot;numbers&quot;, content: b&quot;five&quot; &#125;)</span><br><span class="line">got = Ok(Message &#123; channel: &quot;numbers&quot;, content: b&quot;6&quot; &#125;)</span><br></pre></td></tr></table></figure>

<p>由于订阅和发布之间存在竞争，一些早期消息可能会被丢弃。该程序永远不会退出，只要服务端保持活动状态，对Mini-Redis频道的订阅就会保持活动状态。</p>
<p>让我们看看如何使用流来扩展这个程序。</p>
<h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><p>接受一个<a target="_blank" rel="noopener" href="https://docs.rs/futures-core/0.3/futures_core/stream/trait.Stream.html"><code>Stream</code></a>并返回另一个<a target="_blank" rel="noopener" href="https://docs.rs/futures-core/0.3/futures_core/stream/trait.Stream.html"><code>Stream</code></a>的函数通常称为“流适配器”，因为这属于“适配器模式”。常见的流适配器包括<a target="_blank" rel="noopener" href="https://docs.rs/tokio-stream/0.1/tokio_stream/trait.StreamExt.html#method.map"><code>map</code></a>、<a target="_blank" rel="noopener" href="https://docs.rs/tokio-stream/0.1/tokio_stream/trait.StreamExt.html#method.take">take</a>和<a target="_blank" rel="noopener" href="https://docs.rs/tokio-stream/0.1/tokio_stream/trait.StreamExt.html#method.filter">filter</a>。</p>
<p>更新Mini-Redis以使其可以退出。我们希望收到三个消息后就停止遍历。这可以使用<a target="_blank" rel="noopener" href="https://docs.rs/tokio-stream/0.1/tokio_stream/trait.StreamExt.html#method.take"><code>take</code></a>完成，此适配器限制流<strong>最多只能</strong>产生<code>n</code>条消息。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> messages = subscriber</span><br><span class="line">    .into_stream()</span><br><span class="line">    .take(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>再次运行程序，输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">got = Ok(Message &#123; channel: &quot;numbers&quot;, content: b&quot;1&quot; &#125;)</span><br><span class="line">got = Ok(Message &#123; channel: &quot;numbers&quot;, content: b&quot;two&quot; &#125;)</span><br><span class="line">got = Ok(Message &#123; channel: &quot;numbers&quot;, content: b&quot;3&quot; &#125;)</span><br></pre></td></tr></table></figure>

<p>而这一次程序执行完毕后退出。</p>
<p>现在，让我们将流中的信息限制为一位数，我们将通过检查消息长度来实现这一点。这次使用<a target="_blank" rel="noopener" href="https://docs.rs/tokio-stream/0.1/tokio_stream/trait.StreamExt.html#method.filter"><code>filter</code></a>适配器，以丢弃任何与此断言不匹配的消息。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> messages = subscriber</span><br><span class="line">    .into_stream()</span><br><span class="line">    .filter(|msg| <span class="keyword">match</span> msg &#123;</span><br><span class="line">        <span class="literal">Ok</span>(msg) <span class="keyword">if</span> msg.content.len() == <span class="number">1</span> =&gt; <span class="literal">true</span>,</span><br><span class="line">        _ =&gt; <span class="literal">false</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    .take(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>再次运行程序，输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">got = Ok(Message &#123; channel: &quot;numbers&quot;, content: b&quot;1&quot; &#125;)</span><br><span class="line">got = Ok(Message &#123; channel: &quot;numbers&quot;, content: b&quot;3&quot; &#125;)</span><br><span class="line">got = Ok(Message &#123; channel: &quot;numbers&quot;, content: b&quot;6&quot; &#125;)</span><br></pre></td></tr></table></figure>

<p>请注意，适配器的应用顺序很重要。先调用<code>filter</code>再调用<code>take</code>与先调用<code>take</code>再调用<code>filter</code>是不同的。</p>
<p>最后，我们将整理输出，即删除输出中的<code>Ok(Message &#123; ... &#125;)</code>部分，这次使用<a target="_blank" rel="noopener" href="https://docs.rs/tokio-stream/0.1/tokio_stream/trait.StreamExt.html#method.map"><code>map</code></a>。因为这是在<code>filter</code><strong>之后</strong>应用的，我们知道消息是<code>Ok</code>，因此可以使用<code>unwrap()</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> messages = subscriber</span><br><span class="line">    .into_stream()</span><br><span class="line">    .filter(|msg| <span class="keyword">match</span> msg &#123;</span><br><span class="line">        <span class="literal">Ok</span>(msg) <span class="keyword">if</span> msg.content.len() == <span class="number">1</span> =&gt; <span class="literal">true</span>,</span><br><span class="line">        _ =&gt; <span class="literal">false</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(|msg| msg.unwrap().content)</span><br><span class="line">    .take(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>此时的输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">got = b&quot;1&quot;</span><br><span class="line">got = b&quot;3&quot;</span><br><span class="line">got = b&quot;6&quot;</span><br></pre></td></tr></table></figure>

<p>另一种选择是使用<a target="_blank" rel="noopener" href="https://docs.rs/tokio-stream/0.1/tokio_stream/trait.StreamExt.html#method.filter_map"><code>filter_map</code></a>将<a target="_blank" rel="noopener" href="https://docs.rs/tokio-stream/0.1/tokio_stream/trait.StreamExt.html#method.filter"><code>filter</code></a>和<a target="_blank" rel="noopener" href="https://docs.rs/tokio-stream/0.1/tokio_stream/trait.StreamExt.html#method.map"><code>map</code></a>合并在一个调用中。</p>
<p>还有更多可用的适配器，请查看<a target="_blank" rel="noopener" href="https://docs.rs/tokio-stream/0.1/tokio_stream/trait.StreamExt.html">此列表</a>。</p>
<h2 id="实现Stream"><a href="#实现Stream" class="headerlink" title="实现Stream"></a>实现<code>Stream</code></h2><p><a target="_blank" rel="noopener" href="https://docs.rs/futures-core/0.3/futures_core/stream/trait.Stream.html"><code>Stream</code></a> trait与<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a> trait非常相似。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"><span class="keyword">use</span> std::task::&#123;Context, Poll&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Stream</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll_next</span></span>(</span><br><span class="line">        <span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, </span><br><span class="line">        cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;</span><br><span class="line">    ) -&gt; Poll&lt;<span class="built_in">Option</span>&lt;Self::Item&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">size_hint</span></span>(&amp;<span class="keyword">self</span>) -&gt; (<span class="built_in">usize</span>, <span class="built_in">Option</span>&lt;<span class="built_in">usize</span>&gt;) &#123;</span><br><span class="line">        (<span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Stream::poll_next()</code>函数很像<code>Future::poll</code>，不同在于你可以重复调用它，以从流中接收许多更多值。正如我们在<a href="./#9-%E6%B7%B1%E5%85%A5%E5%BC%82%E6%AD%A5">深入异步</a>中看到的那样，当流的返回值尚未就绪时，将返回<code>Poll::Pending</code>，此时任务的唤醒器已注册，一旦要再次轮询流，唤醒器就会收到通知。</p>
<p><code>size_hint()</code>方法的使用方式与其在<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch13-02-iterators.html">迭代器</a>上的使用方式相同。</p>
<p>通常，在手动实现<code>Stream</code>时，是通过组合futures和其他流来完成的。作为一个例子，让我们再次以<a href="./#9-%E6%B7%B1%E5%85%A5%E5%BC%82%E6%AD%A5">深入异步</a>中实现的<code>Delay</code> future为基础构建。这次实现为以10毫秒为间隔产生三次<code>()</code>的流。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio_stream::Stream;</span><br><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"><span class="keyword">use</span> std::task::&#123;Context, Poll&#125;;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Interval</span></span> &#123;</span><br><span class="line">    rem: <span class="built_in">usize</span>,</span><br><span class="line">    delay: Delay,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Stream <span class="keyword">for</span> Interval &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = ();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll_next</span></span>(<span class="keyword">mut</span> <span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;)</span><br><span class="line">        -&gt; Poll&lt;<span class="built_in">Option</span>&lt;()&gt;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.rem == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// No more delays</span></span><br><span class="line">            <span class="keyword">return</span> Poll::Ready(<span class="literal">None</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">match</span> Pin::new(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.delay).poll(cx) &#123;</span><br><span class="line">            Poll::Ready(_) =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> when = <span class="keyword">self</span>.delay.when + Duration::from_millis(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">self</span>.delay = Delay &#123; when &#125;;</span><br><span class="line">                <span class="keyword">self</span>.rem -= <span class="number">1</span>;</span><br><span class="line">                Poll::Ready(<span class="literal">Some</span>(()))</span><br><span class="line">            &#125;</span><br><span class="line">            Poll::Pending =&gt; Poll::Pending,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="async-stream"><a href="#async-stream" class="headerlink" title="async-stream"></a><code>async-stream</code></h3><p>使用<a target="_blank" rel="noopener" href="https://docs.rs/futures-core/0.3/futures_core/stream/trait.Stream.html"><code>Stream</code></a>特性手动实现流可能很乏味。然而，Rust尚不支持使用<code>async/await</code>语法定义流，该特性正在实现，只是尚未完成。</p>
<p>可将<a target="_blank" rel="noopener" href="https://docs.rs/async-stream"><code>async-stream</code></a> crate当作临时解决方案。该crate提供了一个<code>stream!</code>宏可以将输入转换为流。使用该crate，上面的interval可以这样实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> async_stream::stream;</span><br><span class="line"><span class="keyword">use</span> std::time::&#123;Duration, Instant&#125;;</span><br><span class="line"></span><br><span class="line">stream! &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> when = Instant::now();</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> delay = Delay &#123; when &#125;;</span><br><span class="line">        delay.<span class="keyword">await</span>;</span><br><span class="line">        <span class="keyword">yield</span> ();</span><br><span class="line">        when += Duration::from_millis(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Rust/">Rust</a><a class="link-muted mr-2" rel="tag" href="/tags/Tokio/">Tokio</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatpay.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/09/24/second-vps-from-us/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">第二个VPS科学球 - 改</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/06/18/pna-rust-project-4/"><span class="level-item">PingCap的Rust训练课程4：并发与并行</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><script src="https://utteranc.es/client.js" repo="zlotus/comment" issue-term="pathname" label="some-issue-label" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/opm_sq.png" alt="子实"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">子实</p><p class="is-size-6 is-block">程序员</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>陕西/西安</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">79</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">23</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zlotus" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com/qinzishi"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/Zealot_uS"><i class="fab fa-twitter"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.zhihu.com/people/zlotus" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Diary/"><span class="level-start"><span class="level-item">Diary</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">65</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Shell/"><span class="level-start"><span class="level-item">Shell</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Coroutines/"><span class="tag">Coroutines</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">31</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenCV/"><span class="tag">OpenCV</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Operating-System/"><span class="tag">Operating System</span><span class="tag">21</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Paper/"><span class="tag">Paper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Raspberry-Pi/"><span class="tag">Raspberry Pi</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag">29</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TensorFlow/"><span class="tag">TensorFlow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tokio/"><span class="tag">Tokio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZMQ/"><span class="tag">ZMQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ctpn/"><span class="tag">ctpn</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/llama/"><span class="tag">llama</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macOS/"><span class="tag">macOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/obsidion/"><span class="tag">obsidion</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%A5%E8%AE%B0/"><span class="tag">日记</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E8%B0%88/"><span class="tag">杂谈</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B/"><span class="tag">编程</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%84%9A%E6%9C%AC/"><span class="tag">脚本</span><span class="tag">4</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a><p class="is-size-7"><span>&copy; 2024 子实</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>