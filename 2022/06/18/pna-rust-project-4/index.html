<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>PingCap的Rust训练课程4：并发与并行 - 子实</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="子实"><meta name="msapplication-TileImage" content="/img/avatar-o.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="子实"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="PingCap的Rust训练课程4：并发与并行"><meta property="og:type" content="article"><meta property="og:title" content="PingCap的Rust训练课程4：并发与并行"><meta property="og:url" content="https://zlotus.github.io/2022/06/18/pna-rust-project-4/"><meta property="og:site_name" content="子实"><meta property="og:description" content="PingCap的Rust训练课程4：并发与并行"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zlotus.github.io/img/og_image.png"><meta property="article:published_time" content="2022-06-18T10:40:00.000Z"><meta property="article:modified_time" content="2022-06-18T10:40:00.000Z"><meta property="article:author" content="子实"><meta property="article:tag" content="Rust"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><meta property="twitter:creator" content="@Zealot_uS"><meta property="twitter:site" content="Zealot_uS"><link rel="publisher" href="+LotusQin"><meta property="fb:admins" content="qinzishi"><meta property="fb:app_id" content="qinzishi"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zlotus.github.io/2022/06/18/pna-rust-project-4/"},"headline":"PingCap的Rust训练课程4：并发与并行","image":["https://zlotus.github.io/img/og_image.png"],"datePublished":"2022-06-18T10:40:00.000Z","dateModified":"2022-06-18T10:40:00.000Z","author":{"@type":"Person","name":"子实"},"publisher":{"@type":"Organization","name":"子实","logo":{"@type":"ImageObject","url":"https://zlotus.github.io/img/opm_sq.png"}},"description":"PingCap的Rust训练课程4：并发与并行"}</script><link rel="icon" href="/img/avatar-o.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/2014/07/09/about-me/">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-06-18T10:40:00.000Z" title="6/18/2022, 6:40:00 PM">2022-06-18</time>发表</span><span class="level-item"><time dateTime="2022-06-18T10:40:00.000Z" title="6/18/2022, 6:40:00 PM">2022-06-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a></span><span class="level-item">2 小时读完 (大约15757个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">PingCap的Rust训练课程4：并发与并行</h1><div class="content"><article class="message message-immersive is-warning">
<div class="message-body">
<i class="fas fa-exclamation-triangle mr-2"></i>本文内容大多翻译自原文：<a target="_blank" rel="noopener" href="https://github.com/pingcap/talent-plan/tree/master/courses/rust/projects/project-4">PNA Rust Project 4: Concurrency and parallelism</a>。
</div>
</article>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>任务</strong>：使用自定义协议，创建一个具有同步网络的<em>多线程</em>、持久化键/值存储的服务端和客户端。</p>
<p><strong>目标</strong>：</p>
<ul>
<li>写一个简单的线程池</li>
<li>使用通道进行跨线程通信</li>
<li>利用锁共享数据结构</li>
<li>无锁执行读操作</li>
<li>对单线程与多线程版本进行基准测试</li>
</ul>
<p><strong>关键词</strong>：线程池、通道、锁、无锁数据结构、原子化、参数化基准测试。</p>
<span id="more"></span>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在这个项目中，您将创建一个使用自定义协议进行通信的简单键/值服务端和客户端。服务端将使用同步网络，并将使用较为复杂的并发实现来响应多个请求。内存索引将改为并发数据结构，由所有线程共享，而压缩操作将在专用的线程上完成，以减少单个请求的延迟。</p>
<h2 id="项目需求规格"><a href="#项目需求规格" class="headerlink" title="项目需求规格"></a>项目需求规格</h2><p>cargo项目<code>kvs</code>建立了一个名为<code>kvs-client</code>的命令行键值存储客户端，和一个名为<code>kvs-server</code>的键值存储服务端，二者又都调用了一个名为<code>kvs</code>的库。客户端通过一个自定义协议与服务端通信。</p>
<p>命令行规格与<a target="_blank" rel="noopener" href="https://github.com/pingcap/talent-plan/blob/master/courses/rust/projects/project-3/README.md">前一个项目</a>相同。本项目与前一个项目的的不同之处在于并发实现，在我们实现时会对其进行描述。</p>
<p>库的规格几乎相同，除了以下两点：一是这一次所有的<code>KvsEngine</code>、<code>KvStore</code>等类型的方法都使用<code>&amp;self</code>而不是<code>&amp;mut self</code>，我们将实现<code>Clone</code> trait，这在并发数据结构中很常见。但为什么呢？其实并不是说我们将不再编写不可变代码，尽管它们将会在线程之间共享。那为什么要在方法签名中避免使用<code>&amp;mut self</code>？也许您现在还不清楚，但在本项目结束时，它会变得显而易见。</p>
<p>二是本项目中的库包含一个新的trait：<code>ThreadPool</code>。它包含以下方法：</p>
<ul>
<li><code>ThreadPool::new(threads: u32) -&gt; Result&lt;ThreadPool&gt;</code><br>创建一个新的线程池，立即生成指定数量的线程。<br>如果未能生成线程，则返回错误。所有先前产生的线程都被结束。</li>
<li><code>ThreadPool::spawn&lt;F&gt;(&amp;self, job: F) where F: FnOnce() + Send + &#39;static</code><br>在线程池中运行一个函数。<br>运行操作总是成功的，但如果函数发生panic，线程池仍将继续以相同数量的线程运行 &mdash; 线程数不会减少，线程池也不会被析构、损坏或失效。</li>
</ul>
<p>到这个项目结束时，该特性将有几个实现，您将再次执行基准测试来比较它们。</p>
<p>本项目完全不需要对客户端代码进行任何修改。</p>
<h2 id="项目设置"><a href="#项目设置" class="headerlink" title="项目设置"></a>项目设置</h2><p>继续上一个项目，删除之前的测试目录，并复制本项目的测试目录。这个项目应该包含一个名为<code>kvs</code>的库，以及两个可执行文件，<code>kvs-server</code>和<code>kvs-client</code>。</p>
<p><code>Cargo.toml</code>中需要以下开发依赖项：</p>
<figure class="highlight toml"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dev-dependencies]</span></span><br><span class="line"><span class="attr">assert_cmd</span> = <span class="string">&quot;0.11&quot;</span></span><br><span class="line"><span class="attr">criterion</span> = <span class="string">&quot;0.2.11&quot;</span></span><br><span class="line"><span class="attr">crossbeam-utils</span> = <span class="string">&quot;0.6.5&quot;</span></span><br><span class="line"><span class="attr">predicates</span> = <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.6.5&quot;</span></span><br><span class="line"><span class="attr">tempfile</span> = <span class="string">&quot;3.0.7&quot;</span></span><br><span class="line"><span class="attr">walkdir</span> = <span class="string">&quot;2.2.7&quot;</span></span><br><span class="line"><span class="attr">panic-control</span> = <span class="string">&quot;0.1.4&quot;</span></span><br></pre></td></tr></table></figure>

<p>与以前的项目一样，添加足够的定义以使测试套件通过编译。</p>
<hr>
<p>添加新模块<code>thread_pool</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── src</span><br><span class="line">   └── thread_pool</span><br><span class="line">      ├── mod.rs</span><br><span class="line">      ├── naive.rs</span><br><span class="line">      ├── rayon.rs</span><br><span class="line">      └── shared_queue.rs</span><br></pre></td></tr></table></figure>

<p>在<code>lib.rs</code>中添加<code>thread_pool</code>模块：</p>
<figure class="highlight rs"><figcaption><span>lib.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> thread_pool;</span><br></pre></td></tr></table></figure>

<p>在<code>mod.rs</code>中声明三种线程池：</p>
<figure class="highlight rs"><figcaption><span>./thread_pool/mod.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! This module provides various thread pools. All thread pools should implement</span></span><br><span class="line"><span class="comment">//! the `ThreadPool` trait.</span></span><br><span class="line"><span class="keyword">use</span> crate::<span class="built_in">Result</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> naive;</span><br><span class="line"><span class="keyword">mod</span> rayon;</span><br><span class="line"><span class="keyword">mod</span> shared_queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::naive::NaiveThreadPool;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::rayon::RayonThreadPool;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::shared_queue::SharedQueueThreadPool;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// The trait that all thread pools should implement.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">ThreadPool</span></span> &#123;</span><br><span class="line">    <span class="comment">/// Creates a new thread pool, immediately spawning the specified number of</span></span><br><span class="line">    <span class="comment">/// threads.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// Returns an error if any thread fails to spawn. All previously-spawned threads</span></span><br><span class="line">    <span class="comment">/// are terminated.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(threads: <span class="built_in">u32</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">Self</span>&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">Self</span>: <span class="built_in">Sized</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Spawns a function into the thread pool.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// Spawning always succeeds, but if the function panics the threadpool continues</span></span><br><span class="line">    <span class="comment">/// to operate with the same number of threads &amp;mdash; the thread count is not</span></span><br><span class="line">    <span class="comment">/// reduced nor is the thread pool destroyed, corrupted or invalidated.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">spawn</span></span>&lt;F&gt;(&amp;<span class="keyword">self</span>, job: F)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="built_in">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三种线程池都用最简单的标准线程做实现，以通过编译。这里以<code>naive.rs</code>为例，其他两个也使用这样的实现即可：</p>
<figure class="highlight rs"><figcaption><span>naive.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> super::ThreadPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::<span class="built_in">Result</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// It is actually not a thread pool. It spawns a new thread every time</span></span><br><span class="line"><span class="comment">/// the `spawn` method is called.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">NaiveThreadPool</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> ThreadPool <span class="keyword">for</span> NaiveThreadPool &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(_threads: <span class="built_in">u32</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">        <span class="literal">Ok</span>(NaiveThreadPool)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">spawn</span></span>&lt;F&gt;(&amp;<span class="keyword">self</span>, job: F)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="built_in">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        thread::spawn(job);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="知识背景：阻塞和多线程"><a href="#知识背景：阻塞和多线程" class="headerlink" title="知识背景：阻塞和多线程"></a>知识背景：阻塞和多线程</h2><p>到目前为止，您已经在单线程上处理了所有请求，包括读取和写入（例如”get”和”set”）。换句话说，数据库中的所有请求都是<em>串行的</em>。使用我们将在这个项目中重复的图表，时间流向如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread</span><br><span class="line">       +  +--------+--------+--------+--------+</span><br><span class="line">  T1   |  |   R1   |   R2   |   W1   |   W2   |</span><br><span class="line">       +  +--------+--------+--------+--------+</span><br><span class="line"></span><br><span class="line">          --&gt; read/write reqs over time --&gt;</span><br></pre></td></tr></table></figure>

<p>读取和写入操作都可能需要阻塞。阻塞是指线程在等待访问资源时停止执行（例如等待访问文件中的数据，或等待访问受锁保护的变量）。当一个线程在一个任务上被阻塞时，便可不能执行另一个任务。因此，在I/O密集型系统中，任何请求可能都在花费大量时间等待操作系统和内存从磁盘读取数据或将数据写入磁盘：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    +---------+----------------------------+---------+</span><br><span class="line">R1  | working | waiting for data ...       | working |</span><br><span class="line">    +---------+----------------------------+---------+</span><br><span class="line"></span><br><span class="line">    --&gt; time --&gt;</span><br></pre></td></tr></table></figure>

<p>The simplest way to put the CPU back to work while one request is blocked is to service requests on multiple threads, so that ideally our requests are all processed concurrently, and — if we have enough CPUs — in parallel:</p>
<p>在一个请求被阻塞时，让CPU能够继续工作的最简单方法，是创建多个线程一起提供服务。因此理想情况下，我们的请求都是并发处理的 &mdash; 如果我们有足够的 CPU &mdash; 即并行处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">thread</span><br><span class="line">       +  +--------+</span><br><span class="line">  T1   |  |   R1   |</span><br><span class="line">       |  +--------+</span><br><span class="line">  T2   |  |   R2   |</span><br><span class="line">       |  +--------+</span><br><span class="line">  T3   |  |   W1   |</span><br><span class="line">       |  +--------+</span><br><span class="line">  T4   |  |   W2   |</span><br><span class="line">       +  +--------+</span><br><span class="line"></span><br><span class="line">          --&gt; read/write reqs over time --&gt;</span><br></pre></td></tr></table></figure>

<p>所以这将是本项目的重点 &mdash; 并行处理请求。</p>
<h2 id="第1部分：多线程"><a href="#第1部分：多线程" class="headerlink" title="第1部分：多线程"></a>第1部分：多线程</h2><p>鉴于我们首次引入并发概念，就用最简单的方法：为每个传入的连接创建一个新线程，并响应该连接上的请求，然后让线程退出。如此，将工作分发到多个线程将提供怎样的性能收益？您预计延迟会受到怎样的影响？吞吐量呢？</p>
<p>第一步是为这种简单方法编写一个<code>ThreadPool</code>实现，其中<code>ThreadPool::spawn</code>将为每个生成的作业创建一个新线程。我们称之为<code>NaiveThreadPool</code>（实际上它甚至不能算是一个<em>真正的</em>线程池，因为这个实现不会在各作业间重用线程，但仍需要符合我们的trait规范以供之后的基准测试比较）。</p>
<p>我们现在不关注更复杂的实现，因为即使将这个简单方法集成到我们现有的设计中仍需要不少努力。请注意，<code>ThreadPool::new</code>构造函数接受一个<code>threads</code>参数，用于指定池中的线程数。在此实现中，该参数将处于未使用状态。</p>
<p><em>现在来实现这个版本的<code>ThreadPool</code>，然后我们将它集成到新的<code>KvStore</code>中。</em></p>
<p>需要通过的测试用例：</p>
<ul>
<li><code>thread_pool::naive_thread_pool_*</code></li>
</ul>
<hr>
<p>经过“项目设置”一节的修改，现在的代码已经能够通过<code>cargo test --test thread_pool</code>的所有测试（实现时再修改）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">running 4 tests</span><br><span class="line"><span class="built_in">test</span> rayon_thread_pool_spawn_counter ... ok</span><br><span class="line"><span class="built_in">test</span> naive_thread_pool_spawn_counter ... ok</span><br><span class="line"><span class="built_in">test</span> shared_queue_thread_pool_spawn_counter ... ok</span><br><span class="line"><span class="built_in">test</span> shared_queue_thread_pool_panic_task ... ok</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished <span class="keyword">in</span> 0.02s</span><br></pre></td></tr></table></figure>

<h2 id="第2部分：创建可共享KvsEngine"><a href="#第2部分：创建可共享KvsEngine" class="headerlink" title="第2部分：创建可共享KvsEngine"></a>第2部分：创建可共享<code>KvsEngine</code></h2><p>在我们将<code>NaiveThreadPool</code>集成到<code>KvsServer</code>之前，我们必须创建<code>KvsEngine</code> trait并实现<code>KvStore</code>（现在您可以忽略上一个项目中的 <code>SledKvsEngine</code>，当然，您可以重新实现它作为这个项目的附加作业）。</p>
<p>回想一下项目需求规格规范，在本项目中，<code>KvsEngine</code>会使用<code>&amp;self</code>作为<code>self</code>，而不是上一个项目中的<code>&amp;mut self</code>。此外，还需要为每个实现，显式编写<code>Clone</code>，并为它们隐式添加<code>Send + &#39;static</code>。具体定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">KvsEngine</span></span>: <span class="built_in">Clone</span> + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">set</span></span>(&amp;<span class="keyword">self</span>, key: <span class="built_in">String</span>, value: <span class="built_in">String</span>) -&gt; <span class="built_in">Result</span>&lt;()&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get</span></span>(&amp;<span class="keyword">self</span>, key: <span class="built_in">String</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">remove</span></span>(&amp;<span class="keyword">self</span>, key: <span class="built_in">String</span>) -&gt; <span class="built_in">Result</span>&lt;()&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个trait签名提供了很代码实现相关的信息。首先想想当我们要使用多线程实现时，为什么需要引擎实现<code>Clone</code>。参考Rust中其他并发数据类型的设计，例如<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a>。再想想为什么需要使用<code>&amp;self</code>，而不是<code>&amp;mut self</code>。您对共享可变状态了解多少？在这个项目结束时，请确保你理解这里的含义 &mdash; <em>这就是我们使用Rust的意义</em>。</p>
<p>在这个模型中，<code>KvsEngine</code>的行为类似于另一个对象的<em>句柄</em>，并且由于该对象需要在线程之间共享，它可能需要保持在<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap">堆</a>上，并且因为该共享状态不能是可变的，它需要由一些同步原语保护。</p>
<p>因此，<em>使用线程安全的共享指针类型将<code>KvsEngine</code>、<code>KvStore</code>中的数据移动到堆上，并将其保护在您选择的锁之后。</em></p>
<p>由于<code>SledKvsEngine</code>实现了<code>KvsEngine</code>，它可能也需要更改。</p>
<p>此时，您的单线程<code>kvs-server</code>应该可以再次工作，但现在有了一个可以在以后跨线程共享的<code>KvsEngine</code>。</p>
<p>需要通过的测试用例：</p>
<ul>
<li><code>kv_store::concurrent_*</code></li>
</ul>
<hr>
<ul>
<li><code>Arc</code>会将内容物放在堆上，并可以使用<code>clone</code>创建指向同一个地址的引用；</li>
<li>之所以修改trait定义之后可以不使用<code>mut</code>引用，是因为实现时将以类似<code>self.writer.lock().unwrap().set(key, value)</code>的方式使用<code>KvsEngine</code>的写操作，而读操作封装在<code>RefCell</code>中即可共享；</li>
<li>将<code>KvStore</code>中的内存索引改为可并发的<code>Arc&lt;SkipMap&lt;...&gt;&gt;</code>方式，并将写对象封装在<code>Arc&lt;Mutex&lt;...&gt;&gt;</code>中，以便在多个线程中执行写操作；</li>
<li>创建一个单线程的<code>KvStoreReader</code>，将日志文件句柄封装在<code>RefCell</code>中以便共享读操作。继续负责从<code>gen</code>日志文件中读取<code>CommandPos</code>处的json数据并解析为<code>Command</code>返回；</li>
<li>创建一个跨线程的<code>KvStoreWriter</code>接管原<code>KvStore</code>中的写日志操作，包括<code>set</code>、<code>remove</code>、<code>compact</code>；</li>
</ul>
<h2 id="第3部分：向KvsServer添加多线程"><a href="#第3部分：向KvsServer添加多线程" class="headerlink" title="第3部分：向KvsServer添加多线程"></a>第3部分：向<code>KvsServer</code>添加多线程</h2><p>让我们在这里快速回顾一下我们的架构：<code>KvsServer</code>设置一个TCP套接字并开始监听；当收到一个请求时，将反序列化并调用<code>KvsEngine</code> trait的一些实现来存储或检索数据；最后返回响应。<code>KvsEngine</code>如何工作的细节与<code>KvsServer</code>无关。</p>
<p>因此，在上一个项目中，您可能模糊地创建了一个循环，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> listener = TcpListener::bind(addr)?;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> stream <span class="keyword">in</span> listener.incoming() &#123;</span><br><span class="line">    <span class="keyword">let</span> cmd = <span class="keyword">self</span>.read_cmd(&amp;stream);</span><br><span class="line">    <span class="keyword">let</span> resp = <span class="keyword">self</span>.process_cmd(cmd);</span><br><span class="line">    <span class="keyword">self</span>.respond(&amp;stream, resp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>现在您只需要做类似的事情，然后把循环内的工作都放在<code>NaiveThreadPool</code>中执行</em>。这会将数据库查询和响应工作放在与TCP监听不同的线程中，从而将大部分繁重的工作转移到其他线程，以允许接收线程处理更多请求。如此便能够增加吞吐量，至少在多核机器上是这样。</p>
<p>于是，您现在仍然有一对有效的客户端/服务端键值存储，只不过现在是多线程的。</p>
<hr>
<ul>
<li>在循环中<code>clone</code> <code>KvsEngine</code>，然后将<code>KvsEngine</code>和<code>ThreadPool</code>一起传给线程执行函数<code>serve</code>；</li>
<li>此时<code>serve</code>由于有了<code>KvsEngine</code>的<code>clone</code>引用，也不需要通过<code>self</code>调用引擎了，因此可以不再当做类函数使用；</li>
<li>在<code>bin/kvs-server.rs</code>中创建服务时需要加上<code>ThreadPool</code>参数，可以在<code>Cargo.toml</code>中引入<code>num_cpus</code>库，以在创建线程池时自动获取主机cpu个数。</li>
</ul>
<h2 id="第4部分：创建真正的线程池"><a href="#第4部分：创建真正的线程池" class="headerlink" title="第4部分：创建真正的线程池"></a>第4部分：创建真正的线程池</h2><p>所以现在你已经有了你的多线程架构，是时候编写一个真正的线程池了。您可能不会在实践中编写自己的线程池，因为可以使用已经过充分测试的线程池crate，不过通过自己编写线程池可以更有效的学习并发相关经验。在本项目接下来的部分中，您将像我们在上一个项目中对引擎所做的那样，抽象线程池，并将您的实现与现有线程池进行性能比较。</p>
<p>那么，什么是线程池？</p>
<p>其实也没什么复杂的。为了不给每个要执行的多线程作业都创建一个新线程，我们选择来维护一“池”的线程，并不停重用这些线程以避免不停的创建新线程。</p>
<p>那么，为什么？</p>
<p>因为可以提高性能。重用线程可以节省出少量性能，而在编写高性能应用程序时，每一点性能都很重要。想象一下创建一个新线程需要什么：</p>
<p>您必须有一个调用栈才能运行该线程，从而必须为该调用栈分配空间。虽然分配空间已然相当简单，但仍不如不分配来的简单。调用栈的分配方式取决于操作系统和运行时的细节，但可能涉及锁和系统调用。同样的，虽然系统调用也很简单，但是当我们处理Rust级别的性能时它们也就算不上简单了 &mdash; 减少系统调用是简单且常见的优化方式。然后必须仔细初始化该栈，以便第一个<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Stack_frame">栈帧</a>包含适当的基指针值以及栈的初始化<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Function_prologue">函数序言</a>中所需的任何其他值。在Rust中，栈需要配置一个<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/Memory/creating-guard-pages">保护页</a>来防止栈溢出，从而保护内存安全。这需要另外两个系统调用，<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/blob/6635fbed4ca8c65822f99e994735bd1877fb063e/src/libstd/sys/unix/thread.rs#L315"><code>mmap</code>和<code>mprotect</code></a>（尽管Linux上避免了这两个系统调用）。</p>
<p>而这只是设置调用栈。创建新线程至少也需要一个系统调用，而内核必须在内部对新线程进行计算。</p>
<p>在Rust中，C库<a target="_blank" rel="noopener" href="https://www.gnu.org/software/hurd/libpthread.html">libpthread</a>库负责处理大多数这种复杂工作。</p>
<p>然后在某个时刻，操作系统在新栈上执行上下文切换，线程运行。当线程终止时，所有工作都需要再次撤消。</p>
<p>当使用线程池时，仅有池里的线程需要初始化开销，后续作业只是简单的上下文切换到池中的线程。</p>
<h3 id="那么如何构建线程池？"><a href="#那么如何构建线程池？" class="headerlink" title="那么如何构建线程池？"></a>那么如何构建线程池？</h3><p>有许多策略和权衡，但对于练习项目，您只需将使用一个共享队列将工作分配给空闲线程即可。这意味着您的“生产者”，即接受网络连接的线程，将作业发送到这个队列（或通道）；而“消费者”，即池中的每个空闲线程，从该队列（通道）读取等待作业执行。这是最简单的工作调度策略，而且可能非常高效。那么，这种方法有什么缺点？</p>
<p>这里有三个重要因素需要考虑：</p>
<ol>
<li><em>使用哪种数据结构来分配工作</em> &mdash; 应是一个队列，且应有一个发送者（“生产者”）负责监听TCP连接，同时应用许多接收者（“消费者”）即池中的线程。</li>
<li><em>如何处理panic的作业</em> &mdash; 线程池将运行任意作业。如果一个线程发生panic，线程池需要以某种方式恢复。</li>
<li><em>如何应对退出</em> &mdash; 即当<code>ThreadPool</code>对象超出作用域时，它需要关闭每个线程，一定不能不管这些线程。</li>
</ol>
<p>这些问题都是相互交织的，因为每一个问题都可能涉及线程间的通信和同步。有些解决方案会很简单，每个问题的解决方案都可以优雅地协同工作；有些解决方案会很复杂，这些问题的解决方案可能相互独立独立且相互交织。仔细选择您的数据结构，聪明的运用这些数据结构的特点。</p>
<p>您将通过在某些并发队列类型上发送消息来分发工作（Rust中的并发队列通常是具有两种连接类型的数据结构：发送者类和接收者类；任何实现了<code>Send</code> + <code>&#39;static</code>的类型都可以在这两个类之间传递）。</p>
<p>Rust中的消息通常表示为枚举类型，每个可能发送的消息都有相应变量，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ThreadPoolMessage</span></span> &#123;</span><br><span class="line">    RunJob(<span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> <span class="built_in">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;),</span><br><span class="line">    Shutdown,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这往往是一种更简单、更有效的解决方案，而不是为了不同目的而试图“兼顾”多个通道。当然，如果只有一种类型的消息，则不需要枚举。现在，上面的示例并不一定是管理线程池所需消息集的全集，这具体取决于设计。比如，如果您的队列返回值表明发送方已被销毁，则通常可以隐式shutdown。</p>
<p>现在有许多种的多线程队列。在Rust中最常见的是<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/sync/mpsc/index.html"><code>mpsc</code></a>通道，就包含在Rust标准库中。这是一个多生产者、单消费者队列，因此将其用于单队列线程池将需要某种锁。在这里使用锁有什么缺点？Rust中还有许多其他并发队列类型，每种都有优缺点。如果您愿意同时锁定生产者和消费者，那么您甚至可以使用<code>Mutex&lt;VecDeque&gt;</code>，不过如果存在更好的解决方案，就没有理由在生产中这么做了。</p>
<p><em>历史趣事：Rust标准库中包含通道这件事有些奇怪，并且被一些人认为是一个错误，因为它背离了Rust的理念 &mdash; 保持最小化标准库、专注抽象操作系统，并让crate生态提供高级数据结构。它们的存在是Rust开发史中刻意为之的，可能来源于Go这样消息传递语言。其他库（例如<a target="_blank" rel="noopener" href="https://github.com/crossbeam-rs/crossbeam"><code>crossbeam</code></a>）提供了更复杂的替代方案，为不同场景提供更合适的选项😉。</em></p>
<p>您的线程池将需要处理作业函数产生panic的情况 &mdash; 放任panic销毁线程可能会使池中的线程快速耗尽。因此，如果池中的某个线程panic，您需要确保线程总数不会减少。那该怎么办？您至少有两个选择：当有线程销毁时立刻新建另一个线程，或者捕获panic并保持现有线程运行。这需要您做出权衡并选择其中一种方式，在您的代码中注释您的选择。</p>
<p>您可能会用到的工具有：<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/thread/fn.spawn.html"><code>thread::spawn</code></a>、<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/thread/fn.panicking.html"><code>thread::panicking</code></a>、<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html"><code>catch_unwind</code></a>、<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/sync/mpsc/index.html"><code>mpsc</code></a>通道、<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>、<a target="_blank" rel="noopener" href="https://docs.rs/crossbeam/0.7.1/crossbeam/channel/index.html">crossbeam的MPMC通道</a>、<code>thread</code>的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/thread/struct.JoinHandle.html"><code>JoinHandle</code></a>。按照您的需求选择合适的工具。</p>
<p><em>创建<code>SharedQueueThreadPool</code>类，实现<code>ThreadPool</code>。</em></p>
<p>需要完成的测试用例：</p>
<ul>
<li><code>shared_queue_thread_pool_*</code></li>
</ul>
<p>将<code>KvsServer</code>中用到的<code>NaiveThreadPool</code>替换为<code>SharedQueueThreadPool</code>。同样，您的<code>kvs-server</code>应该仍然像以前一样工作，只不过这次的多线程模型更高效一些。您应当使用恰当的数量构造线程池，这里推荐使用<code>num_cpus</code> crate，以为每个CPU创建一个线程。稍后我们将再次讨论线程个数。</p>
<hr>
<ul>
<li>利用<code>crossbeam::channel</code>创建一对<code>tx</code>/<code>rx</code>（发送者/接收者），<code>tx</code>用于在线程池的<code>spawn</code>中向<code>channel</code>发送作业，<code>rx</code>负责接收并执行这些作业；</li>
<li>我们目前的策略为放任线程panic，并立刻创建新线程。要实现这一策略需要将<code>rx</code>封装在新类<code>TaskReceiver</code>中，然后控制该类的<code>Drop</code>行为，当发生<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/thread/fn.panicking.html"><code>thread::panicking()</code></a>时，克隆本<code>TaskReceiver</code>实例并放入新建的线程中以继续接收新的作业；</li>
<li>线程的执行函数，只需使用<code>loop</code>持续等待作业并执行作业中的函数即可。</li>
</ul>
<figure class="highlight rust"><figcaption><span>thread_pool/shared_queue.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> crossbeam::channel::&#123;<span class="keyword">self</span>, Sender, Receiver&#125;;</span><br><span class="line"><span class="keyword">use</span> log::&#123;debug, error&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> super::ThreadPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::<span class="built_in">Result</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note for Rust training course: the thread pool is not implemented using</span></span><br><span class="line"><span class="comment">// `catch_unwind` because it would require the task to be `UnwindSafe`.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// A thread pool using a shared queue inside.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// If a spawned task panics, the old thread will be destroyed and a new one will be</span></span><br><span class="line"><span class="comment">/// created. It fails silently when any failure to create the thread at the OS level</span></span><br><span class="line"><span class="comment">/// is captured after the thread pool is created. So, the thread number in the pool</span></span><br><span class="line"><span class="comment">/// can decrease to zero, then spawning a task to the thread pool will panic.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">SharedQueueThreadPool</span></span> &#123;</span><br><span class="line">    tx: Sender&lt;<span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> <span class="built_in">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;&gt;, </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> ThreadPool <span class="keyword">for</span> SharedQueueThreadPool &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(threads: <span class="built_in">u32</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> (tx, rx) = channel::unbounded::&lt;<span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> <span class="built_in">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..threads &#123;</span><br><span class="line">            <span class="keyword">let</span> rx = TaskReceiver(rx.clone());</span><br><span class="line">            thread::Builder::new().spawn(|| run_task(rx))?;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">Ok</span>(SharedQueueThreadPool &#123; tx &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Spawns a function into the thread pool.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// # Panics</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// Panics if the thread pool has no thread.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">spawn</span></span>&lt;F&gt;(&amp;<span class="keyword">self</span>, job: F)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="built_in">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.tx</span><br><span class="line">            .send(<span class="built_in">Box</span>::new(job))</span><br><span class="line">            .expect(<span class="string">&quot;The thread pool has no thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TaskReceiver</span></span>(Receiver&lt;<span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> <span class="built_in">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> TaskReceiver &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> thread::panicking() &#123;</span><br><span class="line">            <span class="keyword">let</span> rx = <span class="keyword">self</span>.clone();</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Err</span>(e) = thread::Builder::new().spawn(<span class="keyword">move</span> || run_task(rx)) &#123;</span><br><span class="line">                error!(<span class="string">&quot;Failed to spawn a thread: &#123;&#125;&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">run_task</span></span>(rx: TaskReceiver) &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> rx.<span class="number">0</span>.recv() &#123;</span><br><span class="line">            <span class="literal">Ok</span>(task) =&gt; &#123;</span><br><span class="line">                task();</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="literal">Err</span>(_) =&gt; debug!(<span class="string">&quot;Thread exits because the thread pool destoryed. &quot;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第5部分：抽象线程池"><a href="#第5部分：抽象线程池" class="headerlink" title="第5部分：抽象线程池"></a>第5部分：抽象线程池</h2><p>与在之前的项目中抽象出<code>KvsEngine</code>来比较不同的实现一样，现在您应抽象出<code>ThreadPool</code>来做类似的事。</p>
<p>如果您还没有这么做，请向<code>KvsServer</code>添加第二个类型参数以表示<code>ThreadPool</code>实现，构造函数以线程池作为第二个参数，并使用该线程池来分发作业。</p>
<p>最后，使用<a target="_blank" rel="noopener" href="https://docs.rs/rayon/"><code>rayon</code></a> crate中的<code>ThreadPool</code>创建另一个<code>ThreadPool</code>，以实现<code>RayonThreadPool</code>。</p>
<p><code>Rayon</code>的线程池使用一种称为“<a target="_blank" rel="noopener" href="https://www.dre.vanderbilt.edu/~schmidt/PDF/work-stealing-dequeue.pdf">工作窃取</a>”的更复杂的调度策略，预计它的性能会比我们的实现更好，不过在我们尝试之前谁知道呢！</p>
<figure class="highlight rust"><figcaption><span>thread_pool/rayon.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> super::ThreadPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::&#123;<span class="built_in">Result</span>, KvsError&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Wrapper of rayon::ThreadPool</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">RayonThreadPool</span></span>&#123;</span><br><span class="line">    pool: rayon::ThreadPool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> ThreadPool <span class="keyword">for</span> RayonThreadPool &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(threads: <span class="built_in">u32</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> pool = rayon::ThreadPoolBuilder::new()</span><br><span class="line">            .num_threads(threads <span class="keyword">as</span> <span class="built_in">usize</span>)</span><br><span class="line">            .build()</span><br><span class="line">            .map_err(|e| KvsError::StringError(<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, e)))?;</span><br><span class="line">        <span class="literal">Ok</span>(RayonThreadPool&#123;pool&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">spawn</span></span>&lt;F&gt;(&amp;<span class="keyword">self</span>, job: F)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="built_in">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.pool.spawn(job)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第6部分：评估您的线程池"><a href="#第6部分：评估您的线程池" class="headerlink" title="第6部分：评估您的线程池"></a>第6部分：评估您的线程池</h2><p>现在您将编写<em>6</em>个基准测试，一个写入繁重的工作负载比较<code>SharedQueueThreadPool</code>在不同线程数下的性能，一个读取繁重的工作负载比较<code>SharedQueueThreadPool</code>在不同线程数下的性能；再写两个测试，类似前面两个只不过用来测试<code>RayonThreadPool</code>；最后还有两个将<code>RayonThreadPool</code>与<code>SledKvsEngine</code>结合使用。</p>
<p>看上去要写6个其实并没有那么多 &mdash; 因为后四个基本上是复制前两个。</p>
<p><em>注意：接下来的两节描述了一组相当复杂的基准测试。它们确实可以实现出来（可能……还没有人写过），但有效理解和高效编写都比较难。两节确实介绍了一些有用的<code>criterion</code>特性，但如果对你来说内容过于庞杂，可以选择跳过（也可以告诉我们有哪些内容不适合你）。不过，这里的困难可能是一个很好的学习机会。最后，实现这些基准测试需要实现以编程方式关闭<code>KvsServer</code>的方法（即不发送<code>SIGKILL</code>并让操作系统执行退出），我们之前还没有讨论过。</em></p>
<p>其中一部分工作就是让将前一个项目中的<code>SledKvsEngine</code>在本项目的多线程环境中再次工作。这应该不难，因为<code>sled</code>可以被克隆并在线程间发送，就像您编写的引擎一样。</p>
<p>希望结果会很有趣。</p>
<p>您将再次使用<code>criterion</code>。</p>
<p>这些将是<em>参数化</em>基准测试，即使用不同参数多次运行的单个测试，而<code>criterion</code>支持<a target="_blank" rel="noopener" href="https://bheisler.github.io/criterion.rs/book/user_guide/benchmarking_with_inputs.html">使用参数作为基准测试的输入</a>。这里的基准测试参数将是线程池中的线程数。</p>
<p>您将尝试测试服务器在各种条件下的吞吐量。您将同时发送许多请求，等待响应，然后结束。您可能会好奇，服务器CPU数量与线程总数的关系，是如何影响吞吐量的；您的线程池与<code>rayon</code>相比性能如何；以及在多线程环境下您的<code>KvStore</code>与<code>SledKvsEngine</code>的比较。</p>
<p>由于您的<code>KvsClient</code>（可能会）被阻塞，即请求后等待响应，这会使测试变的复杂。如果是非阻塞的，那么您可以发送许多请求而无需等待响应，然后再收集响应。而使用阻塞的<code>KvsClient</code>，您将需要在独立的线程中发送每个请求，以使服务饱和。</p>
<p>在进行基准测试时，一定要清楚您希望评估哪些代码，并尽可能只去测试那一部分代码。像<code>criterion</code>这样的基准测试库在一个循环中多次运行一段代码，测量它通过每个循环所花费的时间。因此，应当只将您想要评估的代码放入循环中，并将无关代码尽可能的留在循环外。</p>
<p>因此，以这个带有输入的简单<code>criterion</code>为例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = Criterion::default();</span><br><span class="line"><span class="keyword">let</span> inputs = &amp;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">c.bench_function_over_inputs(<span class="string">&quot;example&quot;</span>, |b, &amp;&amp;num| &#123;</span><br><span class="line">    b.iter(|| &#123;</span><br><span class="line">        <span class="comment">// important measured work goes here</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, inputs);</span><br></pre></td></tr></table></figure>

<p><code>iter</code>多次调用您的闭包，测量每次迭代。但是如此就需要事先设置大量线程，您并不希望这么做。如果只需要设置一次，就能够在多次迭代中使用，则应该将设置过程放在闭包之外，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = Criterion::default();</span><br><span class="line"><span class="keyword">let</span> inputs = &amp;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">c.bench_function_over_inputs(<span class="string">&quot;example&quot;</span>, |b, &amp;&amp;num| &#123;</span><br><span class="line">    <span class="comment">// do setup here</span></span><br><span class="line">    b.iter(|| &#123;</span><br><span class="line">        <span class="comment">// important measured work goes here</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, inputs);</span><br></pre></td></tr></table></figure>

<p>只评估<code>b.iter</code>闭包中的代码，其余的环境设置代码都放在前面。</p>
<p>如果设置无法放在循环之前，那么另一种策略是使设置占用的工作量小于想要评估的代码的工作量，例如添加循环。也要考虑基准测试中的“析构”部分，通常指运行<code>drop</code>的成本。</p>
<p>如果您有一个阻塞客户端，则客户端将需要许多线程，而在执行循环之前，您只有一次机会创建这些线程。因此，在基准测试执行迭代前，您需要设置一堆可复用的线程。幸运的是，<code>SharedQueueThreadPool</code>就是一个很好的工具。为每个请求设置一个线程，并将其与某个通道配对，以报告收到响应，这就成了一个合适的基准测试工具。</p>
<h3 id="现在开始编写前两个基准测试"><a href="#现在开始编写前两个基准测试" class="headerlink" title="现在开始编写前两个基准测试"></a>现在开始编写前两个基准测试</h3><p>前面提到这是一个参数化基准测试，参数就是服务器线程池中要使用的CPU核数。我们想看看只有1个、2个、4个等每个偶数一直到CPU核数的2倍时，吞吐量都是什么表现。至于为什么是2倍，也许拥有比内核更多的线程可能会有好处，您将通过实验来发现。</p>
<p>对于密集写入的作业，在环境设置期间（即调用<code>b.iter(...)</code>之前）先创建<code>KvsServer&lt;KvStore, SharedQueueThreadPool&gt;</code>，线程池使用参数化的线程数。然后编写一个作业，为1000个等长的键设置相同的值。请注意，尽管键不同，但为了测试结果的一致性，应在每个循环中使用同一套键。</p>
<p>然后在每次线程写入键和值后，也应该<code>assert!</code>调用成功（以确保作业执行中没有出错），从而表明作业成功完成。当所有线程都完成后，基准测试线程继续运行并结束迭代。实现这种信号式结束的最直观方法是让每个作业线程将消息发送回基准测试线程，但请记住，这些信号代码是与您希望评估的代码毫无关系的开销，因此它的工作量应尽可能少。您可以只使用一条消息，或者使用其他并发类型，仅向基准测试线程发出一次信号吗？</p>
<p>将此基准测试命名为<code>write_queued_kvstore</code>（或其他）。</p>
<p>对于密集读取作业，在环境设置期间先创建<code>KvServer&lt;KvStore, SharedQueueThreadPool&gt;</code>，线程池使用参数化的线程数。然后编写保护1000个线程的客户端线程池。仍然在环境设置阶段，创建另一个客户端并初始化1000个不同的等长键，并全部使用相同的值。</p>
<p>然后，在基准测试循环中，为客户端生成1000个检索相同键/值解析的作业，然后<code>assert!</code>结果是正确的。最后，像以前一样，向基准测试线程发送一条消息，表示读取已完成。</p>
<p>将此基准测试命名为<code>read_queued_kvstore</code>（或其他）。</p>
<p><strong>的确有不少工作要做。</strong></p>
<p>您可以像往常一样使用<code>cargo bench</code>运行这组<code>criterion</code>基准测试。</p>
<p>只不过这次您有更多工作要完成。由于您将要在多个参数上执行相同的基准测试，即以线程池中的线程数为参数，如果能将这些结果体现在一个漂亮的图表中，以看到不同线程数的影响，将会使测试结果更加直观。</p>
<p>恰好<code>criterion</code>就有这个功能！</p>
<p>请再次并阅读有关<a target="_blank" rel="noopener" href="https://bheisler.github.io/criterion.rs/book/user_guide/benchmarking_with_inputs.html">使用参数作为基准测试的输入</a>的内容。文章解释了如何制作输入的基准测试图标。您注意到了什么？当您的线程数接近服务器CPU核数时会发生什么？当线程数超过服务器的线程数时会发生什么？您认为是什么导致了测试结果中的趋势？结果取决于许多因素，因此您的结果可能与其他任何人都不同。</p>
<p>这是始终进行基准测试而不非推测性能的一个很好的理由。我们可以做出有根据的猜测，但直到我们测试才会知道结果。</p>
<h2 id="第7部分：评估其他线程池和引擎"><a href="#第7部分：评估其他线程池和引擎" class="headerlink" title="第7部分：评估其他线程池和引擎"></a>第7部分：评估其他线程池和引擎</h2><p>到这里，您已经解决了基准测试练习中最困难的部分。现在您只需在之前的基础上做更多配置性工作即可。</p>
<p>拿您之前写的那两个基准，然后复制粘贴三遍。将这些副本中的<code>SharedQueueThreadPool</code>更改为<code>RayonThreadPool</code>。</p>
<p>将第三个和第四个命名为<code>read/write_rayon_kvstore</code>（或其他）。这两个将与前两个<code>SharedQueueThreadPool</code>实现进行比较，以了解您的实现与<code>RayonThreadPool</code>之间的区别。</p>
<p>第五个和第六个，命名为<code>read/write_rayon_sledkvengine</code>，将引擎改成<code>SledKvsEngine</code>。这些您将与前两个进行比较，以了解您的<code>KvsEngine</code>与多线程环境中的<code>sled</code>有什么区别。</p>
<p>和以前一样，运行并绘制所有这些基准测试。如上所述将它们相互比较，在各种线程数下，您的调度与<code>rayon</code>相比如何？在各种线程数下，您的存储引擎与<code>sled</code>相比如何？结果令人惊讶吗？你能想象为什么存在差异吗？</p>
<h3 id="扩展1：比较函数"><a href="#扩展1：比较函数" class="headerlink" title="扩展1：比较函数"></a>扩展1：比较函数</h3><p>现在，您为三个不同的线程池执行了相同的基准测试，您运行了也比较了它们的性能。<code>criterion</code>内置支持比较多个实现。查看Criterion用户手册中的“<a target="_blank" rel="noopener" href="https://bheisler.github.io/criterion.rs/book/user_guide/comparing_functions.html">比较函数</a>”并修改您的基准测试，以便让<code>criterion</code>自己进行比较，看看那些华丽的图表。</p>
<h3 id="背景：锁的极限"><a href="#背景：锁的极限" class="headerlink" title="背景：锁的极限"></a>背景：锁的极限</h3><p>在本项目前期，我们建议通过将<code>KvsEngine</code>内部数据放在堆上并保护在锁之后来保证其线程安全。您可能立即意识到这不会提高吞吐量，因为它只是将一种阻塞换成了另一种阻塞 &mdash; 将原来的阻塞磁盘访问换成了现在的阻塞互斥访问。</p>
<p>所以到目前为止，我们所取得的成就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">thread</span><br><span class="line">       +  +--------+</span><br><span class="line">  T1   |  |   R1   |</span><br><span class="line">       |  +-----------------+</span><br><span class="line">  T2   |           |   R2   |</span><br><span class="line">       |           +-----------------+</span><br><span class="line">  T3   |                    |   W1   |</span><br><span class="line">       |                    +-----------------+</span><br><span class="line">  T4   |                             |   W2   |</span><br><span class="line">       +                             +--------+</span><br><span class="line">          --&gt; read/write reqs over time --&gt;</span><br></pre></td></tr></table></figure>

<p>在上一节中，您对您的引擎与<code>SledKvsEngine</code>的多线程吞吐量进行了基准测试。希望您已经发现，您的多线程实现比<code>sled</code>的性能要差得多（如果不是，要么是您的实现非常棒，要么是<code>sled</code>出了什么问题）。到目前为止，添加多线程导致的性能比单线程实现更差 &mdash; 现在您的实现还需要执行线程间上下文切换的额外工作，以及为了保证互斥锁而强加的阻塞。</p>
<p>因此，对于项目的这一部分将变得更加复杂。用锁保护整个状态很容易 &mdash; 整个状态总是以原子方式读写，于是一次只有一个客户端可以访问整个状态。但这也意味着想要访问共享状态的两个线程必须互相等待。换句话说，当<code>KvsEngine</code>受互斥锁保护时，尽管是多线程的，但服务器中的实际并发量非常少。</p>
<p>高性能、可扩展、并行的软件倾向于尽可能避免锁和锁争用。与大多数语言相比，Rust使复杂且高性能的并发模式变的更容易（因为您无需担心数据竞争和程序崩溃），但它并不能阻止您写出可能导致错误程序行为的逻辑bug。</p>
<p>所以你仍然需要对并发进行一些认真的思考。幸运的是，Rust crate生态中有许多复杂的并行编程工具，因此您的任务通常只是了解它们是什么以及如何将它们组合在一起，而不是了解如何编写自己的复杂无锁数据结构。</p>
<p>让我们看一些更复杂的例子。我们将以单线程<code>KvStore</code>为例，并考虑如何将其改为线程安全的。</p>
<p>这是一个单线程<code>KvStore</code>示例，就像您在早期项目中创编写的那样（这是课程示例项目中的简化版本）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">KvStore</span></span> &#123;</span><br><span class="line">    <span class="comment">/// Directory for the log and other data</span></span><br><span class="line">    path: PathBuf,</span><br><span class="line">    <span class="comment">/// The log reader</span></span><br><span class="line">    reader: BufReaderWithPos&lt;File&gt;,</span><br><span class="line">    <span class="comment">/// The log writer</span></span><br><span class="line">    writer: BufWriterWithPos&lt;File&gt;,</span><br><span class="line">    <span class="comment">/// The in-memory index from key to log pointer</span></span><br><span class="line">    index: BTreeMap&lt;<span class="built_in">String</span>, CommandPos&gt;,</span><br><span class="line">    <span class="comment">/// The number of bytes representing &quot;stale&quot; commands that could be</span></span><br><span class="line">    <span class="comment">/// deleted during a compaction</span></span><br><span class="line">    uncompacted: <span class="built_in">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这是简单的多线程版本，用锁保护一切。希望您的实现看起来已经类似这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">KvStore</span></span>(Arc&lt;Mutex&lt;SharedKvStore&gt;&gt;);</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">SharedKvStore</span></span> &#123;</span><br><span class="line">    <span class="comment">/// Directory for the log and other data</span></span><br><span class="line">    path: PathBuf,</span><br><span class="line">    <span class="comment">/// The log reader</span></span><br><span class="line">    reader: BufReaderWithPos&lt;File&gt;,</span><br><span class="line">    <span class="comment">/// The log writer</span></span><br><span class="line">    writer: BufWriterWithPos&lt;File&gt;,</span><br><span class="line">    <span class="comment">/// The in-memory index from key to log pointer</span></span><br><span class="line">    index: BTreeMap&lt;<span class="built_in">String</span>, CommandPos&gt;,</span><br><span class="line">    <span class="comment">/// The number of bytes representing &quot;stale&quot; commands that could be</span></span><br><span class="line">    <span class="comment">/// deleted during a compaction</span></span><br><span class="line">    uncompacted: <span class="built_in">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>的解决方案，简单、正确且常见：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a>将值放在堆上，以便它可以在线程之间共享，并提供一个<code>clone</code>方法来为每个线程创建一个“句柄”；</li>
<li><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>提供了一种在不使用<code>&amp;mut</code>引用的情况下，获得该值的写访问权限的方法。</li>
</ul>
<p>对于许多情况，这是一个完全合理的解决方案。但在本项目中，互斥锁将成为锁争用的源头：互斥锁不仅会串行化<code>SharedKvStore</code>的写访问，还会串行化读访问。任何想要使用<code>KvStore</code>的线程都需要等待<code>Mutex</code>被另一个线程解锁。所有请求都会阻塞任何其他并发请求。</p>
<p>我们真正想要的是不必使用锁，或者 &mdash; 如果确实需要锁的 &mdash; 它们尽量少的与其他线程竞争。</p>
<p>互斥锁的进阶是<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock</code></a>，即“读写锁”。这是每个并行软件开发者都必须知道的另一种常见锁。读写锁对互斥体的改进是它允许任意数量的读取，或单个写入。即用Rust术语，<code>RwLock</code>可以同时支持任意数量的<code>&amp;</code>引用，或单个<code>&amp;mut</code>引用。读会被写阻塞，写会阻塞其他所有读和写。</p>
<p>在我们的数据库中，这意味着可以同时满足所有读取请求，但是当单个写入请求进入时，系统中的所有其他活动都会停止并等待该写操作完成。实现这一点很简单，基本上就是将<code>Mutex</code>换成<code>RwLock</code>。</p>
<p>现在，再次考虑我们的多线程示意图，最终的处理流程如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">thread</span><br><span class="line">       +  +--------+</span><br><span class="line">  T1   |  |   R1   |</span><br><span class="line">       |  +--------+</span><br><span class="line">  T2   |  |   R2   |</span><br><span class="line">       |  +-----------------+</span><br><span class="line">  T3   |           |   W1   |</span><br><span class="line">       |           +-----------------+</span><br><span class="line">  T4   |                    |   W2   |</span><br><span class="line">       +                    +--------+</span><br><span class="line">          --&gt; read/write reqs over time --&gt;</span><br></pre></td></tr></table></figure>

<h2 id="第8部分：无锁读"><a href="#第8部分：无锁读" class="headerlink" title="第8部分：无锁读"></a>第8部分：无锁读</h2><p>对于本项目，我们想要尝试去创建永远不会锁定的读取器，即发生并发写入也依然不会阻塞读取。无论写入请求如何，都可以始终为读取请求提供服务。（写如现在仍然会阻塞其他写操作 &mdash; 除了成为一项具有挑战性的并行编程问题，并行写入本身是否有意义仍是一个难以回答的问题）。</p>
<p>我们最终的期望是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">thread</span><br><span class="line">       +  +--------+</span><br><span class="line">  T1   |  |   R1   |</span><br><span class="line">       |  +--------+</span><br><span class="line">  T2   |  |   R2   |</span><br><span class="line">       |  +--------+</span><br><span class="line">  T3   |  |   W1   |</span><br><span class="line">       |  +-----------------+</span><br><span class="line">  T4   |           |   W2   |</span><br><span class="line">       +           +--------+</span><br><span class="line">          --&gt; read/write reqs over time --&gt;</span><br></pre></td></tr></table></figure>

<p>如果能做到这一点，那么我们将实现无锁的读操作：即使有读操作在等待来自文件系统的数据（被阻塞），所有类型的其他操作（读和写）都可以继续进行。不过，这仍然不足以保证系统始终可以为读请求提供服务。想想如果在大小为<code>N</code>的线程池上存在<code>N</code>个阻塞的写请求会发生什么。稍后你需要考虑这个问题，但现在，您的重点是从读操作中移除锁。</p>
<p>与<code>Mutex</code>和<code>RwLock</code>不同，并没有一种封装类型可以应用于整个任意共享状态，以实现同时读取和写入的目标（至少不能同时还具有高性能）。</p>
<p>这意味着我们需要考虑如何使用<code>SharedKvStore</code>的每个字段，选择正确的同步方案以允许执行尽可能多的线程，并能够继续保持数据的逻辑一致性。</p>
<p>这就是多线程真正困难的地方。如果你移除那个大锁，Rust仍然会保护您免受<a target="_blank" rel="noopener" href="https://blog.regehr.org/archives/490">数据竞争</a>的影响，但它并不能帮助您保持数据的逻辑一致性。</p>
<p>所以在考虑解决方案之前，让我们考虑一下我们的需求。我们要：</p>
<ul>
<li>同时在多个线程上读取内存索引和磁盘日志；</li>
<li>将命令写入磁盘，同时维护内存索引；</li>
<li>读与写并行，因此：</li>
<li>一般来说，为了保证读与写并发时总是能够读到一致的状态，这意味着：<ul>
<li>维护一个不变量，使其实在指向日志中的一个有效命令；</li>
<li>维护一些适当的不变量以供其他的记录行为使用，比如为了下例<code>uncompacted</code>的记录；</li>
</ul>
</li>
<li>定期压缩磁盘数据，同时为读操作维护不变量；</li>
</ul>
<p>本节的其余部分是对有助于实现上述目标的各种背景知识的介绍，也这是项目的最终目标：修改<code>KvStore</code>以同时执行读取和写入。</p>
<h3 id="示例数据结构的解释"><a href="#示例数据结构的解释" class="headerlink" title="示例数据结构的解释"></a>示例数据结构的解释</h3><p>为了更具体的讨论，我们将需要一个示例，以展示应受保护的数据和应被维护的不变量。下面是一个<code>KvStore</code>实现及其字段的示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">KvStore</span></span> &#123;</span><br><span class="line">    <span class="comment">/// Directory for the log and other data</span></span><br><span class="line">    path: PathBuf,</span><br><span class="line">    <span class="comment">/// The log reader</span></span><br><span class="line">    reader: BufReaderWithPos&lt;File&gt;,</span><br><span class="line">    <span class="comment">/// The log writer</span></span><br><span class="line">    writer: BufWriterWithPos&lt;File&gt;,</span><br><span class="line">    <span class="comment">/// The in-memory index from key to log pointer</span></span><br><span class="line">    index: BTreeMap&lt;<span class="built_in">String</span>, CommandPos&gt;,</span><br><span class="line">    <span class="comment">/// The number of bytes representing &quot;stale&quot; commands that could be</span></span><br><span class="line">    <span class="comment">/// deleted during a compaction</span></span><br><span class="line">    uncompacted: <span class="built_in">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是本项目示例的简化版本。</p>
<p>各字段的作用非常明确：</p>
<p><code>path</code>：<code>PathBuf</code>只是日志的目录路径，永远不会改变 &mdash; 它是不可变的，不可变的类型在Rust中是同步的，所以它甚至根本不需要任何保护。它可以被任何线程通过共享引用同时读取。</p>
<p><code>reader</code>：<code>HashMap&lt;u64, BufReaderWithPos&lt;File&gt;&gt;</code>是当前日志文件的读句柄。它是可变的，即压缩后会指向新的日志文件。</p>
<p><code>writer</code>：<code>BufWriterWithPos&lt;File&gt;</code>是当前日志文件的写句柄。任何写入都需要对<code>writer</code>的可变访问，并且压缩过程需要修改<code>writer</code>和<code>current_gen</code>。</p>
<p><code>index</code>：<code>BTreeMap&lt;String, CommandPos&gt;</code>是数据库中每个键到其所在日志文件中具体位置的内存索引。它从可以从每个读线程读取，从每个写线程写入，即使在压缩期间也能正常访问。</p>
<p><code>uncompacted</code>：<code>u64</code>仅用于计算日志中已被后续写入命令取代的“陈旧”命令的总长度，用以触发日志压缩操作。</p>
<p>在以前的项目中，我们不必担心写、读和压缩之间的交叉会产生不一致的结果，因为它们都发生在同一个线程上。现在，如果您对数据结构的选择和使用不够小心，很容易破坏数据库的状态。</p>
<h3 id="消除锁的策略"><a href="#消除锁的策略" class="headerlink" title="消除锁的策略"></a>消除锁的策略</h3><p>高级并行编程的关键是了解可用的工具以及使用它们的时机。以下是我们在实施此项目时发现的一些有用的技术，其中一些您也将用到。这些技术将以上面的数据结构为例进行讲解。</p>
<h4 id="理解并维护顺序一致性"><a href="#理解并维护顺序一致性" class="headerlink" title="理解并维护顺序一致性"></a>理解并维护顺序一致性</h4><p>（请注意，“顺序一致性”一词有其准确含义，但在这里我们只是概括性地讨论如何确保以特定顺序执行作业）。</p>
<p>理解并行编程的关键在于理解代码各部分的“执行顺序”间的关系。在这个线程中，要让本线程早于其他线程看到数据，共享数据结构需要怎样改动？要让本线程早于其他线程暴露内部数据，共享数据结构需要怎样改动？我如何保证执行结果？</p>
<p>在单线程代码中，推断出任意行代码之前发生了什么很简单 &mdash; 如果代码写在前面，则会在前面执行，反之则会在后面执行。但这实际上并不是这样，即使在单线程代码中：为了使代码更高效的运行，CPU和编译器都会重新组织代码执行的顺序，只不过CPU使用器机码，编译器使用用以生成机器码的内部编码。实际上的代码执行顺序跟您编写代码的顺序并不相同，代码只是看起来在按您编写的顺序运行，因为CPU和编译器都会跟踪<em>数据依赖</em>，它们并不会打乱依赖顺序重新排列操作。</p>
<p>在多线程代码中，CPU和编译器<em>仍</em>使用与单线程相同的条件重新排序代码，而且您的代码块会被打碎重排，除非您使用同步类型和操作告诉编译器不允许重新排序。</p>
<p>任何必须在特定操作之前或之后发生的操作，都必须显式使用同步类型或操作，如使用锁、原子类型等等。</p>
<p>在上面的例子中，文件写入和内存索引写入显然应以特定的顺序发生 &mdash; 如果索引在文件更新前更新会发生什么？另外，例子中包含另一个状态，即未压缩命令的总长度<code>uncompacted</code>。错误的计算未压缩命令的长度将产生什么影响？如果在将数据写入文件之前就可以看到<code>uncompacted</code>发生了变化可能还好，但是必须为每个这样的独立同步值制定策略。</p>
<h4 id="确定不可变值"><a href="#确定不可变值" class="headerlink" title="确定不可变值"></a>确定不可变值</h4><p>你可能已经了解了很多关于Rust中的不可变性，以及不可变值如何轻松的在线程间共享（它们具有<code>Sync</code> trait）。不可变值最适合并发 &mdash; 只需将它们放在<code>Arc</code>后面即可。</p>
<p>在本例中，<code>PathBuf</code>是不可变的。</p>
<h4 id="复制值而不是复制共享"><a href="#复制值而不是复制共享" class="headerlink" title="复制值而不是复制共享"></a>复制值而不是复制共享</h4><p>在Rust中我们可能不太喜欢克隆，特别是克隆大小不确定的类型，如<code>String</code>和<code>Vec</code>。但是克隆的存在是完全合理的：在某些情况下避免克隆可能非常困难，而且CPU也非常擅长复制内存缓冲区。此外，在本例中，服务端所需的状态副本的数量，实际上受线程池中线程数量的限制。</p>
<p>在本例中，<code>PathBuf</code>也很容易克隆。</p>
<p>考虑一个潜在问题，如何跨线程共享对文件的访问。<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/fs/struct.File.html"><code>File</code></a>类型对读和写操作均需要可变访问。因此，其跨线程共享需要使用锁以授权可变访问。那么，什么是文件？它并不是一份实际上的文件 &mdash; 而只是磁盘上物理资源的句柄，一个文件同时存在多个打开句柄是可以的。注意<code>File</code>的API &mdash; 并没有实现<code>Clone</code>，虽然它确实有个诱人的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/fs/struct.File.html#method.try_clone"><code>try_clone</code></a>方法，它的语义对多线程代码会产生复杂的影响，如seek原文件的位置会同步到<code>try_clone</code>创建的另一个文件。请考虑<code>File::open</code>和<code>try_clone</code>中文件之间的区别。使用<code>try_clone</code>还是<code>File::open</code>，将是您的选择。查看<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1687275/what-is-the-difference-between-read-and-pread-in-unix"><code>pread</code></a>可能会有所帮助。</p>
<h4 id="按角色分解数据结构"><a href="#按角色分解数据结构" class="headerlink" title="按角色分解数据结构"></a>按角色分解数据结构</h4><p>在例子中，我们有两个明确的角色：读和写（也许还有第三个用于压缩）。将读逻辑和写逻辑分离并各封装为一个并发类型在Rust中很常见。读逻辑有自己的数据集，写逻辑也一样，这就为封装提供了很好的条件，所有读操作划为一种类型，而所有写操作划为另一种类型。</p>
<p>这种划分将进一步使两者都访问哪些资源变得非常明显，因为读类型和写类型都将包含这些资源的共享句柄。</p>
<h4 id="使用专门的并发数据结构"><a href="#使用专门的并发数据结构" class="headerlink" title="使用专门的并发数据结构"></a>使用专门的并发数据结构</h4><p>知道哪些工具可用以及该在哪些场景中使用可能是并行编程中最困难的部分。除了学校里教的基础锁类型，同步数据类型也变得越来越专业化。</p>
<p>在本项目中，由于内存索引是某种类型的关联数据结构（也称为“映射”），如树或哈希表，那么我们自然会想到是否存在并发关联数据结构。</p>
<p>确实存在，且正确的使用这些数据结构是完成本项目的关键。</p>
<p>但是怎么才能找到这些类型呢？第一步是确定是否存在并发映射。您可以阅读<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/fs/struct.File.html#method.try_clone">Rust Discord</a>上的<code>#beginners</code>部分，但对于本项目，在网络上搜”concurrent map”即可。</p>
<p>这是容易的部分，<em>在Rust</em>中找到正确的并发映射类型则更困难。比较好的起手式是访问<a target="_blank" rel="noopener" href="https://libs.rs/">libs.rs</a>。libs.rs与crates.io类似，但crates.io包含所有已发布的库，而libs.rs仅包含受到……好吧，某些人好评的库。因此，如果一个库在libs.rs上，就是库可用的一个指示，另一个是<a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a>上的下载计数 &mdash; 通常，下载越多的crates被测试的越细。下载计数可以粗略的看作是“担保”库的人数。最后，在聊天中提问也是一个好主意。</p>
<h4 id="将清理延后"><a href="#将清理延后" class="headerlink" title="将清理延后"></a>将清理延后</h4><p>像克隆一样，垃圾收集在Rust中经常遭到反对 &mdash; 避免GC几乎就是Rust存的意义。但实际上垃圾收集是不可避免的，“垃圾收集”和“内存回收”实际上是同义词，各种语言都复合使用了多种垃圾收集策略。GC策略轴的一端，在没有自动内存管理的语言（如C）中，垃圾收集完全由程序员决定，如使用<code>malloc</code>和<code>free</code>。另一端则是垃圾收集语言，如 Java，所有内存都由一个通用垃圾收集器管理。</p>
<p>但实际上，在C中并不是所有内存的管理和回收都使用<code>malloc</code>/<code>free</code>，在Java也并不是所有内存管理都通过GC完成。举个简单的例子，两者中的高性能应用程序通常都依赖于专门的内存区域，在这些区域既可以重用内存也可以大量解除分配，以优化其内存访问模式。</p>
<p>同样在Rust中，并非所有内存都被显式地释放。比如在<code>Rc</code>和<code>Arc</code>类型中实现了<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Reference_counting">资源计数</a>，也算算算一种简单的GC。</p>
<p>全局垃圾收集器的最大好处之一，就是使许多无锁数据结构成为可能。学术文献中描述的许多无锁数据结构都依赖于GC执行。<a target="_blank" rel="noopener" href="https://github.com/crossbeam-rs/crossbeam"><code>crossbeam</code></a>库及其<a target="_blank" rel="noopener" href="https://docs.rs/crossbeam/0.7.1/crossbeam/epoch/index.html"><code>epoch</code></a>类型的出现，就是在不依赖GC的情况下实现无锁算法。</p>
<p>也就是说垃圾收集有多种形式，其“将资源清理延迟到未来某个时间”的基本策略在许多场景中都很强大。</p>
<p>当您现在不知道如何执行一些并发工作时，可以试着考虑：“可以稍后再做吗？”。</p>
<h4 id="与原子类型共享标志和计数器"><a href="#与原子类型共享标志和计数器" class="headerlink" title="与原子类型共享标志和计数器"></a>与原子类型共享标志和计数器</h4><p>在底层，大多数并发数据结构都是使用<a target="_blank" rel="noopener" href="https://preshing.com/20130618/atomic-vs-non-atomic-operations/">原子操作</a>或“原子类型”实现的。原子类型在单个内存单元上运行，一般在8到128个字节之间，通常是字长（与指针的字节数相同，并且与Rust<code>usize</code>类型大小相同）。如果两个线程正确使用原子类型，则一个线程中的写入结果将立即对另一个线程中的读取可见。除了使读取或写入立即可见之外，在Rust中，原子操作还通过<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html"><code>Ordering</code></a>标志限制编译器和CPU重新排序指令的方式。</p>
<p>当从粗粒度并行中的锁，转向更细粒度的并行时，通常需要使用原子类型来增强现成的并发数据结构。</p>
<h3 id="实现无锁读"><a href="#实现无锁读" class="headerlink" title="实现无锁读"></a>实现无锁读</h3><p>以上就是相关的背景知识。希望这些知识已经开始引导您考虑了很多东西，并朝着正确的方向前进了。现在轮到实现了：</p>
<p><em>修改<code>KvStore</code>以同时执行读取和写入。</em></p>
<hr>
<figure class="highlight rust"><figcaption><span>engines/kvs.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::collections::BTreeMap;</span><br><span class="line"><span class="keyword">use</span> std::fs::&#123;<span class="keyword">self</span>, File, OpenOptions&#125;;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, BufReader, BufWriter, Read, Seek, SeekFrom, Write&#125;;</span><br><span class="line"><span class="keyword">use</span> std::ops::Range;</span><br><span class="line"><span class="keyword">use</span> std::path::&#123;Path, PathBuf&#125;;</span><br><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicU64, Ordering&#125;;</span><br><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crossbeam_skiplist::SkipMap;</span><br><span class="line"><span class="keyword">use</span> log::error;</span><br><span class="line"><span class="keyword">use</span> serde::&#123;Deserialize, Serialize&#125;;</span><br><span class="line"><span class="keyword">use</span> serde_json::Deserializer;</span><br><span class="line"><span class="keyword">use</span> crate::&#123;KvsError, <span class="built_in">Result</span>, KvsEngine&#125;;</span><br><span class="line"><span class="keyword">use</span> std::ffi::OsStr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> COMPACTION_THRESHOLD: <span class="built_in">u64</span> = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// The `KvStore` stores string key/value pairs.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Key/value pairs are persisted to disk in log files. Log files are named after</span></span><br><span class="line"><span class="comment">/// monotonically increasing generation numbers with a `log` extension name.</span></span><br><span class="line"><span class="comment">/// A `BTreeMap` in memory stores the keys and the value locations for fast query.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// ```rust</span></span><br><span class="line"><span class="comment">/// # use kvs::&#123;KvStore, Result&#125;;</span></span><br><span class="line"><span class="comment">/// # fn try_main() -&gt; Result&lt;()&gt; &#123;</span></span><br><span class="line"><span class="comment">/// use std::env::current_dir;</span></span><br><span class="line"><span class="comment">/// use kvs::KvsEngine;</span></span><br><span class="line"><span class="comment">/// let mut store = KvStore::open(current_dir()?)?;</span></span><br><span class="line"><span class="comment">/// store.set(&quot;key&quot;.to_owned(), &quot;value&quot;.to_owned())?;</span></span><br><span class="line"><span class="comment">/// let val = store.get(&quot;key&quot;.to_owned())?;</span></span><br><span class="line"><span class="comment">/// assert_eq!(val, Some(&quot;value&quot;.to_owned()));</span></span><br><span class="line"><span class="comment">/// # Ok(())</span></span><br><span class="line"><span class="comment">/// # &#125;</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">KvStore</span></span> &#123;</span><br><span class="line">    <span class="comment">// map generation number to the file reader</span></span><br><span class="line">    index: Arc&lt;SkipMap&lt;<span class="built_in">String</span>, CommandPos&gt;&gt;,</span><br><span class="line">    reader: KvStoreReader,</span><br><span class="line">    <span class="comment">// writer of the current log.</span></span><br><span class="line">    writer: Arc&lt;Mutex&lt;KvStoreWriter&gt;&gt;,</span><br><span class="line">    <span class="comment">// the number of bytes representing &quot;stale&quot; commands that could be</span></span><br><span class="line">    <span class="comment">// deleted during a compaction.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> KvStore &#123;</span><br><span class="line">    <span class="comment">/// Opens a `KvStore` with the given path.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// This will create a new directory if the given one does not exist.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// # Errors</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// It propagates I/O or deserialization errors during the log replay.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">open</span></span>(path: <span class="keyword">impl</span> <span class="built_in">Into</span>&lt;PathBuf&gt;) -&gt; <span class="built_in">Result</span>&lt;KvStore&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> path = Arc::new(path.into());</span><br><span class="line">        fs::create_dir_all(&amp;*path)?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> readers = BTreeMap::new();</span><br><span class="line">        <span class="keyword">let</span> index = Arc::new(SkipMap::new());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> gen_list = sorted_gen_list(&amp;path)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> uncompacted = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> &amp;gen <span class="keyword">in</span> &amp;gen_list &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> reader = BufReaderWithPos::new(File::open(log_path(&amp;path, gen))?)?;</span><br><span class="line">            uncompacted += load(gen, &amp;<span class="keyword">mut</span> reader, &amp;*index)?;</span><br><span class="line">            readers.insert(gen, reader);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> current_gen = gen_list.last().unwrap_or(&amp;<span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> writer = new_log_file(&amp;path, current_gen)?;</span><br><span class="line">        <span class="keyword">let</span> safe_point = Arc::new(AtomicU64::new(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> reader = KvStoreReader &#123; </span><br><span class="line">            path: Arc::clone(&amp;path), </span><br><span class="line">            safe_point,</span><br><span class="line">            readers: RefCell::new(readers),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> writer = KvStoreWriter &#123;</span><br><span class="line">            reader: reader.clone(),</span><br><span class="line">            writer,</span><br><span class="line">            current_gen, </span><br><span class="line">            uncompacted,</span><br><span class="line">            path: Arc::clone(&amp;path),</span><br><span class="line">            index: Arc::clone(&amp;index),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="literal">Ok</span>(KvStore &#123;</span><br><span class="line">            reader,</span><br><span class="line">            index,</span><br><span class="line">            writer: Arc::new(Mutex::new(writer)),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> KvsEngine <span class="keyword">for</span> KvStore &#123;</span><br><span class="line">    <span class="comment">/// Sets the value of a string key to a string.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// If the key already exists, the previous value will be overwritten.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// # Errors</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// It propagates I/O or serialization errors during writing the log.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">set</span></span>(&amp;<span class="keyword">self</span>, key: <span class="built_in">String</span>, value: <span class="built_in">String</span>) -&gt; <span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.writer.lock().unwrap().set(key, value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Gets the string value of a given string key.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// Returns `None` if the given key does not exist.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// # Errors</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// It returns `KvsError::UnexpectedCommandType` if the given command type unexpected.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get</span></span>(&amp;<span class="keyword">self</span>, key: <span class="built_in">String</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(cmd_pos) = <span class="keyword">self</span>.index.get(&amp;key) &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> Command::Set &#123; value, .. &#125; = <span class="keyword">self</span>.reader.read_command(*cmd_pos.value())? &#123;</span><br><span class="line">                <span class="literal">Ok</span>(<span class="literal">Some</span>(value))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="literal">Err</span>(KvsError::UnexpectedCommandType)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">Ok</span>(<span class="literal">None</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Removes a given key.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// # Errors</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// It returns `KvsError::KeyNotFound` if the given key is not found.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// It propagates I/O or serialization errors during writing the log.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">remove</span></span>(&amp;<span class="keyword">self</span>, key: <span class="built_in">String</span>) -&gt; <span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.writer.lock().unwrap().remove(key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A single thread reader. </span></span><br><span class="line"><span class="comment">/// </span></span><br><span class="line"><span class="comment">/// Each `KvStore` instance has its own `KvStoreReader` and </span></span><br><span class="line"><span class="comment">/// `KvStoreReader`s open the same file separately. So the user </span></span><br><span class="line"><span class="comment">/// can read concurrently through multiple `KvStore`s in different </span></span><br><span class="line"><span class="comment">/// threads.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KvStoreReader</span></span> &#123;</span><br><span class="line">    path: Arc&lt;PathBuf&gt;,</span><br><span class="line">    <span class="comment">// generation of the latest compaction file</span></span><br><span class="line">    safe_point: Arc&lt;AtomicU64&gt;,</span><br><span class="line">    readers: RefCell&lt;BTreeMap&lt;<span class="built_in">u64</span>, BufReaderWithPos&lt;File&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> KvStoreReader &#123;</span><br><span class="line">    <span class="comment">/// Close file handles with generation number less than safe_point.</span></span><br><span class="line">    <span class="comment">/// </span></span><br><span class="line">    <span class="comment">/// `safe_point` is updated to the latest compaction gen after a compaction finished.</span></span><br><span class="line">    <span class="comment">/// The compaction generation contains the sum of all operations before it and the </span></span><br><span class="line">    <span class="comment">/// in-memory index contains no entries with generation number less than safe_point.</span></span><br><span class="line">    <span class="comment">/// So we can safely close those file handles and the stales file can be deleted.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">close_stale_handles</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> readers = <span class="keyword">self</span>.readers.borrow_mut();</span><br><span class="line">        <span class="keyword">while</span> !readers.is_empty() &#123;</span><br><span class="line">            <span class="keyword">let</span> first_gen = *readers.keys().next().unwrap();</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.safe_point.load(Ordering::SeqCst) &lt;= first_gen &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            readers.remove(&amp;first_gen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Read the log file at the given `CommandPos`.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read_and</span></span>&lt;F, R&gt;(&amp;<span class="keyword">self</span>, cmd_pos: CommandPos, f: F) -&gt; <span class="built_in">Result</span>&lt;R&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="built_in">FnOnce</span>(io::Take&lt;&amp;<span class="keyword">mut</span> BufReaderWithPos&lt;File&gt;&gt;) -&gt; <span class="built_in">Result</span>&lt;R&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.close_stale_handles();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> readers = <span class="keyword">self</span>.readers.borrow_mut();</span><br><span class="line">        <span class="comment">// Open the file if we haven&#x27;t open it in this `KvStoreReader`.</span></span><br><span class="line">        <span class="comment">// We don&#x27;t use entry API here because we want the errors to be propogated.</span></span><br><span class="line">        <span class="keyword">if</span> !readers.contains_key(&amp;cmd_pos.gen) &#123;</span><br><span class="line">            <span class="keyword">let</span> reader = BufReaderWithPos::new(File::open(log_path(&amp;<span class="keyword">self</span>.path, cmd_pos.gen))?)?;</span><br><span class="line">            readers.insert(cmd_pos.gen, reader);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> reader = readers.get_mut(&amp;cmd_pos.gen).unwrap();</span><br><span class="line">        reader.seek(SeekFrom::Start(cmd_pos.pos))?;</span><br><span class="line">        <span class="keyword">let</span> cmd_reader = reader.take(cmd_pos.len);</span><br><span class="line">        f(cmd_reader)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the log file at the given `CommandPos` and deserialize it to `Command`.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read_command</span></span>(&amp;<span class="keyword">self</span>, cmd_pos: CommandPos) -&gt; <span class="built_in">Result</span>&lt;Command&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.read_and(cmd_pos, |cmd_reader| &#123;</span><br><span class="line">            <span class="literal">Ok</span>(serde_json::from_reader(cmd_reader)?)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Clone</span> <span class="keyword">for</span> KvStoreReader &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clone</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        KvStoreReader &#123; </span><br><span class="line">            path: Arc::clone(&amp;<span class="keyword">self</span>.path), </span><br><span class="line">            safe_point: Arc::clone(&amp;<span class="keyword">self</span>.safe_point), </span><br><span class="line">            <span class="comment">// don&#x27;t use other KvStoreReader&#x27;s readers</span></span><br><span class="line">            readers: RefCell::new(BTreeMap::new()), </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KvStoreWriter</span></span> &#123;</span><br><span class="line">    reader: KvStoreReader,</span><br><span class="line">    writer: BufWriterWithPos&lt;File&gt;,</span><br><span class="line">    current_gen: <span class="built_in">u64</span>,</span><br><span class="line">    <span class="comment">// the number of bytes representing &quot;stale&quot; commands that could be</span></span><br><span class="line">    <span class="comment">// delete during a compaction</span></span><br><span class="line">    uncompacted: <span class="built_in">u64</span>,</span><br><span class="line">    path: Arc&lt;PathBuf&gt;,</span><br><span class="line">    index: Arc&lt;SkipMap&lt;<span class="built_in">String</span>, CommandPos&gt;&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> KvStoreWriter &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">set</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, key: <span class="built_in">String</span>, value: <span class="built_in">String</span>) -&gt; <span class="built_in">Result</span>&lt;()&gt;&#123;</span><br><span class="line">        <span class="keyword">let</span> cmd = Command::set(key, value);</span><br><span class="line">        <span class="keyword">let</span> pos = <span class="keyword">self</span>.writer.pos;</span><br><span class="line">        serde_json::to_writer(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.writer, &amp;cmd)?;</span><br><span class="line">        <span class="keyword">self</span>.writer.flush()?;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> Command::Set &#123; key, .. &#125; = cmd &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(old_cmd) = <span class="keyword">self</span>.index.get(&amp;key) &#123;</span><br><span class="line">                <span class="keyword">self</span>.uncompacted += old_cmd.value().len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.index</span><br><span class="line">                .insert(key, (<span class="keyword">self</span>.current_gen, pos..<span class="keyword">self</span>.writer.pos).into());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.uncompacted &gt; COMPACTION_THRESHOLD &#123;</span><br><span class="line">            <span class="keyword">self</span>.compact()?;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">remove</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, key: <span class="built_in">String</span>) -&gt; <span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.index.contains_key(&amp;key) &#123;</span><br><span class="line">            <span class="keyword">let</span> cmd = Command::remove(key);</span><br><span class="line">            <span class="keyword">let</span> pos = <span class="keyword">self</span>.writer.pos;</span><br><span class="line">            serde_json::to_writer(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.writer, &amp;cmd)?;</span><br><span class="line">            <span class="keyword">self</span>.writer.flush()?;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> Command::Remove &#123; key &#125; = cmd &#123;</span><br><span class="line">                <span class="keyword">let</span> old_cmd = <span class="keyword">self</span>.index.remove(&amp;key).expect(<span class="string">&quot;key not found&quot;</span>);</span><br><span class="line">                <span class="keyword">self</span>.uncompacted += old_cmd.value().len;</span><br><span class="line">                <span class="comment">// the &quot;remove&quot; command itself can be deleted in the next compaction</span></span><br><span class="line">                <span class="comment">// so we add it&#x27;s length to `uncompacted`</span></span><br><span class="line">                <span class="keyword">self</span>.uncompacted += <span class="keyword">self</span>.writer.pos - pos;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.uncompacted &gt; COMPACTION_THRESHOLD &#123;</span><br><span class="line">                <span class="keyword">self</span>.compact()?;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">Ok</span>(())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">Err</span>(KvsError::KeyNotFound)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Clear stale entries in log.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">compact</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">        <span class="comment">// increase current gen by 2. current_gen + 1 is for compaction file</span></span><br><span class="line">        <span class="keyword">let</span> compaction_gen  = <span class="keyword">self</span>.current_gen + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">self</span>.current_gen += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">self</span>.writer = new_log_file(&amp;<span class="keyword">self</span>.path, <span class="keyword">self</span>.current_gen)?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> compaction_writer = new_log_file(&amp;<span class="keyword">self</span>.path, compaction_gen)?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> new_pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> entry <span class="keyword">in</span> <span class="keyword">self</span>.index.iter() &#123;</span><br><span class="line">            <span class="keyword">let</span> len = <span class="keyword">self</span>.reader.read_and(*entry.value(), |<span class="keyword">mut</span> entry_reader| &#123;</span><br><span class="line">                <span class="literal">Ok</span>(io::copy(&amp;<span class="keyword">mut</span> entry_reader, &amp;<span class="keyword">mut</span> compaction_writer)?)</span><br><span class="line">            &#125;)?;</span><br><span class="line">            <span class="keyword">self</span>.index.insert(</span><br><span class="line">                entry.key().clone(),</span><br><span class="line">                (compaction_gen, new_pos..new_pos+len).into(),</span><br><span class="line">            );</span><br><span class="line">            new_pos += len;</span><br><span class="line">        &#125;</span><br><span class="line">        compaction_writer.flush()?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.reader</span><br><span class="line">            .safe_point</span><br><span class="line">            .store(compaction_gen, Ordering::SeqCst);</span><br><span class="line">        <span class="keyword">self</span>.reader.close_stale_handles();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remove stale log files.</span></span><br><span class="line">        <span class="comment">// Note that actually these files are not deleted immediately because `KvStoreReader`s</span></span><br><span class="line">        <span class="comment">// still keep open file handles. When `KvStoreReader` is used next time, it will clear</span></span><br><span class="line">        <span class="comment">// its stale file handles. On Unix, the files will be deleted after all the handles</span></span><br><span class="line">        <span class="comment">// are closed. On Windows, the deletions below will fail and stale files are expected</span></span><br><span class="line">        <span class="comment">// to be deleted in the next compaction.</span></span><br><span class="line">        <span class="keyword">let</span> stale_gens = sorted_gen_list(&amp;<span class="keyword">self</span>.path)?</span><br><span class="line">            .into_iter()</span><br><span class="line">            .filter(|&amp;gen| gen &lt; compaction_gen);</span><br><span class="line">        <span class="keyword">for</span> stale_gen <span class="keyword">in</span> stale_gens &#123;</span><br><span class="line">            <span class="keyword">let</span> file_path = log_path(&amp;<span class="keyword">self</span>.path, stale_gen);</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Err</span>(e) = fs::remove_file(&amp;file_path) &#123;</span><br><span class="line">                error!(<span class="string">&quot;&#123;:?&#125; cannot be deleted: &#123;&#125;&quot;</span>, file_path, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.uncompacted = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="literal">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// Create a new log file with given generation number.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Returns the writer to the log.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">new_log_file</span></span>(path: &amp;Path, gen: <span class="built_in">u64</span>) -&gt; <span class="built_in">Result</span>&lt;BufWriterWithPos&lt;File&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> path = log_path(&amp;path, gen);</span><br><span class="line">    <span class="keyword">let</span> writer = BufWriterWithPos::new(</span><br><span class="line">        OpenOptions::new()</span><br><span class="line">            .create(<span class="literal">true</span>)</span><br><span class="line">            .write(<span class="literal">true</span>)</span><br><span class="line">            .append(<span class="literal">true</span>)</span><br><span class="line">            .open(&amp;path)?,</span><br><span class="line">    )?;</span><br><span class="line">    <span class="literal">Ok</span>(writer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Returns sorted generation numbers in the given directory.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sorted_gen_list</span></span>(path: &amp;Path) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u64</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> gen_list: <span class="built_in">Vec</span>&lt;<span class="built_in">u64</span>&gt; = fs::read_dir(&amp;path)?</span><br><span class="line">        .flat_map(|res| -&gt; <span class="built_in">Result</span>&lt;_&gt; &#123; <span class="literal">Ok</span>(res?.path()) &#125;)</span><br><span class="line">        .filter(|path| path.is_file() &amp;&amp; path.extension() == <span class="literal">Some</span>(<span class="string">&quot;log&quot;</span>.as_ref()))</span><br><span class="line">        .flat_map(|path| &#123;</span><br><span class="line">            path.file_name()</span><br><span class="line">                .and_then(OsStr::to_str)</span><br><span class="line">                .map(|s| s.trim_end_matches(<span class="string">&quot;.log&quot;</span>))</span><br><span class="line">                .map(<span class="built_in">str</span>::parse::&lt;<span class="built_in">u64</span>&gt;)</span><br><span class="line">        &#125;)</span><br><span class="line">        .flatten()</span><br><span class="line">        .collect();</span><br><span class="line">    gen_list.sort_unstable();</span><br><span class="line">    <span class="literal">Ok</span>(gen_list)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Load the whole log file and store value locations in the index map.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Returns how many bytes can be saved after a compaction.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">load</span></span>(</span><br><span class="line">    gen: <span class="built_in">u64</span>,</span><br><span class="line">    reader: &amp;<span class="keyword">mut</span> BufReaderWithPos&lt;File&gt;,</span><br><span class="line">    index: &amp;SkipMap&lt;<span class="built_in">String</span>, CommandPos&gt;,</span><br><span class="line">) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">u64</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// To make sure we read from the beginning of the file.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> pos = reader.seek(SeekFrom::Start(<span class="number">0</span>))?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> stream = Deserializer::from_reader(reader).into_iter::&lt;Command&gt;();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> uncompacted = <span class="number">0</span>; <span class="comment">// number of bytes that can be saved after a compaction.</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(cmd) = stream.next() &#123;</span><br><span class="line">        <span class="keyword">let</span> new_pos = stream.byte_offset() <span class="keyword">as</span> <span class="built_in">u64</span>;</span><br><span class="line">        <span class="keyword">match</span> cmd? &#123;</span><br><span class="line">            Command::Set &#123; key, .. &#125; =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(old_cmd) = index.get(&amp;key) &#123;</span><br><span class="line">                    uncompacted += old_cmd.value().len;</span><br><span class="line">                &#125;</span><br><span class="line">                index.insert(key, (gen, pos..new_pos).into());</span><br><span class="line">            &#125;</span><br><span class="line">            Command::Remove &#123; key &#125; =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(old_cmd) = index.remove(&amp;key) &#123;</span><br><span class="line">                    uncompacted += old_cmd.value().len;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// the &quot;remove&quot; command itself can be deleted in the next compaction</span></span><br><span class="line">                <span class="comment">// so we add its length to `uncompacted`</span></span><br><span class="line">                uncompacted += new_pos - pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pos = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">Ok</span>(uncompacted)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">log_path</span></span>(dir: &amp;Path, gen: <span class="built_in">u64</span>) -&gt; PathBuf &#123;</span><br><span class="line">    dir.join(<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;.log&quot;</span>, gen))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Struct representing a command.</span></span><br><span class="line"><span class="meta">#[derive(Serialize, Deserialize, Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Command</span></span> &#123;</span><br><span class="line">    Set &#123; key: <span class="built_in">String</span>, value: <span class="built_in">String</span> &#125;,</span><br><span class="line">    Remove &#123; key: <span class="built_in">String</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Command &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">set</span></span>(key: <span class="built_in">String</span>, value: <span class="built_in">String</span>) -&gt; Command &#123;</span><br><span class="line">        Command::Set &#123; key, value &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">remove</span></span>(key: <span class="built_in">String</span>) -&gt; Command &#123;</span><br><span class="line">        Command::Remove &#123; key &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, Clone, Copy)]</span></span><br><span class="line"><span class="comment">/// Represents the position and length of a json-serialized command in the log.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CommandPos</span></span> &#123;</span><br><span class="line">    gen: <span class="built_in">u64</span>,</span><br><span class="line">    pos: <span class="built_in">u64</span>,</span><br><span class="line">    len: <span class="built_in">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">From</span>&lt;(<span class="built_in">u64</span>, Range&lt;<span class="built_in">u64</span>&gt;)&gt; <span class="keyword">for</span> CommandPos &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">from</span></span>((gen, range): (<span class="built_in">u64</span>, Range&lt;<span class="built_in">u64</span>&gt;)) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        CommandPos &#123;</span><br><span class="line">            gen,</span><br><span class="line">            pos: range.start,</span><br><span class="line">            len: range.end - range.start,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BufReaderWithPos</span></span>&lt;R: Read + Seek&gt; &#123;</span><br><span class="line">    reader: BufReader&lt;R&gt;,</span><br><span class="line">    pos: <span class="built_in">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;R: Read + Seek&gt; BufReaderWithPos&lt;R&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(<span class="keyword">mut</span> inner: R) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> pos = inner.seek(SeekFrom::Current(<span class="number">0</span>))?;</span><br><span class="line">        <span class="literal">Ok</span>(BufReaderWithPos &#123;</span><br><span class="line">            reader: BufReader::new(inner),</span><br><span class="line">            pos,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;R: Read + Seek&gt; Read <span class="keyword">for</span> BufReaderWithPos&lt;R&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>]) -&gt; io::<span class="built_in">Result</span>&lt;<span class="built_in">usize</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> len = <span class="keyword">self</span>.reader.read(buf)?;</span><br><span class="line">        <span class="keyword">self</span>.pos += len <span class="keyword">as</span> <span class="built_in">u64</span>;</span><br><span class="line">        <span class="literal">Ok</span>(len)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;R: Read + Seek&gt; Seek <span class="keyword">for</span> BufReaderWithPos&lt;R&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">seek</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, pos: SeekFrom) -&gt; io::<span class="built_in">Result</span>&lt;<span class="built_in">u64</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.pos = <span class="keyword">self</span>.reader.seek(pos)?;</span><br><span class="line">        <span class="literal">Ok</span>(<span class="keyword">self</span>.pos)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BufWriterWithPos</span></span>&lt;W: Write + Seek&gt; &#123;</span><br><span class="line">    writer: BufWriter&lt;W&gt;,</span><br><span class="line">    pos: <span class="built_in">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;W: Write + Seek&gt; BufWriterWithPos&lt;W&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(<span class="keyword">mut</span> inner: W) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> pos = inner.seek(SeekFrom::Current(<span class="number">0</span>))?;</span><br><span class="line">        <span class="literal">Ok</span>(BufWriterWithPos &#123;</span><br><span class="line">            writer: BufWriter::new(inner),</span><br><span class="line">            pos,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;W: Write + Seek&gt; Write <span class="keyword">for</span> BufWriterWithPos&lt;W&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;[<span class="built_in">u8</span>]) -&gt; io::<span class="built_in">Result</span>&lt;<span class="built_in">usize</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> len = <span class="keyword">self</span>.writer.write(buf)?;</span><br><span class="line">        <span class="keyword">self</span>.pos += len <span class="keyword">as</span> <span class="built_in">u64</span>;</span><br><span class="line">        <span class="literal">Ok</span>(len)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">flush</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.writer.flush()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;W: Write + Seek&gt; Seek <span class="keyword">for</span> BufWriterWithPos&lt;W&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">seek</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, pos: SeekFrom) -&gt; io::<span class="built_in">Result</span>&lt;<span class="built_in">u64</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.pos = <span class="keyword">self</span>.writer.seek(pos)?;</span><br><span class="line">        <span class="literal">Ok</span>(<span class="keyword">self</span>.pos)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>干得漂亮，朋友。休息一下吧。</p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Rust/">Rust</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatpay.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/08/30/pna-rust-project-5/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">PingCap的Rust训练课程5：异步编程</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/05/10/pna-rust-project-3/"><span class="level-item">PingCap的Rust训练课程3：同步的“客户端-服务端”网络模块</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><script src="https://utteranc.es/client.js" repo="zlotus/comment" issue-term="pathname" label="some-issue-label" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/opm_sq.png" alt="子实"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">子实</p><p class="is-size-6 is-block">程序员</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>陕西/西安</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">80</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">23</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zlotus" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com/qinzishi"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/Zealot_uS"><i class="fab fa-twitter"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.zhihu.com/people/zlotus" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Diary/"><span class="level-start"><span class="level-item">Diary</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">66</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Shell/"><span class="level-start"><span class="level-item">Shell</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Coroutines/"><span class="tag">Coroutines</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">32</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenCV/"><span class="tag">OpenCV</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Operating-System/"><span class="tag">Operating System</span><span class="tag">21</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Paper/"><span class="tag">Paper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Raspberry-Pi/"><span class="tag">Raspberry Pi</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag">29</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TensorFlow/"><span class="tag">TensorFlow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tokio/"><span class="tag">Tokio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZMQ/"><span class="tag">ZMQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ctpn/"><span class="tag">ctpn</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/llama/"><span class="tag">llama</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macOS/"><span class="tag">macOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/obsidion/"><span class="tag">obsidion</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%A5%E8%AE%B0/"><span class="tag">日记</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E8%B0%88/"><span class="tag">杂谈</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B/"><span class="tag">编程</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%84%9A%E6%9C%AC/"><span class="tag">脚本</span><span class="tag">4</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a><p class="is-size-7"><span>&copy; 2024 子实</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>