<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>使用Rust编写操作系统 - 3.4 - 内存分配器设计 - 子实</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="子实"><meta name="msapplication-TileImage" content="/img/avatar-o.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="子实"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="使用Rust编写操作系统 - 3.4 - 内存分配器设计"><meta property="og:type" content="article"><meta property="og:title" content="使用Rust编写操作系统 - 3.4 - 内存分配器设计"><meta property="og:url" content="https://zlotus.github.io/2021/04/06/writing-an-os-in-rust-3.4/"><meta property="og:site_name" content="子实"><meta property="og:description" content="使用Rust编写操作系统 - 3.4 - 内存分配器设计"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://os.phil-opp.com/allocator-designs/bump-allocation.svg"><meta property="og:image" content="https://os.phil-opp.com/allocator-designs/allocation-fragmentation.svg"><meta property="og:image" content="https://os.phil-opp.com/allocator-designs/linked-list-allocation.svg"><meta property="og:image" content="https://os.phil-opp.com/allocator-designs/linked-list-allocator-push.svg"><meta property="og:image" content="https://os.phil-opp.com/allocator-designs/linked-list-allocator-remove-region.svg"><meta property="og:image" content="https://os.phil-opp.com/allocator-designs/linked-list-allocator-fragmentation-on-dealloc.svg"><meta property="og:image" content="https://os.phil-opp.com/allocator-designs/linked-list-allocator-merge-on-dealloc.svg"><meta property="og:image" content="https://os.phil-opp.com/allocator-designs/fixed-size-block-example.svg"><meta property="article:published_time" content="2021-04-06T11:02:00.000Z"><meta property="article:modified_time" content="2021-04-06T11:02:00.000Z"><meta property="article:author" content="子实"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Operating System"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://os.phil-opp.com/allocator-designs/bump-allocation.svg"><meta property="twitter:creator" content="@Zealot_uS"><meta property="twitter:site" content="Zealot_uS"><link rel="publisher" href="+LotusQin"><meta property="fb:admins" content="qinzishi"><meta property="fb:app_id" content="qinzishi"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zlotus.github.io/2021/04/06/writing-an-os-in-rust-3.4/"},"headline":"使用Rust编写操作系统 - 3.4 - 内存分配器设计","image":[],"datePublished":"2021-04-06T11:02:00.000Z","dateModified":"2021-04-06T11:02:00.000Z","author":{"@type":"Person","name":"子实"},"publisher":{"@type":"Organization","name":"子实","logo":{"@type":"ImageObject","url":"https://zlotus.github.io/img/opm_sq.png"}},"description":"使用Rust编写操作系统 - 3.4 - 内存分配器设计"}</script><link rel="icon" href="/img/avatar-o.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/2014/07/09/about-me/">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-06T11:02:00.000Z" title="4/6/2021, 7:02:00 PM">2021-04-06</time>发表</span><span class="level-item"><time dateTime="2021-04-06T11:02:00.000Z" title="4/6/2021, 7:02:00 PM">2021-04-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a></span><span class="level-item">2 小时读完 (大约18513个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">使用Rust编写操作系统 - 3.4 - 内存分配器设计</h1><div class="content"><article class="message message-immersive is-warning">
<div class="message-body">
<i class="fas fa-exclamation-triangle mr-2"></i>本文所有内容均为翻译，原文：<a target="_blank" rel="noopener" href="https://os.phil-opp.com/allocator-designs/">Allocator Designs</a>；原项目：<a target="_blank" rel="noopener" href="https://os.phil-opp.com/">Writing an OS in Rust</a>
</div>
</article>

<p>本文将展示如何从零编写堆分配器，并讨论不同的分配器设计，包括线性分配，链表分配和固定大小块分配。我们将为这三种分配器分别创建一个可用于内核的基本实现。</p>
<span id="more"></span>

<p>这个博客是在<a target="_blank" rel="noopener" href="https://github.com/phil-opp/blog_os">GitHub</a>上公开开发的。如果你有任何问题或疑问，请在那里开一个issue。你也可以在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/allocator-designs/#comments">底部</a>留言。这篇文章的完整源代码可以在<a target="_blank" rel="noopener" href="https://github.com/phil-opp/blog_os/tree/post-11">post-11</a>分支中找到。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/heap-allocation/">上一篇文章</a>中，我们向内核添加了对堆分配的基本支持。为此，我们在页表中<a target="_blank" rel="noopener" href="https://os.phil-opp.com/heap-allocation/#creating-a-kernel-heap">创建了一个新的内存区域</a>，并<a target="_blank" rel="noopener" href="https://os.phil-opp.com/heap-allocation/#using-an-allocator-crate">使用<code>linked_list_allocator</code>crate</a>来管理该内存。现在我们有了一个工作堆，但大部分工作留给了该分配器crate，并没有去了解分配器是如何工作的。</p>
<p>在这篇文章中，我们将展示如何从头开始创建堆分配器，而不是依赖现有的分配器crate。我们还将讨论不同的分配器设计，包括简单的<em>线性分配器</em>和基本的<em>固定大小块分配器</em>，并使用此知识来实现性能提高的分配器（与<code>linked_list_allocator</code>crate相比）。</p>
<h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><p>分配器的主要任务是管理可用的堆内存，它需要在<code>alloc</code>调用中返回未使用的内存，并跟踪用<code>dealloc</code>释放的内存，以便实现内存重用。最重要的是，它绝不能分配已经在其他地方使用的内存，因为这将会导致未定义的行为。</p>
<p>除了确保正确性之外，还有许多次要任务。例如，分配器应有效地利用可用内存并减少内存<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fragmentation_(computing)">碎片</a>。此外，它应该能够很好的用于并发应用程序，并可以扩展到任意数量的处理器。为了获得最佳性能，它甚至可以针对CPU缓存优化内存布局，以提高<a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/locality-of-reference-and-cache-operation-in-cache-memory/">缓存局部性</a>并避免<a target="_blank" rel="noopener" href="https://mechanical-sympathy.blogspot.de/2011/07/false-sharing.html">伪共享</a>。</p>
<p>这些要求会使好的分配器非常复杂。比如<a target="_blank" rel="noopener" href="http://jemalloc.net/">jemalloc</a>具有超过30.000行代码。不过，我们通常并不希望在内核中使用如此复杂的代码，因为在内核中一个bug就会导致严重的安全漏洞。幸运的是，与用户空间代码相比，内核代码的分配模式通常要简单得多，因此使用较为简单的分配器设计通常就足够了。</p>
<p>在下面的内容中，我们将介绍三种可能的内核分配器设计，并说明它们的优缺点。</p>
<h2 id="线性分配器"><a href="#线性分配器" class="headerlink" title="线性分配器"></a>线性分配器</h2><p>最简单的分配器设计是<em>线性分配器</em>（也称为<em>栈分配器</em>）。它线性的分配内存，并且仅跟踪分配的字节数和分配数。线性分配器仅在非常特定的用例中使用，因为它有一个严格的限制：只能一次释放所有内存。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>线性分配器的思路是通过增加（“肿起来”）一个<code>next</code>变量来线性分配内存，该变量指向未使用内存的起点。一开始，<code>next</code>就是堆的起始地址。每次分配时，<code>next</code>都会增加，因此它始终指向已用内存和未用内存之间的边界：</p>
<p><img src="https://os.phil-opp.com/allocator-designs/bump-allocation.svg" alt="线性分配"></p>
<p><code>next</code>指针只会向前单方向移动，因此该方案永远不会将相同的存储区域分配出去两次。当指针到达堆尾时，已经没有更多的内存可供分配，因此下一次分配将引发一个内存不足错误。</p>
<p>线性分配器通常通过分配计数器实现，分配计数器在每次<code>alloc</code>调用时加1，在每次<code>dealloc</code>调用时减1。当分配计数器为零时，表示堆上的所有分配都已释放。在这种情况下，可以将<code>next</code>指针重置为堆的起始地址，以便再次分配完整的堆内存。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们通过声明一个新的<code>allocator::bump</code>子模块开始我们的实现：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> bump;</span><br></pre></td></tr></table></figure>

<p>子模块的代码位于新的<code>src/allocator/bump.rs</code>文件中，内容如下：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator/bump.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">BumpAllocator</span></span> &#123;</span><br><span class="line">    heap_start: <span class="built_in">usize</span>,</span><br><span class="line">    heap_end: <span class="built_in">usize</span>,</span><br><span class="line">    next: <span class="built_in">usize</span>,</span><br><span class="line">    allocations: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> BumpAllocator &#123;</span><br><span class="line">    <span class="comment">/// 创建一个空的线性分配器</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">const</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        BumpAllocator &#123;</span><br><span class="line">            heap_start: <span class="number">0</span>,</span><br><span class="line">            heap_end: <span class="number">0</span>,</span><br><span class="line">            next: <span class="number">0</span>,</span><br><span class="line">            allocations: <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 使用给定的堆边界初始化线性分配器</span></span><br><span class="line">    <span class="comment">/// </span></span><br><span class="line">    <span class="comment">/// 该方法为非安全，因为调用者必须保证提供的内存范围未被使用。</span></span><br><span class="line">    <span class="comment">/// 同时，该方法只能被调用一次。</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">init</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, heap_start: <span class="built_in">usize</span>, heap_size: <span class="built_in">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.heap_start = heap_start;</span><br><span class="line">        <span class="keyword">self</span>.heap_end = heap_start + heap_size;</span><br><span class="line">        <span class="keyword">self</span>.next = heap_start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>heap_start</code>和<code>heap_end</code>字段为堆内存区域的下限和上限。调用者需要确保这些地址有效，否则分配器将返回无效的内存。因此，<code>init</code>函数需要被标记为<code>unsafe</code>调用。</p>
<p><code>next</code>字段将始终指向堆内存中的首个未使用字节，即下一次分配的起始地址。在初始化函数中将其设置为<code>heap_start</code>，因为在一开始整个堆都是未使用状态。在每次分配时，该字段都会增加分配出去的大小（“肿起来”），以确保我们不会两次返回相同的内存区域。</p>
<p><code>allocations</code>字段是活动中已分配内存的简单计数器，目标是在释放最后一块已分配内存后重置分配器。初始化为0。</p>
<p>选择创建一个单独的<code>init</code>函数，而不是在<code>new</code>函数中直接执行初始化，是为了是我们的分配器接口与<code>linked_list_allocator</code>crate提供的分配器接口一致。这样，无需更改其他代码即可切换分配器。</p>
<h4 id="为线性分配器实现GlobalAlloc"><a href="#为线性分配器实现GlobalAlloc" class="headerlink" title="为线性分配器实现GlobalAlloc"></a>为线性分配器实现<code>GlobalAlloc</code></h4><p>如<a target="_blank" rel="noopener" href="https://os.phil-opp.com/heap-allocation/#the-allocator-interface">上一篇文章所述</a>，所有堆分配器都需要实现<code>GlobalAlloc</code>trait，其定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="class"><span class="keyword">trait</span> <span class="title">GlobalAlloc</span></span> &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">self</span>, layout: Layout) -&gt; *<span class="keyword">mut</span> <span class="built_in">u8</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">dealloc</span></span>(&amp;<span class="keyword">self</span>, ptr: *<span class="keyword">mut</span> <span class="built_in">u8</span>, layout: Layout);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc_zeroed</span></span>(&amp;<span class="keyword">self</span>, layout: Layout) -&gt; *<span class="keyword">mut</span> <span class="built_in">u8</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">realloc</span></span>(</span><br><span class="line">        &amp;<span class="keyword">self</span>,</span><br><span class="line">        ptr: *<span class="keyword">mut</span> <span class="built_in">u8</span>,</span><br><span class="line">        layout: Layout,</span><br><span class="line">        new_size: <span class="built_in">usize</span></span><br><span class="line">    ) -&gt; *<span class="keyword">mut</span> <span class="built_in">u8</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仅需要实现<code>alloc</code>和<code>dealloc</code>方法，其他两个方法均具有默认实现，我们在实现时可以忽略。</p>
<h4 id="首次实现尝试"><a href="#首次实现尝试" class="headerlink" title="首次实现尝试"></a>首次实现尝试</h4><p>让我们试着为<code>BumpAllocator</code>实现<code>alloc</code>方法：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator/bump.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> alloc::alloc::&#123;GlobalAlloc, Layout&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> GlobalAlloc <span class="keyword">for</span> BumpAllocator &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">self</span>, layout: Layout) -&gt; *<span class="keyword">mut</span> <span class="built_in">u8</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 对齐及边界检查</span></span><br><span class="line">        <span class="keyword">let</span> alloc_start = <span class="keyword">self</span>.next;</span><br><span class="line">        <span class="keyword">self</span>.next = alloc_start + layout.size();</span><br><span class="line">        <span class="keyword">self</span>.allocations += <span class="number">1</span>;</span><br><span class="line">        alloc_start <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u8</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">dealloc</span></span>(&amp;<span class="keyword">self</span>, _ptr: *<span class="keyword">mut</span> <span class="built_in">u8</span>, _layout: Layout) &#123;</span><br><span class="line">        todo!();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先将<code>next</code>字段用作分配的起始地址。然后更新<code>next</code>字段，使其指向分配的结束地址，即堆上的下一个未使用的地址。最后，在将分配的起始地址作为<code>* mut u8</code>指针返回之前，我们将分配计数器加1。</p>
<p>请注意，我们不执行任何边界检查或对齐调整，因此此实现尚不安全。这无关紧要，因为无论如何它都无法通过编译：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">error[E0594]: cannot assign to `self.next` <span class="built_in">which</span> is behind a `&amp;` reference</span><br><span class="line">  --&gt; src/allocator/bump.rs:29:9</span><br><span class="line">   |</span><br><span class="line">26 |     unsafe fn alloc(&amp;self, layout: Layout) -&gt; *mut u8 &#123;</span><br><span class="line">   |                     ----- <span class="built_in">help</span>: consider changing this to be a mutable reference: `&amp;mut self`</span><br><span class="line">...</span><br><span class="line">29 |         self.next = alloc_start + layout.size();</span><br><span class="line">   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be written</span><br></pre></td></tr></table></figure>

<p>（<code>self.allocations += 1</code>行也会报告相同的错误，在此省略。）</p>
<p>发生错误是因为<code>GlobalAlloc</code>trait的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html#tymethod.alloc"><code>alloc</code></a>和<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html#tymethod.dealloc"><code>dealloc</code></a>方法仅使用不可变的<code>&amp;self</code>引用执行，因此无法修改<code>next</code>和<code>allocations</code>字段。这是不行的，因为在分配后更新<code>next</code>是线性分配器的基本原理。</p>
<p>注意，在方法声明中将<code>&amp;self</code>更改为<code>&amp;mut self</code>的编译器建议在这里并不会起作用。因为该方法签名是由<code>GlobalAlloc</code>trait定义的，不能在实现时进行更改。（我在Rust代码库中开了一个关于无效建议的<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/issues/68049">issue</a>。）</p>
<h4 id="GlobalAlloc与可变性"><a href="#GlobalAlloc与可变性" class="headerlink" title="GlobalAlloc与可变性"></a><code>GlobalAlloc</code>与可变性</h4><p>在研究这个可变性问题可能的解决方案之前，让我们尝试理解<code>GlobalAlloc</code>trait中的方法为什么使用<code>&amp;self</code>定义参数的原因：正如我们在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/heap-allocation/#the-global-allocator-attribute">上一篇文章</a>中看到的那样，全局堆分配器是通过将<code>#[global_allocator]</code>属性添加到一个实现<code>GlobalAlloc</code>trait的<code>static</code>变量来定义的。静态变量在Rust中是不可变的，所以不能使用静态分配器的<code>&amp;mut self</code>引用来调用方法。因此，<code>GlobalAlloc</code>的所有方法仅采用不可变的<code>&amp;self</code>引用。</p>
<p>幸运的是，有一种方法可以从<code>&amp;self</code>引用中获取<code>&amp;mut self</code>引用：我们可以通过将分配器封装在<a target="_blank" rel="noopener" href="https://docs.rs/spin/0.5.0/spin/struct.Mutex.html"><code>spin::Mutex</code></a>自旋锁中来使用同步的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">内部可变性</a>。该类型提供互斥方法<code>lock</code>，从而安全地将<code>&amp;self</code>引用转换为<code>&amp;mut self</code>引用。我们已经在内核中多次使用了该封装类型，比如用在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/vga-text-mode/#spinlocks">VGA文本缓冲区</a>中。</p>
<h3 id="Locked封装类型"><a href="#Locked封装类型" class="headerlink" title="Locked封装类型"></a><code>Locked</code>封装类型</h3><p>借助<code>spin::Mutex</code>封装类型，我们可以为线性分配器实现<code>GlobalAlloc</code>特性。这里的技巧是不是直接为<code>BumpAllocator</code>实现trait，而是为封装的<code>spin::Mutex &lt;BumpAllocator&gt;</code>类型实现trait：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> GlobalAlloc <span class="keyword">for</span> spin::Mutex&lt;BumpAllocator&gt; &#123;…&#125;</span><br></pre></td></tr></table></figure>

<p>很不幸这仍然不起作用，因为Rust编译器不允许为其他crate中定义的类型的实现trait：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error[E0117]: only traits defined <span class="keyword">in</span> the current crate can be implemented <span class="keyword">for</span> arbitrary types</span><br><span class="line">  --&gt; src/allocator/bump.rs:28:1</span><br><span class="line">   |</span><br><span class="line">28 | unsafe impl GlobalAlloc <span class="keyword">for</span> spin::Mutex&lt;BumpAllocator&gt; &#123;</span><br><span class="line">   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^--------------------------</span><br><span class="line">   | |                           |</span><br><span class="line">   | |                           `spin::mutex::Mutex` is not defined <span class="keyword">in</span> the current crate</span><br><span class="line">   | impl doesn<span class="string">&#x27;t use only types from inside the current crate</span></span><br><span class="line"><span class="string">   |</span></span><br><span class="line"><span class="string">   = note: define and implement a trait or new type instead</span></span><br></pre></td></tr></table></figure>

<p>要解决此问题，我们需要再次封装<code>spin::Mutex</code>以创建自己的封装类型：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 封装spin::Mutex，以允许为其实现trait</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Locked</span></span>&lt;A&gt; &#123;</span><br><span class="line">    inner: spin::Mutex&lt;A&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;A&gt; Locked&lt;A&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">const</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(inner: A) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        Locked &#123;</span><br><span class="line">            inner: spin::Mutex::new(inner),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">lock</span></span>(&amp;<span class="keyword">self</span>) -&gt; spin::MutexGuard&lt;A&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.inner.lock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类型是对<code>spin::Mutex&lt;A&gt;</code>的泛型封装。它对封装的类型<code>A</code>没有任何限制，因此可以用于封装所有类型，而不仅仅是分配器。它提供了一个简单的构造函数<code>new</code>，用于封装给定值。为了方便调用，它还提供了<code>lock</code>函数，该函数可调用被封装的<code>Mutex</code>上的<code>lock</code>函数。由于<code>Locked</code>类型非常通用，也可用在其他分配器实现中，因此我们将它放在父级模块<code>allocator</code>中。</p>
<h4 id="实现Locked-lt-BumpAllocator-gt"><a href="#实现Locked-lt-BumpAllocator-gt" class="headerlink" title="实现Locked&lt;BumpAllocator&gt;"></a>实现<code>Locked&lt;BumpAllocator&gt;</code></h4><p><code>Locked</code>类型是在我们自己的crate中定义的（与<code>spin::Mutex</code>不同），因此可以用来为线性分配器实现<code>GlobalAlloc</code>。完整实现如下：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator/bump.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> super::&#123;align_up, Locked&#125;;</span><br><span class="line"><span class="keyword">use</span> alloc::alloc::&#123;GlobalAlloc, Layout&#125;;</span><br><span class="line"><span class="keyword">use</span> core::ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> GlobalAlloc <span class="keyword">for</span> Locked&lt;BumpAllocator&gt; &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">self</span>, layout: Layout) -&gt; *<span class="keyword">mut</span> <span class="built_in">u8</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> bump = <span class="keyword">self</span>.lock(); <span class="comment">// 获取可变引用</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> alloc_start = align_up(bump.next, layout.align());</span><br><span class="line">        <span class="keyword">let</span> alloc_end = <span class="keyword">match</span> alloc_start.checked_add(layout.size()) &#123;</span><br><span class="line">            <span class="literal">Some</span>(end) =&gt; end,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="keyword">return</span> ptr::null_mut(),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> alloc_end &gt; bump.heap_end &#123;</span><br><span class="line">            ptr::null_mut() <span class="comment">// 内存不足</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bump.next = alloc_end;</span><br><span class="line">            bump.allocations += <span class="number">1</span>;</span><br><span class="line">            alloc_start <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u8</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">dealloc</span></span>(&amp;<span class="keyword">self</span>, _ptr: *<span class="keyword">mut</span> <span class="built_in">u8</span>, _layout: Layout) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> bump = <span class="keyword">self</span>.lock(); <span class="comment">// 获取可变引用</span></span><br><span class="line"></span><br><span class="line">        bump.allocations -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> bump.allocations == <span class="number">0</span> &#123;</span><br><span class="line">            bump.next = bump.heap_start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>alloc</code>和<code>dealloc</code>的第一步是通过<code>inner</code>字段调用<a target="_blank" rel="noopener" href="https://docs.rs/spin/0.5.0/spin/struct.Mutex.html#method.lock"><code>Mutex::lock</code></a>方法，以获取被封装分配器类型的可变引用。该实例将保持锁定状态，直到方法结束，即使在多线程环境中也不会发生数据竞争（我们将很快添加线程支持）。</p>
<p>与前面的原型实现相比，<code>alloc</code>现在的实现遵守对齐要求并执行边界检查，以确保分配器分配的内存块仍在堆内存区域范围内。第一步是将<code>next</code>地址向上界对齐到<code>Layout</code>参数上。我们稍后再展示<code>align_up</code>函数的代码。然后将请求的分配大小加上<code>alloc_start</code>以获得这次分配的结束地址。为了防止在执行大尺寸分配时整型溢出，我们使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.usize.html#method.checked_add"><code>checked_add</code></a>方法进行检查。如果发生溢出或分配结果的结束地址大于堆的结束地址，我们将返回空指针以表示内存不足的情况。否则，我们将更新<code>next</code>地址，并像以前一样将<code>allocations</code>计数器加1。最后返回转换为<code>*mut u8</code>指针的<code>alloc_start</code>地址。</p>
<p><code>dealloc</code>函数将忽略给定的指针和<code>Layout</code>参数。它仅用于为<code>allocations</code>计数器减1。如果计数器再次归<code>0</code>，则意味着所有分配都已被释放。在这种情况下，它将<code>next</code>地址重置为<code>heap_start</code>地址，以使完整的堆内存再次可用。</p>
<h4 id="地址对齐"><a href="#地址对齐" class="headerlink" title="地址对齐"></a>地址对齐</h4><p><code>align_up</code>函数非常通用，可以将其放入父级模块<code>allocator</code>中。其实现如下：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 将给定的`addr`向上对齐到`align`</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">align_up</span></span>(addr: <span class="built_in">usize</span>, align: <span class="built_in">usize</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> remainder = addr % align;</span><br><span class="line">    <span class="keyword">if</span> remainder == <span class="number">0</span> &#123;</span><br><span class="line">        addr <span class="comment">// `addr`已对齐</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addr - remainder + align</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数首先结算<code>addr</code>除以<code>align</code>的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Euclidean_division">余数</a>。如果余数为<code>0</code>，则地址已经与给定的参数对齐。否则，我们通过减去余数（这样新的余数为0）然后加上对齐参数（保证新地址不会变得小于原地址）来对齐地址。</p>
<p>请注意，这并不是实现此函数最高效的实现。更快的实现如下所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 将给定的`addr`向上对齐到`align`</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// 要求`align`是2的幂</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">align_up</span></span>(addr: <span class="built_in">usize</span>, align: <span class="built_in">usize</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    (addr + align - <span class="number">1</span>) &amp; !(align - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数利用<code>GlobalAlloc</code>trait确保<code>align</code>始终是2的幂。这样就可以非常高效的通过创建<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Mask_(computing)">位掩码</a>的方式来执行地址对齐。让我们从右往左一步一步理解其工作原理：</p>
<ul>
<li>由于<code>align</code>是2的幂，因此它的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Binary_number#Representation">二进制表示</a>只会有一位被置为1（例如<code>0b000100000</code>）。这意味着<code>align-1</code>操作会将所有低位置为1（例如<code>0b00011111</code>）。</li>
<li>通过<code>!</code>执行<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bitwise_operation#NOT">按位<code>NOT</code></a>运算，我们得到一个除低于<code>align</code>的位外（例如<code>0b…111111111100000</code>）其余位均置为1的数字。</li>
<li>通过对地址和<code>!(align-1)</code>进行<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bitwise_operation#AND">按位<code>AND</code></a>，地址将<em>向下</em>对齐，即清除所有低于<code>align</code>的位。</li>
<li>由于需要的是要向上对齐而不是向下对齐，因此在执行按位与运算之前，需要给<code>addr</code>增加<code>align-1</code>。如此，已对齐的地址将保持不变，而未对齐的地址将在下一个对齐边界处取整。</li>
</ul>
<p>你可以选择任意一种实现方式，它们的计算结果是相同的。</p>
<h3 id="使用线性分配器"><a href="#使用线性分配器" class="headerlink" title="使用线性分配器"></a>使用线性分配器</h3><p>要使用线性分配器而不是<code>linked_list_allocator</code>crate，我们需要修改<code>allocator.rs</code>中的静态变量<code>ALLOCATOR</code>：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> bump::BumpAllocator;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[global_allocator]</span></span><br><span class="line"><span class="keyword">static</span> ALLOCATOR: Locked&lt;BumpAllocator&gt; = Locked::new(BumpAllocator::new());</span><br></pre></td></tr></table></figure>

<p>注意，这里的<code>BumpAllocator::new</code>和<code>Locked::new</code>均已声明为<code>const</code>函数。如果它们是普通函数，则会发生编译错误，因为<code>static</code>变量的初始化表达式必须在编译期求值。</p>
<p>我们不需要在<code>init_heap</code>函数中修改<code>ALLOCATOR.lock().init(HEAP_START, HEAP_SIZE)</code>调用，因为线性分配器提供的接口与<code>linked_list_allocator</code>相同。</p>
<p>现在内核使用了线性分配器！原来的代码应该仍然有效，包括我们在上一篇文章中创建的<a target="_blank" rel="noopener" href="https://os.phil-opp.com/heap-allocation/#adding-a-test"><code>heap_allocation</code>测试</a>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; cargo <span class="built_in">test</span> --<span class="built_in">test</span> heap_allocation</span><br><span class="line">[…]</span><br><span class="line">Running 3 tests</span><br><span class="line">simple_allocation... [ok]</span><br><span class="line">large_vec... [ok]</span><br><span class="line">many_boxes... [ok]</span><br></pre></td></tr></table></figure>

<h3 id="关于线性分配器的讨论"><a href="#关于线性分配器的讨论" class="headerlink" title="关于线性分配器的讨论"></a>关于线性分配器的讨论</h3><p>线性分配的最大优点是效率极高。与需要主动寻找合适的内存块并在<code>alloc</code>和<code>dealloc</code>上执行各种跟踪记录任务的其他分配器设计（参见下文）相比，线性分配器甚至可以<a target="_blank" rel="noopener" href="https://fitzgeraldnick.com/2019/11/01/always-bump-downwards.html">被优化</a>为一组汇编指令。因此，在分配器性能优化任务中，线性分配器就十分有用，例如在创建虚拟DOM库时。</p>
<p>不过线性分配器很少被当做全局分配器使用，它通常出现在“<a target="_blank" rel="noopener" href="https://mgravell.github.io/Pipelines.Sockets.Unofficial/docs/arenas.html">分配竞技场</a>”中，即将多个独立的分配器组合在一起以提高性能。Rust中的竞技场分配器的一个实现是<a target="_blank" rel="noopener" href="https://docs.rs/toolshed/0.8.1/toolshed/index.html"><code>toolshed</code></a>。</p>
<h4 id="线性分配器的缺点"><a href="#线性分配器的缺点" class="headerlink" title="线性分配器的缺点"></a>线性分配器的缺点</h4><p>线性分配器的主要局限性在于，它只有在释放了所有分配后才能重新使用释放的内存再次进行分配。这意味着一个长期独占的分配就足以拖延内存的重用。我们只需对<code>many_boxes</code>测试稍加修改就可以演示这个现象：</p>
<figure class="highlight rust"><figcaption><span>in tests/heap_allocation.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test_case]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">many_boxes_long_lived</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> long_lived = <span class="built_in">Box</span>::new(<span class="number">1</span>); <span class="comment">// new</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..HEAP_SIZE &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="built_in">Box</span>::new(i);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(*x, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(*long_lived, <span class="number">1</span>); <span class="comment">// new</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像<code>many_boxes</code>一样，此测试也会创建大量分配，如果分配器不重新使用释放的内存，将引发内存不足的错误。此外，测试会创建一个<code>long_lived</code>分配，该分配在整个循环执行期间均有效。</p>
<p>当我们尝试运行新测试时将发行测试确实失败了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; cargo <span class="built_in">test</span> --<span class="built_in">test</span> heap_allocation</span><br><span class="line">Running 4 tests</span><br><span class="line">simple_allocation... [ok]</span><br><span class="line">large_vec... [ok]</span><br><span class="line">many_boxes... [ok]</span><br><span class="line">many_boxes_long_lived... [failed]</span><br><span class="line"></span><br><span class="line">Error: panicked at <span class="string">&#x27;allocation error: Layout &#123; size_: 8, align_: 8 &#125;&#x27;</span>, src/lib.rs:86:5</span><br></pre></td></tr></table></figure>

<p>详细讨论一下测试为什么会失败：首先，在堆的开头创建<code>long_lived</code>分配，从而将<code>allocations</code>计数器加1。在每次循环中，都会创建一个短暂的分配并在下一次迭代开始之前就被释放。这意味着<code>allocations</code>计数器在迭代开始时临时增加到2，在迭代结束时减少为1。现在的问题是，线性分配器仅在所有分配释放后才可以重用内存，即<code>allocations</code>计数器减至0。不过这在整个循环完全结束之前都不会发生，因此每次循环迭代都将会分配出去一个新的内存块，从而使得内存在多次迭代后耗尽。</p>
<h4 id="修复这个测试？"><a href="#修复这个测试？" class="headerlink" title="修复这个测试？"></a>修复这个测试？</h4><p>有两个的技巧可以用来修复这个线性分配器的测试：</p>
<ul>
<li>我们可以修改<code>dealloc</code>，通过比较被释放内存的结束地址与<code>next</code>指针是否一致，来判断本次内存释放是否为刚刚才分配出去的内存。如果二者相等，我们可以安全地将<code>next</code>重置为刚刚被释放的分配的起始地址。如此，每次循环都将会重复同一个内存块。</li>
<li>我们也可以添加一个<code>alloc_back</code>方法，该方法使用额外的<code>next_back</code>字段从堆尾开始分配内存。然后，我们就可以为所有长期分配手动调用方法，从而在堆上将短期分配和长期分配分隔开。请注意，只有事先清楚每个分配的有效期限，才能使用这种分隔。该方法的另一个缺点是需要手动执行分配，麻烦且存在安全风险。</li>
</ul>
<p>虽然这两种方法都可以修复测试，但它们并不是通用的解决方案，因为它们都只能在非常特殊的情况下重用内存。问题是：是否有一个通用的解决方案可以重用所有已释放的内存？</p>
<h4 id="重用所有被释放的内存"><a href="#重用所有被释放的内存" class="headerlink" title="重用所有被释放的内存"></a>重用所有被释放的内存</h4><p>正如我们在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/heap-allocation/#dynamic-memory">上一篇文章</a>中了解到的那样，分配可能具有任意的生命周期，并且可以按照任意顺序释放。这意味着我们需要跟踪数量未知且非连续的未使用内存区域，如以下示例所示：</p>
<p><img src="https://os.phil-opp.com/allocator-designs/allocation-fragmentation.svg" alt="分配碎片"></p>
<p>上图显示了堆的分配状态随时间的变化。一开始，整个堆都是未使用的，此时<code>next</code>地址等于<code>heap_start</code>（第1行）。然后出现了第一次分配（第2行）。在第3行中，第二个存储块被分配出去，同时第一个分配被释放了。在第4行中新增了更多分配。其中一半有效期很短，它们在第5行中已被释放，而且在这一行中还新增了另一个分配。</p>
<p>第5行显示了一个基本问题：我们共有五个未使用的内存区域，它们的大小各不相同，但是<code>next</code>指针只能指向最后一个区域的开始。尽管对于本示例，我们可以将其他未使用的存储区域的起始地址和大小存储在大小为4的数组中，但这并不是一个通用的解决方案，因为我们同样可以轻松地创建一个包含8个、16个或1000个未使用的存储区域的例子。</p>
<p>通常，当我们需要处理数量未知的项目时，会倾向于使用在堆上进行分配的集合类型。但在现在并不可行，因为堆分配器不能依赖于自身（这将导致无限递归或死锁）。因此，我们需要找到其他解决方案。</p>
<h2 id="链表分配器"><a href="#链表分配器" class="headerlink" title="链表分配器"></a>链表分配器</h2><p>在实现分配器时，跟踪任意数量的空闲内存区域的常见技巧，就是将这些区域本身用作后备存储。这利用了一个事实：这些已释放的内存区域仍被映射到虚拟地址上，其背后都有一个对应的物理帧，但是我们已经不再需要其上存储的信息了。通过使用区域本身存储该区域相关的内存释放信息，我们就可以跟踪任意数量的释放区域，而无需额外的内存。</p>
<p>最常见的实现方法是在释放的内存中构造一个链表，每个节点都是一个已释放的内存区域：</p>
<p><img src="https://os.phil-opp.com/allocator-designs/linked-list-allocation.svg" alt="链表分配"></p>
<p>每个列表节点包含两个字段：此内存区域的大小和指向下一个未使用的内存区域的指针。使用这种方法，我们只需要那个指向第一个未使用区域的指针（称为<code>head</code>）即可跟踪所有未使用区域，而与它们的数量无关。产生的数据结构通常称为<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Free_list"><em>空闲列表</em></a>。</p>
<p>你可能已经从名称中猜到，这正是<code>linked_list_allocator</code>crate使用的技术。使用此技术的分配器通常也被称为<em>池分配器</em>。</p>
<h3 id="实现链表分配器"><a href="#实现链表分配器" class="headerlink" title="实现链表分配器"></a>实现链表分配器</h3><p>接下来，我们将使用上述跟踪已释放的内存区域的方法，自己实现一个简单的<code>LinkedListAllocator</code>类型。以后的文章并不需要这一部分的内容，因此你可以根据需要选择跳过实现细节。</p>
<h4 id="分配器类型"><a href="#分配器类型" class="headerlink" title="分配器类型"></a>分配器类型</h4><p>我们首先在新的<code>allocator::linked_list</code>子模块中创建一个私有<code>ListNode</code>结构：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> linked_list;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><figcaption><span>in src/allocator/linked_list.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span> &#123;</span><br><span class="line">    size: <span class="built_in">usize</span>,</span><br><span class="line">    next: <span class="built_in">Option</span>&lt;&amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> ListNode&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像在上图中描述的那样，列表节点具有一个<code>size</code>字段和一个指向下一个节点的可选指针，由<code>Option&lt;&amp;&#39;static mut ListNode&gt;</code>类型表示。静态<code>mut</code>类型在语义上描述了指针<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">拥有</a>其后指向的对象。这就基本上就是一个<code>Box</code>类型，只不过它没有能够在作用域末尾释放持有对象的析构函数。</p>
<p>我们为<code>ListNode</code>实现下列方法：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator/linked_list.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> ListNode &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(size: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        ListNode &#123; size, next: <span class="literal">None</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">start_addr</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="keyword">as</span> *<span class="keyword">const</span> <span class="keyword">Self</span> <span class="keyword">as</span> <span class="built_in">usize</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">end_addr</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.start_addr() + <span class="keyword">self</span>.size</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类型具有一个简单的构造函数<code>new</code>，以及用于计算所表示内存区域的开始地址和结束地址的方法。我们将新函数设为<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/reference/items/functions.html#const-functions">const函数</a>，因为稍后会在构造静态链表分配器时使用到它。请注意，在const函数中使用可变引用（包括将<code>next</code>字段设置为<code>None</code>）仍然不稳定。为了能够编译，我们需要在<code>lib.rs</code>的开头添加<code>#![feature(const_mut_refs)]</code>。</p>
<p>我们现在可以使用<code>ListNode</code>结构作为积木，来创建<code>LinkedListAllocator</code>结构体：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator/linked_list.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkedListAllocator</span></span> &#123;</span><br><span class="line">    head: ListNode,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> LinkedListAllocator &#123;</span><br><span class="line">    <span class="comment">/// 创建一个空的`LinkedListAllocator`.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">const</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            head: ListNode::new(<span class="number">0</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 使用给定的堆边界初始化分配器</span></span><br><span class="line">    <span class="comment">/// </span></span><br><span class="line">    <span class="comment">/// 该方法为非安全，因为调用者必须保证提供的内存范围未被使用。</span></span><br><span class="line">    <span class="comment">/// 同时，该方法只能被调用一次。</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">init</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, heap_start: <span class="built_in">usize</span>, heap_size: <span class="built_in">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.add_free_region(heap_start, heap_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 将给定的内存区域添加至链表前端</span></span><br><span class="line">    <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_free_region</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, addr: <span class="built_in">usize</span>, size: <span class="built_in">usize</span>) &#123;</span><br><span class="line">        todo!();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体包含一个<code>head</code>节点，指向第一个堆区域。我们只对<code>next</code>指针的值感兴趣，因此在<code>ListNode::new</code>函数中将大小设为0。将<code>head</code>设置为<code>ListNode</code>而不是仅使用<code>&amp;&#39;static mut ListNode</code>的优点是相应的<code>alloc</code>方法的实现将会更加简单。</p>
<p>就像线性分配器一样，<code>new</code>函数并不会直接使用堆边界来初始化分配器。除了希望保持API兼容性之外，原因还在于初始化过程需要将一个节点写入堆内存，这只能在运行时发生。然而，<code>new</code>函数必须是可以在编译时求值的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/reference/items/functions.html#const-functions"><code>const</code>函数</a>，因为它将用于初始化静态变量<code>ALLOCATOR</code>。出于这个原因，我们仍然使用一个独立的非-常函数<code>init</code>。</p>
<p><code>init</code>方法使用<code>add_free_region</code>方法，稍后将展示其实现。现在，我们使用<code>todo!</code>宏提供一个总是panic的实现占位符。</p>
<h4 id="add-free-region方法"><a href="#add-free-region方法" class="headerlink" title="add_free_region方法"></a><code>add_free_region</code>方法</h4><p><code>add_free_region</code>方法为链表提供了基本的<em>push</em>操作。目前，我们仅在<code>init</code>中调用此方法，但它也将成为我们<code>dealloc</code>实现中的核心方法。请记住，当释放分配的内存区域时，将调用<code>dealloc</code>方法。为了跟踪此次释放产生的的未使用内存区域，我们希望将其push到链表中。</p>
<p><code>add_free_region</code>方法的实现如下：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator/linked_list.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> super::align_up;</span><br><span class="line"><span class="keyword">use</span> core::mem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> LinkedListAllocator &#123;</span><br><span class="line">    <span class="comment">/// 将给定的内存区域添加至链表前端</span></span><br><span class="line">    <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_free_region</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, addr: <span class="built_in">usize</span>, size: <span class="built_in">usize</span>) &#123;</span><br><span class="line">        <span class="comment">// 确保此空闲区域足以容纳一个`ListNode`</span></span><br><span class="line">        <span class="built_in">assert_eq!</span>(align_up(addr, mem::align_of::&lt;ListNode&gt;()), addr);</span><br><span class="line">        <span class="built_in">assert!</span>(size &gt;= mem::size_of::&lt;ListNode&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个新的`ListNode`并将其添加至链表前端</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> node = ListNode::new(size);</span><br><span class="line">        node.next = <span class="keyword">self</span>.head.next.take();</span><br><span class="line">        <span class="keyword">let</span> node_ptr = addr <span class="keyword">as</span> *<span class="keyword">mut</span> ListNode;</span><br><span class="line">        node_ptr.write(node);</span><br><span class="line">        <span class="keyword">self</span>.head.next = <span class="literal">Some</span>(&amp;<span class="keyword">mut</span> *node_ptr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法获取一个内存区域的地址和大小作为参数，将该区域添加到列表前端。首先要保证给定的内存区域具有存储<code>ListNode</code>所需的大小和对齐方式。然后再按照下图中的步骤创建节点并将其插入到列表中：</p>
<p><img src="https://os.phil-opp.com/allocator-designs/linked-list-allocator-push.svg" alt="链表分配器push"></p>
<p>步骤0显示了调用<code>add_free_region</code>前堆的状态。在步骤1中，使用图中标记为<code>freed</code>的内存区域作为参数调用该方法。初步检查后，该方法使用空闲区域大小作为参数，在其调用栈上创建了一个新<code>node</code>。然后，它使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/option/enum.Option.html#method.take"><code>Option::take</code></a>方法将新<code>node</code>的<code>next</code>指针设置为当前的头指针，并将头指针重置为<code>None</code>。</p>
<p>在步骤2中，该方法使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.pointer.html#method.write"><code>write</code></a>方法将新创建的<code>node</code>（译注：目前仍在调用栈中）写入空闲内存区域的开头。最后将<code>head</code>指针指向这个新节点。图中最后呈现出来的指针结构略显混乱，这是因为释放区域总是在列表的开头插入，不过如果我们跟随指针，就会从<code>head</code>指针开始依次到达每个空闲区域了。</p>
<h4 id="find-region函数"><a href="#find-region函数" class="headerlink" title="find_region函数"></a><code>find_region</code>函数</h4><p>链表的另一个基本操作是查找条目并将其从列表中移除。这是实现<code>alloc</code>方法所需的核心操作。我们通过以下方式将该操作实现为<code>find_region</code>方法：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator/linked_list.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> LinkedListAllocator &#123;</span><br><span class="line">    <span class="comment">/// 按照给定大小和对齐方式查找一个空闲内存区域</span></span><br><span class="line">    <span class="comment">/// 并将其从链表中删除</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// 返回一个包含`ListNode`和其开始地址的分配</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">find_region</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, size: <span class="built_in">usize</span>, align: <span class="built_in">usize</span>)</span><br><span class="line">        -&gt; <span class="built_in">Option</span>&lt;(&amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> ListNode, <span class="built_in">usize</span>)&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前链表节点的引用，会在每次迭代中更新</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> current = &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.head;</span><br><span class="line">        <span class="comment">// 在链表中查找一个足够大的内存区域</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> region) = current.next &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Ok</span>(alloc_start) = Self::alloc_from_region(&amp;region, size, align) &#123;</span><br><span class="line">                <span class="comment">// 该区域可以容纳所需的分配，则将该区域从链表中删除</span></span><br><span class="line">                <span class="keyword">let</span> next = region.next.take();</span><br><span class="line">                <span class="keyword">let</span> ret = <span class="literal">Some</span>((current.next.take().unwrap(), alloc_start));</span><br><span class="line">                current.next = next;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 该区域不可以容纳所需的分配，则继续下一轮迭代查找</span></span><br><span class="line">                current = current.next.as_mut().unwrap();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已经找不到合适的内存区域了</span></span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法使用一个<code>current</code>变量和一个<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code>循环</a>来遍历列表元素。首先，将<code>current</code>设置到（假的）<code>head</code>节点。然后，在每次迭代中，它都会更新为当前节点的<code>next</code>字段（在<code>else</code>块中）。如果该区域适合于具有给定大小和对齐方式的分配，则将该区域从链表中删除，并与<code>alloc_start</code>地址一起返回。</p>
<p>当<code>current.next</code>指针变为<code>None</code>时，循环退出。这意味着我们遍历了整个链表，却没并有找到适合于给定分配的区域。在这种情况下，我们将返回<code>None</code>。检查区域是否合适由<code>alloc_from_region</code>函数完成，我们将在稍后展示其实现。</p>
<p>先让我们更加详细地研究如何从列表中删除合适的区域：</p>
<p><img src="https://os.phil-opp.com/allocator-designs/linked-list-allocator-remove-region.svg" alt="链表分配器删除内存区域"></p>
<p>步骤0显示了链表指针调整之前的状态。<code>region</code>区域、<code>current</code>区域、<code>region.next</code>指针和<code>current.next</code>指针均已在图中标出。在步骤1中，使用<code>Option::take</code>方法将<code>region.next</code>和<code>current.next</code>指针都重置为<code>None</code>。原来的指针分别存储在局部变量<code>next</code>和<code>ret</code>中。</p>
<p>在步骤2中，将局部变量<code>next</code>指针赋给<code>current.next</code>指针，也就是原来的<code>region.next</code>指针。结果是<code>current</code>现在直接指向<code>region</code>之后的下一个区域，因此<code>region</code>就不再是链表中的元素了。最后将存储在局部变量<code>ret</code>中的指针返回。</p>
<h4 id="alloc-from-region函数"><a href="#alloc-from-region函数" class="headerlink" title="alloc_from_region函数"></a><em><code>alloc_from_region</code>函数</em></h4><p><code>alloc_from_region</code>函数返回给定内存区域是否适合于具有给定大小和对齐方式的分配。其实现如下：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator/linked_list.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> LinkedListAllocator &#123;</span><br><span class="line">    <span class="comment">/// 尝试使用给定内存区域，为给定大小和对齐方式的分配做出分配</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// 如果成功则返回分配的开始地址。</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">alloc_from_region</span></span>(region: &amp;ListNode, size: <span class="built_in">usize</span>, align: <span class="built_in">usize</span>)</span><br><span class="line">        -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">usize</span>, ()&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> alloc_start = align_up(region.start_addr(), align);</span><br><span class="line">        <span class="keyword">let</span> alloc_end = alloc_start.checked_add(size).ok_or(())?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> alloc_end &gt; region.end_addr() &#123;</span><br><span class="line">            <span class="comment">// 内存区域太小</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">Err</span>(());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> excess_size = region.end_addr() - alloc_end;</span><br><span class="line">        <span class="keyword">if</span> excess_size &gt; <span class="number">0</span> &amp;&amp; excess_size &lt; mem::size_of::&lt;ListNode&gt;() &#123;</span><br><span class="line">            <span class="comment">// 该内存区域的剩余部分太小，无法容纳一个`ListNode`</span></span><br><span class="line">            <span class="comment">// （这是必须的，因为分配动作会将该区域分为已使用和未使用两个部分）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">Err</span>(());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该区域适合于给定的分配</span></span><br><span class="line">        <span class="literal">Ok</span>(alloc_start)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，该函数使用我们之前定义的<code>align_up</code>函数和<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.usize.html#method.checked_add"><code>checked_add</code></a>方法来计算给定分配的起始地址和结束地址。若发生溢出，或结束地址在给定区域的结束地址之后，则给定区域过小，不适合给定分配，所以我们返回错误。</p>
<p>接下来，函数执行的检查可能不太直观。不过这个检查是必要的，因为在大多数情况下，给定区域不可能正好就适合给定分配，因此分配过后，该区域的一部分仍为未使用区域。而此次分配之后，该区域的这一空闲部分必须足够大，以存储其自己的ListNode。该检查将准确地验证：分配是否完全合适（<code>excess_size == 0</code>）或多余的大小是否足以存储一个<code>ListNode</code>。</p>
<h4 id="为链表分配器实现GlobalAlloc"><a href="#为链表分配器实现GlobalAlloc" class="headerlink" title="为链表分配器实现GlobalAlloc"></a>为链表分配器实现<code>GlobalAlloc</code></h4><p>使用<code>add_free_region</code>和<code>find_region</code>方法提供的基本操作，就可以实现<code>GlobalAlloc</code>trait了。与线性分配器一样，我们不直接为<code>LinkedListAllocator</code>实现trait，而是为封装类型<code>Locked&lt;LinkedListAllocator&gt;</code>实现trait。<a target="_blank" rel="noopener" href="https://os.phil-opp.com/allocator-designs/#a-locked-wrapper-type"><code>Locked</code>封装类型</a>使用自旋锁增加了内部可变性，这使我们可以修改分配器实例，尽管<code>alloc</code>和<code>dealloc</code>方法只使用了不可变引用<code>&amp;self</code>。</p>
<p>实现看起来像这样：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator/linked_list.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> super::Locked;</span><br><span class="line"><span class="keyword">use</span> alloc::alloc::&#123;GlobalAlloc, Layout&#125;;</span><br><span class="line"><span class="keyword">use</span> core::ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> GlobalAlloc <span class="keyword">for</span> Locked&lt;LinkedListAllocator&gt; &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">self</span>, layout: Layout) -&gt; *<span class="keyword">mut</span> <span class="built_in">u8</span> &#123;</span><br><span class="line">        <span class="comment">// 调整对齐布局</span></span><br><span class="line">        <span class="keyword">let</span> (size, align) = LinkedListAllocator::size_align(layout);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> allocator = <span class="keyword">self</span>.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>((region, alloc_start)) = allocator.find_region(size, align) &#123;</span><br><span class="line">            <span class="keyword">let</span> alloc_end = alloc_start.checked_add(size).expect(<span class="string">&quot;overflow&quot;</span>);</span><br><span class="line">            <span class="keyword">let</span> excess_size = region.end_addr() - alloc_end;</span><br><span class="line">            <span class="keyword">if</span> excess_size &gt; <span class="number">0</span> &#123;</span><br><span class="line">                allocator.add_free_region(alloc_end, excess_size);</span><br><span class="line">            &#125;</span><br><span class="line">            alloc_start <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u8</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ptr::null_mut()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">dealloc</span></span>(&amp;<span class="keyword">self</span>, ptr: *<span class="keyword">mut</span> <span class="built_in">u8</span>, layout: Layout) &#123;</span><br><span class="line">        <span class="comment">// 调整对齐布局</span></span><br><span class="line">        <span class="keyword">let</span> (size, _) = LinkedListAllocator::size_align(layout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.lock().add_free_region(ptr <span class="keyword">as</span> <span class="built_in">usize</span>, size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们西安从更简单的<code>dealloc</code>方法看起：首先执行一些布局调整，我们将在稍后进行解释，并通过在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/allocator-designs/#a-locked-wrapper-type"><code>Locked</code>封装</a>上调用<a target="_blank" rel="noopener" href="https://docs.rs/spin/0.5.0/spin/struct.Mutex.html#method.lock"><code>Mutex::lock</code></a>函数来获取分配器的可变引用<code>&amp;mut LinkedListAllocator</code>。然后调用<code>add_free_region</code>函数将释放的区域添加到空闲链表中。</p>
<p><code>alloc</code>方法有点复杂。类似的，先进行布局调整，再调用<a target="_blank" rel="noopener" href="https://docs.rs/spin/0.5.0/spin/struct.Mutex.html#method.lock"><code>Mutex::lock</code></a>函数以获取分配器的可变引用。然后使用<code>find_region</code>找到适合这次分配的内存区域，并将其从空闲链表中删除。如果没找到返回<code>None</code>时，方法会因为没有合适的内存区域而返回<code>null_mut</code>，以表示分配错误。</p>
<p>在分配成功的情况下，<code>find_region</code>方法将返回包含合适区域（已从空闲链表中移除）和分配起始地址的元组。使用<code>alloc_start</code>、给定的分配大小、区域的结束地址，方法将重新计算分配的结束地址以及该区域的剩余大小。如果确实有剩余大小，方法将调用<code>add_free_region</code>将区域的剩余部分重新添加回空闲列表。最后将<code>alloc_start</code>地址转换为<code>*mut u8</code>类型并返回。</p>
<h4 id="布局调整"><a href="#布局调整" class="headerlink" title="布局调整"></a>布局调整</h4><p>那么，我们在<code>alloc</code>和<code>dealloc</code>开头都进行了哪些布局调整？其实就是为了确保每个分配的块都能够存储<code>ListNode</code>。这一点很重要，因为在某个时刻，该内存块将要被释放时，我们需要向其写入一个<code>ListNode</code>记录。如果该内存块小于<code>ListNode</code>或并没有正确的对齐，就会引发未定义行为。</p>
<p>布局调整由<code>size_align</code>函数执行，该函数实现如下：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator/linked_list.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> LinkedListAllocator &#123;</span><br><span class="line">    <span class="comment">/// 调整给定布局，使生成的用以分配的内存区域也能够存储`ListNode`。</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// 以元组`(size, align)`的形式返回调整后的大小和对齐方式。</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">size_align</span></span>(layout: Layout) -&gt; (<span class="built_in">usize</span>, <span class="built_in">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> layout = layout</span><br><span class="line">            .align_to(mem::align_of::&lt;ListNode&gt;())</span><br><span class="line">            .expect(<span class="string">&quot;adjusting alignment failed&quot;</span>)</span><br><span class="line">            .pad_to_align();</span><br><span class="line">        <span class="keyword">let</span> size = layout.size().max(mem::size_of::&lt;ListNode&gt;());</span><br><span class="line">        (size, layout.align())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，函数在传入的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/alloc/struct.Layout.html"><code>Layout</code></a>上调用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/alloc/struct.Layout.html#method.align_to"><code>align_to</code></a>方法，以在必要时为<code>ListNode</code>增加空间以对齐。然后使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/alloc/struct.Layout.html#method.pad_to_align"><code>pad_to_align</code></a>方法将布局大小向上对齐，以确保下一个内存块的起始地址也将具有正确的对齐方式，从而能再储一个<code>ListNode</code>。接下来，函数使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/cmp/trait.Ord.html#method.max"><code>max</code></a>方法强制所分配的大小至少要为<code>mem::size_of::&lt;ListNode&gt;</code>。如此，<code>dealloc</code>函数就可以安全地将<code>ListNode</code>写入已释放的内存块中了。</p>
<h3 id="使用链表分配器"><a href="#使用链表分配器" class="headerlink" title="使用链表分配器"></a>使用链表分配器</h3><p>现在，我们只需要在<code>allocator</code>模块中更新静态变量<code>ALLOCATOR</code>，就可以使用新的<code>LinkedListAllocator</code>了：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> linked_list::LinkedListAllocator;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[global_allocator]</span></span><br><span class="line"><span class="keyword">static</span> ALLOCATOR: Locked&lt;LinkedListAllocator&gt; =</span><br><span class="line">    Locked::new(LinkedListAllocator::new());</span><br></pre></td></tr></table></figure>

<p>由于线性分配器和链接列表分配器的<code>init</code>函数行为一致，因此我们无需修改<code>init_heap</code>中的<code>init</code>调用。</p>
<p>现在，当我们再次运行<code>heap_allocation</code>测试时，可以看到所有测试都通过了，其中包括在线性分配器中失败的<code>many_boxes_long_lived</code>测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; cargo <span class="built_in">test</span> --<span class="built_in">test</span> heap_allocation</span><br><span class="line">simple_allocation... [ok]</span><br><span class="line">large_vec... [ok]</span><br><span class="line">many_boxes... [ok]</span><br><span class="line">many_boxes_long_lived... [ok]</span><br></pre></td></tr></table></figure>

<p>这说明了我们的链表分配器能够将释放的内存重新用于后续分配。</p>
<h3 id="关于链表分配器的讨论"><a href="#关于链表分配器的讨论" class="headerlink" title="关于链表分配器的讨论"></a>关于链表分配器的讨论</h3><p>与线性分配器相比，链表分配器更适合作为通用分配器使用，主要是因为它能够立刻重用释放的内存。当然，链表分配器也有一些缺点。其中一部分是由于我们的实现过于简单引起的，另一些则是由于链表分配器的设计本身存在的固有缺陷。</p>
<h4 id="合并空闲块"><a href="#合并空闲块" class="headerlink" title="合并空闲块"></a>合并空闲块</h4><p>我们实现的主要问题是，它只会将堆拆分为越来越小的块，而不会再将小块合并成大块。考虑下面的例子：</p>
<p><img src="https://os.phil-opp.com/allocator-designs/linked-list-allocator-fragmentation-on-dealloc.svg" alt="链表分配器释放的碎片"></p>
<p>在第一行中，堆上创建了三个分配。它们中的两个在第2行中被释放，而第三个在第3行中被释放。现在虽然整个堆处于空闲状态，但仍旧被分成四个单独的块。此时，可能会由于四个块中的任何一个都不足够大，导致内核不能再进行大型分配了。随着时间的流逝，该过程将持续进行，并将堆分成越来越小的块。最后可能出现的情况就是，堆中的块过于分散过于小，使得哪怕正常大小的分配都无法进行了。</p>
<p>要解决此问题，我们需要将相邻的释放块重新合并在一起。对于上面的示例，这意味着：</p>
<p><img src="https://os.phil-opp.com/allocator-designs/linked-list-allocator-merge-on-dealloc.svg" alt="链表分配器释放后合并"></p>
<p>跟第一张图一样，第<code>2</code>行同样释放了三个分配中的两个。与第一张图不同的是，这次不在留着堆碎片不管，我们现在添加一个额外的<code>2a</code>行合并操作，将两个最右边的块重新合并在一起。在第<code>3</code>行中，第三个分配被释放（跟第一张图一样），从而产生由三个独立的块组成的一整个空闲的堆。同样的，我们再添加额外的<code>3a</code>行合并操作，将三个相邻的块重新合并成一整块未使用的堆。</p>
<p><code>linked_list_allocator</code>crate使用以下方式实现此合并策略：与我们的实现不同，该实现并不向列表前端插入<code>deallocate</code>释放的内存块，而是始终将列表按开始地址排序。这样，可以通过检查列表中两个相邻块的地址和大小，直接在<code>deallocate</code>调用时执行合并。当然，这种方式的释放速度稍慢，但是可以防止在我们的实现中出现的堆碎片。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>正如我们在前文了解到的，线性分配器非常快，可以被优化为一组汇编操作。链表分配器作为分配器，性能则要差很多。问题在于，分配请求可能需要遍历完整的链表才能找到合适的块。</p>
<p>由于链表长度取决于未使用的存储块的数量，因此对于不同的程序，其性能可能会发生极大的变化。对于仅创建几个分配的程序，其分配性能较好。但是，对于一个用很多分配将堆碎片化的程序，其分配性能将非常差，因为链表将变得很长，且可能包含非常多非常小的块。</p>
<p>值得注意的是，这个性能问题并不是因为我们的实现过于简单而引起的，这是链表分配器设计的固有缺陷。由于分配器的性能对于内核级代码极其重要，因此，我们将在下文中探讨第三种分配器设计，该设计以降低内存利用率为代价来提高的性能。</p>
<h2 id="固定大小的块分配器"><a href="#固定大小的块分配器" class="headerlink" title="固定大小的块分配器"></a>固定大小的块分配器</h2><p>接下来，我们将介绍一种使用固定大小的内存块来进行分配的分配器。这种分配器通常会返回大于分配所需的内存块，产生<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fragmentation_(computing)#Internal_fragmentation">内部碎片</a>从而导致一定的内存浪费。不过，它也大大降低了找到合适块所需的时间（与链表分配器相比），从而大幅提升分配性能。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>固定大小的块分配器的思路是：我们不再分配跟请求大小完全一致的块，而是定义少量种类的块，并为每一次分配选择一个大小向上取整的块。例如，我们可以定义16、64和512字节的块，分配需要4字节时就返回一个16字节的块，分配需要48字节时就返回一个64字节的块，而分配需要128字节时就返回一个512字节的块。</p>
<p>像链表分配器一样，我们通过在未使用的内存中创建链表来跟踪未使用的内存。不同的是，这次不是像链表分配器那样用一个链表来跟踪不同大小的块，而是为不同大小的块分别设置各自的跟踪链表。于是，每个链表仅存储同一种大小的块。例如，在定义了16、64和512字节块的情况下，内存中将存在三个单独的链表：</p>
<p><img src="https://os.phil-opp.com/allocator-designs/fixed-size-block-example.svg" alt="固定大小的块示例"></p>
<p>原先的链表分配器仅有一个<code>head</code>指针，现在有<code>head_16</code>、<code>head_64</code>和<code>head_512</code>三个了，它们分别指向各自对应大小的第一个未使用的块。而每个链表中的所有节点都具有相同的大小。例如，由<code>head_16</code>指针开始的链表仅包含16字节的块。这意味着我们不再需要在每个列表节点中存储块的大小，因为它已经由头指针的名称决定了。</p>
<p>由于链表中的每个节点都具有相同的大小，因此对一个分配请求来说，用链表中的哪个节点都是一样的。这意味着我们可以使用下列步骤非常有效地执行分配：</p>
<ul>
<li>将请求的分配大小向上取整到最接近的块大小。比如在请求分配12个字节时，按照上例，我们将选择分配一个大小为16的块。</li>
<li>（例如从数组中）取出链表的头指针。对于大小为16的块，我们需要用到<code>head_16</code>。</li>
<li>从链表中移除并返回第一个块。</li>
</ul>
<p>值得注意的是，此处仅需要返回链表的第一个元素，而不再需要遍历整个链表。因此，这种分配器会比链表分配器快得多。</p>
<h4 id="块大小与内存浪费"><a href="#块大小与内存浪费" class="headerlink" title="块大小与内存浪费"></a>块大小与内存浪费</h4><p>我们在取整时将浪费的多少内存，取决于块大小的设置。例如，当返回一个分配请求128字节而我们返回一个512字节的块时，分配出去的内存中有四分之三被浪费了。通过定义合理的块大小，可以在一定程度上限制浪费的内存。例如，当使用2的幂（4、8、16、32、64、128等）作为块大小时，在最坏的情况下也只会浪费一半的内存，平均而言仅浪费四分之一的内存。</p>
<p>基于程序中的公共分配尺寸来优化块大小也是很常见的。例如，我们可以额外增加大小为24的块，以提高经常执行24字节分配的程序的内存使用率。这样通常可以减少浪费的内存量，而且不会造成性能损失。</p>
<h4 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h4><p>像分配一样，释放也非常高效。它涉及以下步骤：</p>
<ul>
<li>将释放的分配大小向上取整到最接近的块大小。这是必需的，因为编译器传递给<code>dealloc</code>的并不是<code>alloc</code>返回的块的大小，而只是所请求的分配大小。通过在<code>alloc</code>和<code>dealloc</code>中使用相同的向上取整函数，就可以确保释放的内存量始终正确。</li>
<li>（例如从数组中）取出链表的头指针。</li>
<li>更新头指针，将释放的块添加到链表的前端。</li>
</ul>
<p>值得注意的是，释放过程也不需要遍历链表。这意味着无论链表有多长，<code>dealloc</code>调用所需的时间都是一个常量。</p>
<h4 id="后备分配器"><a href="#后备分配器" class="headerlink" title="后备分配器"></a>后备分配器</h4><p>鉴于大容量分配（大于2KB）通常是很少见的，尤其是在操作系统内核中，因此对于这些分配，使用不同的分配器可能也是合理的。例如，为了减少内存浪费，我们可以转而使用链表分配器，以进行大于2048字节的分配。因为这种尺寸的分配应该非常少，所以链表也将保持较小的状态，而分配/释放也仍将保持相当快的速度。</p>
<h4 id="创建新块"><a href="#创建新块" class="headerlink" title="创建新块"></a>创建新块</h4><p>前面我们始终假设特定大小的链表中始终有足够多的块来满足所有分配请求。但是，有时候某种大小的块的链表中没有多余的块了。此时，有两种方法可以创建特定大小的空闲新块来满足分配请求：</p>
<ul>
<li>从后备分配器中分配一个新块（如果有后备分配器的话）。</li>
<li>从其他链表中拆分更大的块。如果块大小设置为2的幂，那么此方法将最有效。例如，一个32字节的块可以分为两个16字节的块。</li>
</ul>
<p>在我们的实现中，将选择从后备分配器中分配新的块，因为这种实现要简单得多。</p>
<h3 id="实现固定大小的块分配器"><a href="#实现固定大小的块分配器" class="headerlink" title="实现固定大小的块分配器"></a>实现固定大小的块分配器</h3><p>现在我们知道了固定大小的块分配器是如何工作的，就可以着手实现它了。我们将不会依赖上一节中创建的链表分配器的实现，因此即使你跳过了链表分配器的实现，也可以正常阅读这一部分。</p>
<h4 id="链表节点"><a href="#链表节点" class="headerlink" title="链表节点"></a>链表节点</h4><p>我们通过在新的<code>allocator::fixed_size_block</code>模块中创建<code>ListNode</code>类型来开始实现：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> fixed_size_block;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><figcaption><span>in src/allocator/fixed_size_block.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span> &#123;</span><br><span class="line">    next: <span class="built_in">Option</span>&lt;&amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> ListNode&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类型很像我们在链表分配器中实现的<code>ListNode</code>类型，不同之处在于这里没有了第二个字段<code>size</code>。不需要<code>size</code>字段，是因为在固定大小的块分配器的设计思路中，同一个链表中的每个块大小都相同。</p>
<h4 id="块大小"><a href="#块大小" class="headerlink" title="块大小"></a>块大小</h4><p>接下来，我们定义一个常量切片<code>BLOCK_SIZES</code>，包含了实现中将会用到的块大小：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator/fixed_size_block.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 将会用到的块大小</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// 块大小必须是2的幂，因为它们也将用于块对齐</span></span><br><span class="line"><span class="comment">///（对齐方式必须为2的幂）</span></span><br><span class="line"><span class="keyword">const</span> BLOCK_SIZES: &amp;[<span class="built_in">usize</span>] = &amp;[<span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>];</span><br></pre></td></tr></table></figure>

<p>我们使用从8到2048的2的幂作为块大小。我们不定义任何小于8的块，因为每个块在被释放时必须能够存储指向下一个块的64位指针。对于大于2048字节的分配，我们将使用链表分配器。</p>
<p>为了简化实现，我们定义：一个块的大小也是其在内存中所需的对齐方式。因此，一个16字节的块始终在16字节的边界上对齐，而512字节的块始终在512字节的边界上对齐。由于对齐始终需要是2的幂，因此也排除了任何其他块大小。如果将来需要的块大小不是2的幂，我们仍然可以为此调整执行方式（例如，再定义一个<code>BLOCK_ALIGNMENTS</code>数组）。</p>
<h4 id="分配器类型-1"><a href="#分配器类型-1" class="headerlink" title="分配器类型"></a>分配器类型</h4><p>使用<code>ListNode</code>类型和<code>BLOCK_SIZES</code>切片，我们现在可以定义分配器类型：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator/fixed_size_block.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">FixedSizeBlockAllocator</span></span> &#123;</span><br><span class="line">    list_heads: [<span class="built_in">Option</span>&lt;&amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> ListNode&gt;; BLOCK_SIZES.len()],</span><br><span class="line">    fallback_allocator: linked_list_allocator::Heap,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>list_heads</code>字段是<code>head</code>指针的数组，每个块大小对应一个头指针。使用<code>BLOCK_SIZES</code>切片的<code>len()</code>作为数组长度创建数组。对于那些大于最大块尺寸的分配，我们使用<code>linked_list_allocator</code>提供的分配器作为后备分配器。当然，也可以改用我们自己实现的<code>LinkedListAllocator</code>，但是它并不会自动<a href="./#%E5%90%88%E5%B9%B6%E7%A9%BA%E9%97%B2%E5%9D%97">合并空闲块</a>。</p>
<p>为了构造一个<code>FixedSizeBlockAllocator</code>，我们依旧提供与其他类型分配器相同的<code>new</code>函数和<code>init</code>函数：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator/fixed_size_block.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> FixedSizeBlockAllocator &#123;</span><br><span class="line">    <span class="comment">/// 创建一个空的`FixedSizeBlockAllocator`.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">const</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> EMPTY: <span class="built_in">Option</span>&lt;&amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> ListNode&gt; = <span class="literal">None</span>;</span><br><span class="line">        FixedSizeBlockAllocator &#123;</span><br><span class="line">            list_heads: [EMPTY; BLOCK_SIZES.len()],</span><br><span class="line">            fallback_allocator: linked_list_allocator::Heap::empty(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 使用给定的堆边界初始化线性分配器</span></span><br><span class="line">    <span class="comment">/// </span></span><br><span class="line">    <span class="comment">/// 该方法为非安全，因为调用者必须保证提供的内存范围未被使用。</span></span><br><span class="line">    <span class="comment">/// 同时，该方法只能被调用一次。</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">init</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, heap_start: <span class="built_in">usize</span>, heap_size: <span class="built_in">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.fallback_allocator.init(heap_start, heap_size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新函数只是使用空节点初始化<code>list_heads</code>数组，并创建一个空链表分配器作为<code>fallback_allocator</code>。<code>EMPTY</code>必须为常量的原因是要告诉Rust编译器我们要使用常量值初始化数组。直接将数组初始化为<code>[None; BLOCK_SIZES.len()]</code>会有编译错误，因为之后编译器会要求<code>Option&lt;&amp;&#39;static mut ListNode&gt;</code>需要实现<code>Copy</code>trait，对于这点我们无能为力。这是目前的Rust编译器所具有的局限性，在未来的编译器中可能会解决这个问题。</p>
<p>如果你跳过了<code>LinkedListAllocator</code>的实现一节，则还需要在<code>lib.rs</code>的开头添加<code>#![feature(const_mut_refs)]</code>。原因是在<code>const</code>函数中使用可变引用类型仍然不稳定，包括<code>list_heads</code>字段的数组元素<code>Option&lt;&amp;&#39;static mut ListNode&gt;</code>类型（即使我们将其设置为<code>None</code>）也是如此。</p>
<p>非安全的<code>init</code>函数仅用于调用<code>fallback_allocator</code>的<a target="_blank" rel="noopener" href="https://docs.rs/linked_list_allocator/0.8.0/linked_list_allocator/struct.Heap.html#method.init"><code>init</code></a>函数，而无需对<code>list_heads</code>数组进行任何其他初始化。此后我们将在<code>alloc</code>和<code>dealloc</code>调用上延迟初始化该列表。</p>
<p>为了方便起见，我们还创建了一个私有的<code>fallback_alloc</code>方法，该方法使用<code>fallback_allocator</code>执行分配：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator/fixed_size_block.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> alloc::alloc::Layout;</span><br><span class="line"><span class="keyword">use</span> core::ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> FixedSizeBlockAllocator &#123;</span><br><span class="line">    <span class="comment">/// 使用后备分配器执行分配.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fallback_alloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, layout: Layout) -&gt; *<span class="keyword">mut</span> <span class="built_in">u8</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.fallback_allocator.allocate_first_fit(layout) &#123;</span><br><span class="line">            <span class="literal">Ok</span>(ptr) =&gt; ptr.as_ptr(),</span><br><span class="line">            <span class="literal">Err</span>(_) =&gt; ptr::null_mut(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>linked_list_allocator</code>crate的<a target="_blank" rel="noopener" href="https://docs.rs/linked_list_allocator/0.8.0/linked_list_allocator/struct.Heap.html"><code>Heap</code></a>类型无法实现<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html"><code>GlobalAlloc</code></a>（因为<a href="./#GlobalAlloc%E4%B8%8E%E5%8F%AF%E5%8F%98%E6%80%A7">不使用锁就不可能实现</a>）。而是提供了一个略有不同的接口的<code>allocate_first_fit</code>方法。它不返回<code>*mut u8</code>也不使用空指针来指示分配错误，而是返回<code>Result&lt;NonNull&lt;u8&gt;, ()&gt;</code>。 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/ptr/struct.NonNull.html"><code>NonNull</code></a>类型是是对那些能够保证自己是非空指针的裸指针的抽象。通过在匹配到<code>Ok</code>时返回<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/ptr/struct.NonNull.html#method.as_ptr"><code>NonNull::as_ptr</code></a>方法，匹配到<code>Err</code>时返回<code>null</code>指针，我们可以方便地将其转换回<code>*mut u8</code>类型。</p>
<h4 id="计算块大小列表索引"><a href="#计算块大小列表索引" class="headerlink" title="计算块大小列表索引"></a>计算块大小列表索引</h4><p>在实现<code>GlobalAlloc</code>trait之前，我们定义一个<code>list_index</code>帮助函数，用来返回适合给定<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/alloc/struct.Layout.html"><code>Layout</code></a>的最小块大小：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator/fixed_size_block.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 为给定的`layout`选择一个合适的块大小</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// 返回该块大小在`BLOCK_SIZES`中的索引</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">list_index</span></span>(layout: &amp;Layout) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">usize</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> required_block_size = layout.size().max(layout.align());</span><br><span class="line">    BLOCK_SIZES.iter().position(|&amp;s| s &gt;= required_block_size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>块必须至少具有给定<code>Layout</code>所需的大小和对齐方式。由于我们定义了块的大小也是它的对齐方式，因此这意味着<code>required_block_size</code>应为布局的<code>size()</code>和<code>align()</code>属性中的较大值。为了在<code>BLOCK_SIZES</code>切片中查找最接近向上取整的块大小，我们首先使用<code>iter()</code>方法获取迭代器，然后使用<code>position()</code>方法在切片中查找第一个不小于<code>required_block_size</code>的块的索引并返回该索引。</p>
<p>请注意，这里并不返回块大小本身，而是返回<code>BLOCK_SIZES</code>切片的索引。原因是我们还要使用该索引作为<code>list_heads</code>数组的索引。</p>
<h4 id="为固定大小的块分配器实现GlobalAlloc"><a href="#为固定大小的块分配器实现GlobalAlloc" class="headerlink" title="为固定大小的块分配器实现GlobalAlloc"></a>为固定大小的块分配器实现<code>GlobalAlloc</code></h4><p>最后一步是实现<code>GlobalAlloc</code>trait：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator/fixed_size_block.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> super::Locked;</span><br><span class="line"><span class="keyword">use</span> alloc::alloc::GlobalAlloc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> GlobalAlloc <span class="keyword">for</span> Locked&lt;FixedSizeBlockAllocator&gt; &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">self</span>, layout: Layout) -&gt; *<span class="keyword">mut</span> <span class="built_in">u8</span> &#123;</span><br><span class="line">        todo!();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">dealloc</span></span>(&amp;<span class="keyword">self</span>, ptr: *<span class="keyword">mut</span> <span class="built_in">u8</span>, layout: Layout) &#123;</span><br><span class="line">        todo!();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同其他分配器一样，我们仍不直接为分配器类型实现<code>GlobalAlloc</code>trait，而是使用<a target="_blank" rel="noopener" href="https://os.phil-opp.com/allocator-designs/#a-locked-wrapper-type"><code>Locked</code>封装</a>为其添加同步的内部可变性。由于<code>alloc</code>和<code>dealloc</code>的实现相对复杂，因此我们将在接下来的文章中逐一介绍它们。</p>
<h4 id="alloc"><a href="#alloc" class="headerlink" title="alloc"></a><code>alloc</code></h4><p><code>alloc</code>方法的实现如下所示：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator/fixed_size_block.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">self</span>, layout: Layout) -&gt; *<span class="keyword">mut</span> <span class="built_in">u8</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> allocator = <span class="keyword">self</span>.lock();</span><br><span class="line">    <span class="keyword">match</span> list_index(&amp;layout) &#123;</span><br><span class="line">        <span class="literal">Some</span>(index) =&gt; &#123;</span><br><span class="line">            <span class="keyword">match</span> allocator.list_heads[index].take() &#123;</span><br><span class="line">                <span class="literal">Some</span>(node) =&gt; &#123;</span><br><span class="line">                    allocator.list_heads[index] = node.next.take();</span><br><span class="line">                    node <span class="keyword">as</span> *<span class="keyword">mut</span> ListNode <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u8</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 链表中没有多余的块了，于是创建并分配新块</span></span><br><span class="line">                    <span class="keyword">let</span> block_size = BLOCK_SIZES[index];</span><br><span class="line">                    <span class="comment">// 这只在所有块大小均为2的幂时有效</span></span><br><span class="line">                    <span class="keyword">let</span> block_align = block_size;</span><br><span class="line">                    <span class="keyword">let</span> layout = Layout::from_size_align(block_size, block_align)</span><br><span class="line">                        .unwrap();</span><br><span class="line">                    allocator.fallback_alloc(layout)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">None</span> =&gt; allocator.fallback_alloc(layout),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来一步一步看：</p>
<p>首先调用<code>Locked::lock</code>方法获取对封装中的分配器实例的可变引用。然后调用刚刚定义的<code>list_index</code>函数来计算合适于给定布局的块大小，并尝试使用块大小索引从list_heads数组中取出对应链表的头指针。如果列表索引为<code>None</code>，则说明这次分配没有合适的块大小，于是使用<code>fallback_alloc</code>函数调用<code>fallback_allocator</code>进行分配。</p>
<p>如果列表索引为<code>Some</code>，就尝试使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/option/enum.Option.html#method.take"><code>Option::take</code></a>方法取出（译注：获取并移除）<code>list_heads[index]</code>所在的链表的第一个节点<code>node</code>。如果该链表不为空，则进入<code>match</code>语句的<code>Some(node)</code>分支，将该链表的头指针指向<code>node</code>的后继节点（也是使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/option/enum.Option.html#method.take"><code>take</code></a>）。最后，我们将取出的<code>node</code>以<code>*mut u8</code>指针的形式返回。</p>
<p>如果链表头指针为<code>None</code>，则表示该块大小对应的链表为空。这意味着我们需要按照<a href="./#%E5%88%9B%E5%BB%BA%E6%96%B0%E5%9D%97">上面</a>描述的那样创建一个新块。为此，我们首先从<code>BLOCK_SIZES</code>切片中获取该块大小的具体值，并将其用作新块的大小和对齐方式，再从中创建一个新的<code>Layout</code>，并调用<code>fallback_alloc</code>方法执行分配。之所以需要调整布局和对齐方式，是因为该块将在释放时会被添加到相应的块链表中。</p>
<h4 id="dealloc"><a href="#dealloc" class="headerlink" title="dealloc"></a><code>dealloc</code></h4><p><code>dealloc</code>方法的实现如下所示：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator/fixed_size_block.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> core::&#123;mem, ptr::NonNull&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在`unsafe impl GlobalAlloc`内</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">dealloc</span></span>(&amp;<span class="keyword">self</span>, ptr: *<span class="keyword">mut</span> <span class="built_in">u8</span>, layout: Layout) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> allocator = <span class="keyword">self</span>.lock();</span><br><span class="line">    <span class="keyword">match</span> list_index(&amp;layout) &#123;</span><br><span class="line">        <span class="literal">Some</span>(index) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> new_node = ListNode &#123;</span><br><span class="line">                next: allocator.list_heads[index].take(),</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 为存储的节点验证块大小和块对齐方式</span></span><br><span class="line">            <span class="comment">// verify that block has size and alignment required for storing node</span></span><br><span class="line">            <span class="built_in">assert!</span>(mem::size_of::&lt;ListNode&gt;() &lt;= BLOCK_SIZES[index]);</span><br><span class="line">            <span class="built_in">assert!</span>(mem::align_of::&lt;ListNode&gt;() &lt;= BLOCK_SIZES[index]);</span><br><span class="line">            <span class="keyword">let</span> new_node_ptr = ptr <span class="keyword">as</span> *<span class="keyword">mut</span> ListNode;</span><br><span class="line">            new_node_ptr.write(new_node);</span><br><span class="line">            allocator.list_heads[index] = <span class="literal">Some</span>(&amp;<span class="keyword">mut</span> *new_node_ptr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> ptr = NonNull::new(ptr).unwrap();</span><br><span class="line">            allocator.fallback_allocator.deallocate(ptr, layout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似<code>alloc</code>中的操作，首先调用<code>lock</code>方法获取分配器的可变引用，然后使用<code>list_index</code>函数获取与给定<code>Layout</code>大小相适应的块链表。如果索引为<code>None</code>，则<code>BLOCK_SIZES</code>中并没有合适的块大小，这说明该分配是由后备分配器创建的。因此，这里也应调用后备分配器的<a target="_blank" rel="noopener" href="https://docs.rs/linked_list_allocator/0.8.0/linked_list_allocator/struct.Heap.html#method.deallocate"><code>deallocate</code></a>来释放内存。该方法期望使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/ptr/struct.NonNull.html"><code>NonNull</code></a>而不是<code>*mut u8</code>，因此我们需要做指针转换。（仅当指针为空时，调用<code>unwrap</code>才会失败，而在编译器调用<code>dealloc</code>时这不可能发生。）</p>
<p>如果<code>list_index</code>返回一个块大小的索引，则需要将已释放的内存块添加到相应块大小的链表中。为此，我们首先创建一个指向当前链表头的新<code>ListNode</code>（仍然使用<code>Option::take</code>）。在将新节点写入释放的内存块之前，我们首先断言由<code>index</code>指定的块大小具有存储<code>ListNode</code>所需的大小和对齐方式。然后，我们通过将参数给定的<code>*mut u8</code>指针转换为<code>*mut ListNode</code>指针，并在其上调用非安全的<code>write</code>方法来将<code>new_node</code>写入内存块。最后一步是将列表的头部指针指向新建的<code>ListNode</code>，该链表的目前的指针为<code>None</code>，因为我们在前面使用<code>take</code>取走了原指针而留下一个<code>None</code>。为此，我们将裸指针<code>new_node_ptr</code>转换为一个可变引用。</p>
<p>这里有几点值得注意：</p>
<ul>
<li>我们不区分某个块究竟是从块链表分配的，还是从后备分配器中分配。这意味着将在<code>alloc</code>中创建的新块在<code>dealloc</code>时能够添加到相应的块链表中，从而增加该块大小链表中所包含的块数。</li>
<li>在我们的实现中，<code>alloc</code>方法是唯一能够创建新块的地方。这意味着我们初始化时仅有一系列空的块链表，且仅在执行针对特定块大小的分配时，才惰性填充相应的链表。</li>
<li>即使我们执行了一些<code>unsafe</code>操作，我们也不需要在<code>alloc</code>和<code>dealloc</code>中使用<code>unsafe</code>块。原因是Rust目前将整个非安全函数的函数体视为一个大的<code>unsafe</code>块。由于使用显式<code>unsafe</code>块的优点是很能够明显指出哪些操作是非安全的哪些操是安全的，因此已经有一个<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rfcs/pull/2585">RFC提案</a>讨论更改Rust当前的这种行为。</li>
</ul>
<h3 id="使用固定大小的块分配器"><a href="#使用固定大小的块分配器" class="headerlink" title="使用固定大小的块分配器"></a>使用固定大小的块分配器</h3><p>要使用新的<code>FixedSizeBlockAllocator</code>，我们需要在<code>allocator</code>模块中修改静态变量<code>ALLOCATOR</code>：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> fixed_size_block::FixedSizeBlockAllocator;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[global_allocator]</span></span><br><span class="line"><span class="keyword">static</span> ALLOCATOR: Locked&lt;FixedSizeBlockAllocator&gt; = Locked::new(</span><br><span class="line">    FixedSizeBlockAllocator::new());</span><br></pre></td></tr></table></figure>

<p>由于<code>init</code>函数在我们实现的所有分配器中均具有相同的行为，因此无需修改<code>init_heap</code>中的<code>init</code>调用。</p>
<p>现在，当我们再次运行<code>heap_allocation</code>测试时，所有测试仍应通过：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; cargo <span class="built_in">test</span> --<span class="built_in">test</span> heap_allocation</span><br><span class="line">simple_allocation... [ok]</span><br><span class="line">large_vec... [ok]</span><br><span class="line">many_boxes... [ok]</span><br><span class="line">many_boxes_long_lived... [ok]</span><br></pre></td></tr></table></figure>

<p>这个新分配器看起来也能够正常工作！</p>
<h3 id="关于固定大小的块分配器的讨论"><a href="#关于固定大小的块分配器的讨论" class="headerlink" title="关于固定大小的块分配器的讨论"></a>关于固定大小的块分配器的讨论</h3><p>尽管固定大小的块分配器性能好于链表分配器，但是当使用2的幂作为块大小时，它可能会浪费了多达一半的内存。至于这种权衡是否值得，在很大程度上取决于应用程序类型。对于性能至关重要的操作系统内核而言，固定大小的块分配器似乎是更好的选择。</p>
<p>在实现方面，我们可以在当前实现的基础上继续进行多项改进：</p>
<ul>
<li>与其使用后备分配器惰性分配块，不如在初始化时预先填充各链表，以提高初始的分配的性能。</li>
<li>为了简化实现，我们只允许块大小为2的幂，以便我们也可以将快大小也当做块对齐方式使用。通过以不同方式存储（或计算）对齐方式，我们还可以允许任意其他块大小。如此，我们就可以增加更多的块大小，例如为常见的分配建立块大小链表，以最大程度地减少内存浪费。</li>
<li>我们目前仅创建新的块，但不再释放它们，这将产生块碎片，最终可能会导致在进行大型分配时分配失败。为每个块大小强制设置最大链表长度可能也是合理的。当达到最大长度时，不应继续将其添加到链表中，而应当使用后备分配器直接将其彻底释放。</li>
<li>我们可以使用一个特殊的分配器来分配大于4KiB的内存，而不是使用后备的链表分配器。这个思路是利用大小恰好为4KiB的<a target="_blank" rel="noopener" href="https://os.phil-opp.com/paging-introduction/">内存分页</a>，将连续的虚拟内存块映射到非连续的物理帧。这样，未使用的内存碎片对于大型分配来说就不再是问题。</li>
<li>使用这样的页面分配器，可能有必要将块大小的上限提高到4KiB，并完全弃用链表分配器。这样的主要优点是减少了碎片并提高了性能可预测性，即在非理想情况下也能获取较好的性能。</li>
</ul>
<p>要注意，上面提出的这些仅仅是改进建议。操作系统内核中使用的分配器通常会针对内核的特定工作负载进行高度优化，这只有通过广泛的性能分析才能实现。</p>
<h3 id="其他分配器变体"><a href="#其他分配器变体" class="headerlink" title="其他分配器变体"></a>其他分配器变体</h3><p>固定大小的块分配器设计也有很多变体。<em>slab分配器</em>和<em>伙伴分配器</em>是两个流行的示例，它们也用在诸如Linux之类的流行内核中。下面，我们对这两种设计进行简短介绍。</p>
<h4 id="Slab分配器"><a href="#Slab分配器" class="headerlink" title="Slab分配器"></a>Slab分配器</h4><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Slab_allocation">Slab分配器</a>的思路是使用直接使用内核选定类型的大小作文的块大小。这样，对于这些类型的分配将恰好适合块大小，且不会浪费内存。有时，甚至有可能在未使用的块中预先初始化某些类型实例，以进一步提高性能。</p>
<p>Slab分配器通常与其他分配器结合使用。例如，它可以与固定大小的块分配器一起使用，以进一步拆分分配的块，从而减少内存浪费。此外，它还经常用于在单个大型分配时实现<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object_pool_pattern">对象池模式</a>。</p>
<h4 id="伙伴分配器"><a href="#伙伴分配器" class="headerlink" title="伙伴分配器"></a>伙伴分配器</h4><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Buddy_memory_allocation">伙伴分配器</a>不是使用链表，而是使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Binary_tree">二叉树</a>来管理释放的块，同时配合使用2的幂作为块大小。当需要一定大小的新块时，它将一个较大的块分成两半，从而在树中创建两个子节点。每当释放一个块时，都会分析树中的邻居块。如果邻居也是空闲块，则将这两个块合并，重新成为双倍大小的块。</p>
<p>此合并过程的优点是减少了<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fragmentation_(computing)#External_fragmentation">外部碎片</a>，于是那些较小的释放块就可以重新用于较大的分配了。此外，它无需使用后备分配器，因此其性能更加可预测。它最大的缺点是只能使用2幂作为块大小，这可能会由于<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fragmentation_(computing)#Internal_fragmentation">内部碎片</a>而导致大量的内存浪费。因此，伙伴分配器通常与slab分配器一起使用，以将分配的块进一步拆分为多个较小的块。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章概述了不同的分配器设计。我们学习了如何实现基本的<a target="_blank" rel="noopener" href="https://os.phil-opp.com/allocator-designs/#bump-allocator">线性分配器</a>，它通过增加单个<code>next</code>指针来线性分配内存。虽然线性分配非常快，但是只有释放所有分配之后，它才能重新使用内存。因此，线性分配器很少用作全局分配器。</p>
<p>接下来，我们创建了一个<a target="_blank" rel="noopener" href="https://os.phil-opp.com/allocator-designs/#linked-list-allocator">链表分配器</a>，该分配器使用释放的内存块本身来存放节点并组成链表，即所谓的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Free_list">空闲链表</a>。该链表可以存储任意数量的大小不同的已释放块。尽管不会发生内存浪费，但是由于分配请求可能需要遍历整个列表，因此这种方法的性能很差。同时，我们的实现还遭受<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fragmentation_(computing)#External_fragmentation">外部碎片</a>的困扰，因为这个最小化的实现并不会将相邻的释放块重新合并在一起。</p>
<p>为了解决链表方法的性能问题，我们创建了一个<a target="_blank" rel="noopener" href="https://os.phil-opp.com/allocator-designs/#fixed-size-block-allocator">固定大小的块分配器</a>，该分配器预定义了一组固定的块大小。并为每个块大小设置一个单独的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Free_list">空闲链表</a>，因此分配与释放只需要在相应列表的前端执行插入/取出，因此速度非常快。由于每个分配都向上取整到最接近的块大小，所以会因为<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fragmentation_(computing)#Internal_fragmentation">内部碎片</a>而浪费一些内存。</p>
<p>还有更多具有权衡不同取舍的分配器设计。Slab分配器可以为常见的固定大小的结构优化出更好地分配，但并非在所有情况下都适用。伙伴分配器使用二叉树将释放的块合并回去，但是可能会浪费大量内存，因为它仅支持的块大小只能为2的幂。重要的是要记住，每一个内核实现都有一个独特的工作量，因此并没有一个对所有情况都能保持“最佳”的分配器设计。</p>
<h2 id="下期预告"><a href="#下期预告" class="headerlink" title="下期预告"></a>下期预告</h2><p>目前，我就使用本文作为内存管理实现的尾声。接下来，我们将从<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Thread_(computing)">线程</a>开始探索对<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computer_multitasking"><em>多任务</em></a>的支持。在随后的文章中，我们将探讨<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Multiprocessing">多进程</a>、<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Process_(computing)">进程</a>、以及<a target="_blank" rel="noopener" href="https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html">async/await</a>形式的协作式多任务处理。</p>
<h2 id="支持本项目"><a href="#支持本项目" class="headerlink" title="支持本项目"></a>支持本项目</h2><p>创建和<a target="_blank" rel="noopener" href="https://os.phil-opp.com/status-update/">维护</a>这个博客和相关库是一项繁重的工作，但我真的很喜欢。通过支持我，您可以让我在新内容、新功能和持续维护上投入更多时间。</p>
<p>支持我的最好方式是<a target="_blank" rel="noopener" href="https://github.com/sponsors/phil-opp">在GitHub上赞助我</a>，因为他们不收取任何中间费用。如果你喜欢其他平台，我也有<a target="_blank" rel="noopener" href="https://www.patreon.com/phil_opp">Patreon</a>和<a target="_blank" rel="noopener" href="https://donorbox.org/phil-opp">Donorbox</a>账户。后者是最灵活的，因为它支持多种货币和一次性捐款。</p>
<p>感谢您的支持！</p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Rust/">Rust</a><a class="link-muted mr-2" rel="tag" href="/tags/Operating-System/">Operating System</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatpay.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/04/14/writing-an-os-in-rust-4.1/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">使用Rust编写操作系统 - 4.1 - Async/Await</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/04/01/writing-an-os-in-rust-3.3/"><span class="level-item">使用Rust编写操作系统 - 3.3 - 内存堆分配</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><script src="https://utteranc.es/client.js" repo="zlotus/comment" issue-term="pathname" label="some-issue-label" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/opm_sq.png" alt="子实"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">子实</p><p class="is-size-6 is-block">程序员</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>陕西/西安</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">78</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">22</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zlotus" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com/qinzishi"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/Zealot_uS"><i class="fab fa-twitter"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.zhihu.com/people/zlotus" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Diary/"><span class="level-start"><span class="level-item">Diary</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">64</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Shell/"><span class="level-start"><span class="level-item">Shell</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Coroutines/"><span class="tag">Coroutines</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">30</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenCV/"><span class="tag">OpenCV</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Operating-System/"><span class="tag">Operating System</span><span class="tag">21</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Paper/"><span class="tag">Paper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">17</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Raspberry-Pi/"><span class="tag">Raspberry Pi</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag">29</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TensorFlow/"><span class="tag">TensorFlow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tokio/"><span class="tag">Tokio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZMQ/"><span class="tag">ZMQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ctpn/"><span class="tag">ctpn</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macOS/"><span class="tag">macOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/obsidion/"><span class="tag">obsidion</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%A5%E8%AE%B0/"><span class="tag">日记</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E8%B0%88/"><span class="tag">杂谈</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B/"><span class="tag">编程</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%84%9A%E6%9C%AC/"><span class="tag">脚本</span><span class="tag">4</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a><p class="is-size-7"><span>&copy; 2023 子实</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>