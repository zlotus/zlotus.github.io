<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>使用Rust编写操作系统 - 3.3 - 内存堆分配 - 子实</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="子实"><meta name="msapplication-TileImage" content="/img/avatar-o.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="子实"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="使用Rust编写操作系统 - 3.3 - 内存堆分配"><meta property="og:type" content="article"><meta property="og:title" content="使用Rust编写操作系统 - 3.3 - 内存堆分配"><meta property="og:url" content="https://zlotus.github.io/2021/04/01/writing-an-os-in-rust-3.3/"><meta property="og:site_name" content="子实"><meta property="og:description" content="使用Rust编写操作系统 - 3.3 - 内存堆分配"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://os.phil-opp.com/heap-allocation/call-stack.svg"><meta property="og:image" content="https://os.phil-opp.com/heap-allocation/call-stack-return.svg"><meta property="og:image" content="https://os.phil-opp.com/heap-allocation/call-stack-static.svg"><meta property="og:image" content="https://os.phil-opp.com/heap-allocation/call-stack-heap.svg"><meta property="og:image" content="https://os.phil-opp.com/heap-allocation/call-stack-heap-freed.svg"><meta property="og:image" content="https://os.phil-opp.com/heap-allocation/qemu-dummy-output.png"><meta property="og:image" content="https://os.phil-opp.com/heap-allocation/qemu-alloc-showcase.png"><meta property="article:published_time" content="2021-04-01T09:55:00.000Z"><meta property="article:modified_time" content="2021-04-01T09:55:00.000Z"><meta property="article:author" content="子实"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Operating System"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://os.phil-opp.com/heap-allocation/call-stack.svg"><meta property="twitter:creator" content="@Zealot_uS"><meta property="twitter:site" content="Zealot_uS"><link rel="publisher" href="+LotusQin"><meta property="fb:admins" content="qinzishi"><meta property="fb:app_id" content="qinzishi"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zlotus.github.io/2021/04/01/writing-an-os-in-rust-3.3/"},"headline":"使用Rust编写操作系统 - 3.3 - 内存堆分配","image":["https://os.phil-opp.com/heap-allocation/qemu-dummy-output.png","https://os.phil-opp.com/heap-allocation/qemu-alloc-showcase.png"],"datePublished":"2021-04-01T09:55:00.000Z","dateModified":"2021-04-01T09:55:00.000Z","author":{"@type":"Person","name":"子实"},"publisher":{"@type":"Organization","name":"子实","logo":{"@type":"ImageObject","url":"https://zlotus.github.io/img/opm_sq.png"}},"description":"使用Rust编写操作系统 - 3.3 - 内存堆分配"}</script><link rel="icon" href="/img/avatar-o.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/2014/07/09/about-me/">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-01T09:55:00.000Z" title="4/1/2021, 5:55:00 PM">2021-04-01</time>发表</span><span class="level-item"><time dateTime="2021-04-01T09:55:00.000Z" title="4/1/2021, 5:55:00 PM">2021-04-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a></span><span class="level-item">1 小时读完 (大约10843个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">使用Rust编写操作系统 - 3.3 - 内存堆分配</h1><div class="content"><article class="message message-immersive is-warning">
<div class="message-body">
<i class="fas fa-exclamation-triangle mr-2"></i>本文所有内容均为翻译，原文：<a target="_blank" rel="noopener" href="https://os.phil-opp.com/heap-allocation/">Heap Allocation</a>；原项目：<a target="_blank" rel="noopener" href="https://os.phil-opp.com/">Writing an OS in Rust</a>
</div>
</article>

<p>本文将为内核添加对堆分配的支持。首先将介绍动态内存机制，并展示Rust借用检查器如何防止常见的分配错误。然后将实现Rust的基础分配器接口，创建一个堆内存区域，并编写一个分配器crate。在本文结束时，内核将能够支持Rust内置<code>alloc</code>crate中的所有分配和收集类型。</p>
<span id="more"></span>

<p>这个博客是在<a target="_blank" rel="noopener" href="https://github.com/phil-opp/blog_os">GitHub</a>上公开开发的。如果你有任何问题或疑问，请在那里开一个issue。你也可以在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/heap-allocation/#comments">底部</a>留言。这篇文章的完整源代码可以在<a target="_blank" rel="noopener" href="https://github.com/phil-opp/blog_os/tree/post-10">post-10</a>分支中找到。</p>
<h2 id="局部变量和静态变量"><a href="#局部变量和静态变量" class="headerlink" title="局部变量和静态变量"></a>局部变量和静态变量</h2><p>当前，我们在内核中使用两种类型的变量：局部变量和<code>static</code>变量。局部变量存储在<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Call_stack">调用栈</a>中，并且仅在其所在的函数返回之前有效。静态变量存储在固定的内存位置，并且在程序的整个生命周期中始终有效。</p>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部变量存储在<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Call_stack">调用栈</a>中，这是一个支持<code>push</code>和<code>pop</code>操作的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">栈数据结构</a>。对于每个被调用的函数，编译器都将其参数、返回地址和局部变量压栈：</p>
<p><img src="https://os.phil-opp.com/heap-allocation/call-stack.svg" alt="调用栈"></p>
<p>上图中的例子展示了<code>outer</code>函数调用了<code>inner</code>函数之后的调用栈。可以看到调用栈先是包含了<code>outer</code>函数的局部变量。在<code>inner</code>函数被调用时，参数<code>1</code>和返回地址被压栈。接下来控制权转给了<code>inner</code>函数，并继续将其局部变量压栈。</p>
<p><code>inner</code>函数返回后，其位于调用栈中的相关部分弹栈，此时调用栈中仅剩下<code>outer</code>函数相关的局部变量：</p>
<p><img src="https://os.phil-opp.com/heap-allocation/call-stack-return.svg" alt="调用栈返回"></p>
<p>我们看到<code>inner</code>的局部变量仅在函数返回之前有效。当我们持有变量时间过长时——比如尝试返回对局部变量的引用时——Rust编译器就会强行生命周期并引发编译错误：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">inner</span></span>(i: <span class="built_in">usize</span>) -&gt; &amp;<span class="symbol">&#x27;static</span> <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> z = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    &amp;z[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（<a target="_blank" rel="noopener" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=6186a0f3a54f468e1de8894996d12819">使用play rust在线运行上面的代码</a>）</p>
<p>虽然本例中返回引用并无意义，但在某些情况下，我们希望变量比其所在函数的生命周期更长。我们已经在编写内核的过程中遇到了这种情况，比如在尝试<a target="_blank" rel="noopener" href="https://os.phil-opp.com/cpu-exceptions/#loading-the-idt">加载中断描述符表</a>时就不得不使用<code>static</code>变量来延长其生命周期。</p>
<h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>静态变量存储在栈以外的固定内存位置中。此存储位置由链接器在编译时分配并编码在可执行文件中。静态变量在程序的完整运行时内始终有效，因此它们具有<code>&#39;static</code>生命周期，并且始终可以被局部变量引用：</p>
<p><img src="https://os.phil-opp.com/heap-allocation/call-stack-static.svg" alt="调用栈和静态变量"></p>
<p>上图中的<code>inner</code>函数返回时，其在调用栈中的相关部分被析构。而静态变量位于一个独立的内存范围中，并不会被析构，因此<code>&amp;Z[1]</code>的引用在函数返回后仍然有效。</p>
<p>除了<code>&#39;static</code>生命周期以外，静态变量还有另一个有用的属性，即其内存位置在编译时就已确定，因此不需要引用就能够对其进行访问。我们利用该属性实现了<code>println</code>：通过在内部使用<a target="_blank" rel="noopener" href="https://os.phil-opp.com/vga-text-mode/#a-global-interface">静态<code>Writer</code></a>，即便不使用<code>&amp;mut Writer</code>引用也能够调用该宏。这在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/cpu-exceptions/#implementation">异常处理程序</a>中非常有用，因为在其中我们无法访问任何其他变量。</p>
<p>但是，静态变量的这个属性也带来了一个致命缺点：它们默认是只读的。Rust强制此规则是为了避免<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nomicon/races.html">数据竞争</a>，比如当两个线程同时修改一个静态变量时。修改静态变量的唯一方法是将其封装在<a target="_blank" rel="noopener" href="https://docs.rs/spin/0.5.2/spin/struct.Mutex.html"><code>Mutex</code></a>类型中，从而确保在任何时刻中仅存在一个<code>&amp;mut</code>引用。我们已经将<code>Mutex</code>用于<a target="_blank" rel="noopener" href="https://os.phil-opp.com/vga-text-mode/#spinlocks">静态VGA缓冲区<code>Writer</code></a>。</p>
<h2 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h2><p>结合使用局部变量和静态变量已经能够实现非常强大的功能，足以应付大多数用例了。但是，它们仍然具有一定的局限性：</p>
<ul>
<li>局部变量仅其所在的函数或块结束前有效。这是因为它们存在于调用栈中，并在上下文函数返回后被析构。</li>
<li>静态变量在程序的完整运行时内始终有效，因此无法在不再需要它们时回收和重用它们的内存。此外，它们的所有权语义不明确，且能够被任意函数访问，所以我们才会在需要修改时使用<code>Mutex</code>对其进行保护。</li>
</ul>
<p>局部变量和静态变量的另一个局限性，就是它们的大小固定，因此，遇到需要添加更多元素的情况时，它们将无法存储这些动态增长的集合。（Rust中有一些关于<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/issues/48055">unsized rvalues</a>的提案，以允许局部变量具有动态大小，但它们仅在某些特定情况下有效。）</p>
<p>为了避开这些缺点，编程语言通常会提供第三块用于存放变量的内存区域，称为<strong>堆</strong>。堆使用两个叫做<code>allocate</code>和<code>deallocate</code>的函数在运行时动态内存分配。其工作方式为：<code>allocate</code>函数返回指定大小的可用内存块，用于存储变量。然后，该变量会一直有效，直到在其引用上调用<code>deallocate</code>函数将其释放为止。</p>
<p>让我们来看一个例子：</p>
<p><img src="https://os.phil-opp.com/heap-allocation/call-stack-heap.svg" alt="调用栈和堆"></p>
<p>在这里，<code>inner</code>函数使用堆内存而不是静态变量来存储<code>z</code>。首先按照所需大小分配内存块，然后返回<code>*mut u32</code><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer">裸指针</a>。然后使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/ptr/fn.write.html"><code>ptr::write</code></a>方法写入数组<code>[1,2,3]</code>。最后使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.pointer.html#method.offset"><code>offset</code></a>函数计算指向第<code>i</code>个元素的指针，并将其返回。（请注意，为简洁起见，在此示例函数中，我们省略了一些必需的强制转换和<code>unsafe</code>块。）</p>
<p>分配的内存将会一直有效，直到通过调用<code>dealloc</code>显式释放为止。因此，即使在<code>inner</code>返回且其相关部分的调用栈被析构之后，返回的指针依然有效。与静态内存相比，使用堆内存的优势在于内存可以在释放后重用，这是通过<code>outer</code>的<code>deallocate</code>调用实现的。调用结束后的情形如下：</p>
<p><img src="https://os.phil-opp.com/heap-allocation/call-stack-heap-freed.svg" alt="释放后的调用栈和堆"></p>
<p>可以看到<code>z[1]</code>所在堆中的位置又空闲了，可以重新用于下一次<code>allocate</code>调用。但是，还可以看到<code>z[0]</code>和<code>z[2]</code>从未释放，因为我们从未释放过它们。这种错误称为<em>内存泄漏</em>，也通常是导致程序过度消耗内存的原因（试想一下，当我们在循环中重复调用<code>inner</code>时会发生什么）。这看起来很不好，然而动态分配可能会导致更多种危险的错误。</p>
<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><p>内存泄漏虽然会导致过度消耗内存，但并不会使程序更容易受到攻击。除此之外，还有两种常见的错误类型，其后果更为严重：</p>
<ul>
<li>当我们在调用<code>deallocate</code>后意外地继续使用变量时，便产生了一个称作<strong>释放后使用</strong>的漏洞。这种漏洞会导致未定义的行为，此外，攻击者也经常通过该漏洞来执行任意代码。</li>
<li>当我们不小心两次释放变量时，便产生了一个<strong>双重释放</strong>漏洞。这是有问题的，因为它这可能会释放第一次调用<code>deallocate</code>后在该位置重新分配的变量。因此，它可能再次导致释放后使用漏洞。</li>
</ul>
<p>这些种类的漏洞是很常见的，看起来可以期望人们现在已经学会了如何规避它们。现实很遗憾，这些漏洞仍然经常出现，例如，近日<a target="_blank" rel="noopener" href="https://securityboulevard.com/2019/02/linux-use-after-free-vulnerability-found-in-linux-2-6-through-4-20-11/">Linux中出现的释放后使用漏洞</a>允许执行任意代码。这也表明即使是最优秀的程序员也不一定总是能够正确处理复杂项目中的动态内存。</p>
<p>为了规避这些漏洞，许多语言——例如Java或Python——都使用称为<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)"><em>垃圾回收</em></a>的技术自动管理动态内存。其意图是使程序员不再需要手动调用<code>deallocate</code>，转而使程序定期暂停并扫描未使用的堆变量，然后将它们自动释放。于是，上述漏洞也就不会再出现了。不过，其缺点是常规扫描有一定的性能开销，以及暂停的时间可能会较长。</p>
<p>针对此问题Rust采用了不同的解决方案：它使用一种称为<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html"><em>所有权</em></a>的概念，能够在编译时检查动态内存操作的正确性。因此，Rust不需要垃圾收集也能避免上述漏洞，这意味着没有性能开销。该方案的另一个优点是，程序员仍然可以像使用C或C++一样对动态内存进行细粒度的控制。</p>
<h3 id="Rust中的堆分配"><a href="#Rust中的堆分配" class="headerlink" title="Rust中的堆分配"></a>Rust中的堆分配</h3><p>Rust标准库提供了隐式调用<code>allocate</code>和<code>deallocate</code>抽象类型，省去程序员显示调用这些函数的麻烦。其中最重要的类型是<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/boxed/index.html"><code>Box</code></a>，它是堆分配值的抽象。该类提供了构造函数<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/boxed/struct.Box.html#method.new"><code>Box::new</code></a>，构造函数接受一个值并使用该值的大小调用<code>allocate</code>，再将该值移动到堆上新分配的空间中。为了能够释放堆内存，<code>Box</code>类型实现了<code>Drop</code>trait，以在变量离开作用域时调用<code>deallocate</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> z = <span class="built_in">Box</span>::new([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">    […]</span><br><span class="line">&#125; <span class="comment">// z离开作用域后，`deallocate`将被调用</span></span><br></pre></td></tr></table></figure>

<p>此模式具有一个奇怪的名字——<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">资源获取即初始化</a>（或简称RAII）。它起源于C++，用于实现类似的抽象类型<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/memory/unique_ptr"><code>std::unique_ptr</code></a>。</p>
<p>单靠这种类型不足以防止所有的释放后使用漏洞，因为在<code>Box</code>离开作用域并释放相应的堆内存空间之后，程序员仍然可以保留对其的引用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = &#123;</span><br><span class="line">    <span class="keyword">let</span> z = <span class="built_in">Box</span>::new([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">    &amp;z[<span class="number">1</span>]</span><br><span class="line">&#125;; <span class="comment">// z离开作用域后，`deallocate`将被调用</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br></pre></td></tr></table></figure>

<p>而这便是Rust所有权机制大放异彩之处。所有权会为每个引用分配一个抽象的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html">生命周期</a>，就是该引用的有效的范围。在上例中，<code>x</code>引用来自于<code>z</code>数组，因此在<code>z</code>离开作用域后将变得无效。在<a target="_blank" rel="noopener" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=28180d8de7b62c6b4a681a7b1f745a48">线运行上例</a>时，您将看到Rust编译器的确出现了编译错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error[E0597]: `z[_]` does not live long enough</span><br><span class="line"> --&gt; src/main.rs:4:9</span><br><span class="line">  |</span><br><span class="line">2 |     <span class="built_in">let</span> x = &#123;</span><br><span class="line">  |         - borrow later stored here</span><br><span class="line">3 |         <span class="built_in">let</span> z = Box::new([1,2,3]);</span><br><span class="line">4 |         &amp;z[1]</span><br><span class="line">  |         ^^^^^ borrowed value does not live long enough</span><br><span class="line">5 |     &#125;; // z goes out of scope and `deallocate` is called</span><br><span class="line">  |     - `z[_]` dropped here <span class="keyword">while</span> still borrowed</span><br></pre></td></tr></table></figure>

<p>此时看这些术语可能会有些混乱。在Rust中，引用一个值称为<em>借用</em>值，因为它类似于现实生活中的借东西：你可以临时访问某个对象，但需要在某个时刻将其归还，而且一定不可以析构它。通过确保所有借用在其原对象被析构之前生命周期便已结束，Rust编译器可以保证不会发生释放后使用的情况。</p>
<p>Rust的所有权机制非常强大，不仅可以防止释放后使用的漏洞，而且能够像Java或Python这样的垃圾收集语言一样提供完整的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memory_safety"><em>内存安全</em></a>。另外，它还能保证<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Thread_safety"><em>线程安全</em></a>，因此其多线程代码比这些垃圾收集语言的更安全。最重要的是，所有这些检查都在编译时进行，因此与C语言中的手写内存管理相比一样没有运行时开销。</p>
<h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><p>现在我们知道了Rust中动态内存分配的基础知识，但是要在什么时候应该使用动态内存呢？我们的内核在没有动态内存分配情况下也已经走得很远了，那么为什么现在又需要动态内存呢？</p>
<p>不过，动态内存分配总是会带来一些性能开销，因为我们需要为每一个分配在堆上找到一个尚未使用的位置。因此，通常情况下尽可能使用局部变量，尤其是在对性能要求极高的内核代码中。但是，在某些情况下，动态内存分配才是最佳选择。</p>
<p>作为基本规则，具有动态生命周期或可变大小的变量需要动态内存。动态生命周期最重要的类型是<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/rc/index.html"><strong><code>Rc</code></strong></a>，它对其内部封装值的引用进行计数，并在所有引用均超出作用域后将内部封装值释放。具有可变大小的类型的示例包括<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/vec/index.html"><strong><code>Vec</code></strong></a>、<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/string/index.html"><strong><code>String</code></strong></a>和其他<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/collections/index.html">集合类型</a>，这些集合类型在添加更多元素时将会动态增长。这些类型的工作原理是，当集合装满时重新分配更大的内存，再将所有元素复制过来，最后取消旧的内存分配。</p>
<p>在内核中，我们非常需要集合类型，比如后文中在实现多任务处理时，用于存储活动任务的列表。</p>
<h2 id="分配器接口"><a href="#分配器接口" class="headerlink" title="分配器接口"></a>分配器接口</h2><p>实现堆分配器的第一步是添加对内置<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/"><code>alloc</code></a> crate的依赖。像<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/"><code>core</code></a> crate一样，它也是标准库的子集，同时它还包含分配器和集合类型。要添加对<code>alloc</code>的依赖需要将以下内容添加到<code>lib.rs</code>中：</p>
<figure class="highlight rust"><figcaption><span>in src/lib.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> alloc;</span><br></pre></td></tr></table></figure>

<p>与添加普通依赖不同，我们并不需要修改<code>Cargo.toml</code>。原因是<code>alloc</code>crate与Rust编译器一起作为标准库的一部分供我们使用，因此编译器已经知道了该crate。通过添加此<code>extern crate</code>语句，我们指定编译器去尝试包含该crate。（在以前的Rust中，所有依赖项都需要一个<code>extern crate</code>语句，不过现在该语句是可选的）。</p>
<p>由于我们正在为自定义目标系统进行编译，因此无法使用随Rust一起安装的<code>alloc</code>预编译版本。此处，我们必须告诉cargo用源码重新编译该crate。这可以通过将该crate添加到<code>.cargo/config.toml</code>文件中的<code>unstable.build-std</code>数组中来实现：</p>
<figure class="highlight toml"><figcaption><span>in .cargo/config.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[unstable]</span></span><br><span class="line"><span class="attr">build-std</span> = [<span class="string">&quot;core&quot;</span>, <span class="string">&quot;compiler_builtins&quot;</span>, <span class="string">&quot;alloc&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>现在，编译器将重新编译<code>alloc</code>并其包括在内核中。</p>
<p>默认在<code>#[no_std]</code>的诸多crate中禁用<code>alloc</code>crate的原因是它还有其他要求。现在尝试编译项目时，我们可以看到这些要求引发的编译错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error: no global memory allocator found but one is required; link to std or add</span><br><span class="line">       <span class="comment">#[global_allocator] to a static item that implements the GlobalAlloc trait.</span></span><br><span class="line"></span><br><span class="line">error: `<span class="comment">#[alloc_error_handler]` function required, but not found</span></span><br></pre></td></tr></table></figure>

<p>发生第一个错误是因为<code>alloc</code>crate需要堆分配器，以提供具有<code>allocate</code>和<code>deallocate</code>函数的对象。在Rust中，堆分配器<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html"><code>GlobalAlloc</code></a> trait，如错误消息所示。要为crate提供堆分配器，必须为实现<code>GlobalAlloc</code>trait的<code>static</code>变量添加<code>#[global_allocator]</code>属性。</p>
<p>发生第二个错误是因为调用<code>allocate</code>可能会失败，最常见的情况是在没有更多内存可用时。我们的程序必须能够对这种情况做出反应，这就是<code>#[alloc_error_handler]</code>函数的作用。</p>
<p>在下文的各小节中，我们将详细描述这些特征和属性。</p>
<h3 id="GlobalAlloctrait"><a href="#GlobalAlloctrait" class="headerlink" title="GlobalAlloctrait"></a><code>GlobalAlloc</code>trait</h3><p><code>GlobalAlloc</code>trait定义了堆分配器必须提供的函数。该特性非常特殊，通常程序员不会使用到。而当程序员使用<code>alloc</code>中的分配器和集合类型时，编译器将自动将调用适当的trait函数。</p>
<p>由于我们将需要为所有分配器类型实现该trait，因此有必要仔细研究其声明：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="class"><span class="keyword">trait</span> <span class="title">GlobalAlloc</span></span> &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">self</span>, layout: Layout) -&gt; *<span class="keyword">mut</span> <span class="built_in">u8</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">dealloc</span></span>(&amp;<span class="keyword">self</span>, ptr: *<span class="keyword">mut</span> <span class="built_in">u8</span>, layout: Layout);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc_zeroed</span></span>(&amp;<span class="keyword">self</span>, layout: Layout) -&gt; *<span class="keyword">mut</span> <span class="built_in">u8</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">realloc</span></span>(</span><br><span class="line">        &amp;<span class="keyword">self</span>,</span><br><span class="line">        ptr: *<span class="keyword">mut</span> <span class="built_in">u8</span>,</span><br><span class="line">        layout: Layout,</span><br><span class="line">        new_size: <span class="built_in">usize</span></span><br><span class="line">    ) -&gt; *<span class="keyword">mut</span> <span class="built_in">u8</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该trait定义了两个必须实现的方法<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/"><code>alloc</code></a>与<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html#tymethod.dealloc"><code>dealloc</code></a>，并与我们在示例中使用的<code>allocate</code>和<code>deallocate</code>函数相对应：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/"><code>alloc</code></a>方法将<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/alloc/struct.Layout.html"><code>Layout</code></a>实例作为参数，该实例描述了所分配的内存应具有的大小和对齐方式。该方法返回一个<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer">裸指针</a>，并指向所分配内存块的第一个字节。当发生分配错误时，<code>alloc</code>方法返回一个空指针，而不是显式的错误值。虽然这有点不符合Rust的使用习惯，不过由于现有系统也使用相同的约定，所以其优点是可以很容易的封装现有的系统的分配器。</li>
<li><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html#tymethod.dealloc"><code>dealloc</code></a>方法是分配的另一半，它负责释放内存块。该方法接收两个参数，即<code>alloc</code>返回的指针和分配时用的<code>Layout</code>。</li>
</ul>
<p>该trait还使额外定义了两个带有默认实现的方法<code>alloc_zeroed</code>和<code>realloc</code>：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html#method.alloc_zeroed"><code>alloc_zeroed</code></a>方法等效于先调用<code>alloc</code>再将分配的内存块全部置为零，正如其默认实现中所做的那样。如果自定义实现比默认实现更高效的话，也可以使用它来覆盖默认实现。</li>
<li><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html#method.realloc"><code>realloc</code></a>方法允许增加或减少分配空间。默认实现会分配一个所需大小的新内存块，并会将先前分配中的所有内容复制进来。与上一个方法相同，自定义的分配器实现也可能会提供此一个更高效的实现，比如实现就地扩展/缩小原分配。</li>
</ul>
<h4 id="非安全特性"><a href="#非安全特性" class="headerlink" title="非安全特性"></a>非安全特性</h4><p>需要注意的是，trait本身的所有方法都被声明为<code>unsafe</code>：</p>
<ul>
<li>将该trait声明为<code>unsafe</code>的原因是，程序员必须保证分配器类型的trait实现是正确的。例如，<code>alloc</code>方法绝不能返回已在其他地方使用的内存块，因为这将导致未定义的行为。</li>
<li>同样，其方法均为<code>unsafe</code>的原因是，调用者在调用方法时必须确保各种不变性，例如，传递给<code>alloc</code>的<code>Layout</code>实例指定的大小应是非零的。不过在实践中这并不重要，因为方法通常是由编译器直接调用的，可以确保满足要求。</li>
</ul>
<h3 id="编写一个DummyAllocator"><a href="#编写一个DummyAllocator" class="headerlink" title="编写一个DummyAllocator"></a>编写一个<code>DummyAllocator</code></h3><p>既然已经知道了要为分配器类型提供什么，我们就可以实现一个简单的假分配器。首先创建一个新的分配器模块：</p>
<figure class="highlight rust"><figcaption><span>in src/lib.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> allocator;</span><br></pre></td></tr></table></figure>

<p>我们的假分配器将实现特征的最低要求，即在调用<code>alloc</code>时始终返回错误。看起来像这样：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> alloc::alloc::&#123;GlobalAlloc, Layout&#125;;</span><br><span class="line"><span class="keyword">use</span> core::ptr::null_mut;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Dummy</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> GlobalAlloc <span class="keyword">for</span> Dummy &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">self</span>, _layout: Layout) -&gt; *<span class="keyword">mut</span> <span class="built_in">u8</span> &#123;</span><br><span class="line">        null_mut()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">dealloc</span></span>(&amp;<span class="keyword">self</span>, _ptr: *<span class="keyword">mut</span> <span class="built_in">u8</span>, _layout: Layout) &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;dealloc should be never called&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该结构体不需要任何字段，于是我们将其创建为<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts">零大小类型</a>。就像描述的那样，我们总是用<code>alloc</code>返回空指针，这正对应了分配错误。由于分配器从不返回任何内存，所以永远不应该调用<code>dealloc</code>。因此，我们仅在<code>dealloc</code>中panic即可。<code>alloc_zeroed</code>和<code>realloc</code>方法具有默认实现，因此无需为其提供实现。</p>
<p>这就实现了一个简单的分配器，但是我们仍然需要告诉Rust编译器它应该使用这个分配器。这就需要用到<code>#[global_allocator]</code>属性了。</p>
<h3 id="global-allocator-属性"><a href="#global-allocator-属性" class="headerlink" title="#[global_allocator]属性"></a><code>#[global_allocator]</code>属性</h3><p><code>#[global_allocator]</code>将属性告诉Rust编译器应该使用哪个分配器实例作为全局堆分配器。该属性仅适用于实现了<code>GlobalAlloc</code>特性的<code>static</code>对象。让我们将分配器<code>Dummy</code>的一个实例注册为全局分配器：</p>
<figure class="highlight plaintext"><figcaption><span>src/allocator.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#[global_allocator]</span><br><span class="line">static ALLOCATOR: Dummy = Dummy;</span><br></pre></td></tr></table></figure>

<p>由于<code>Dummy</code>分配器是<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts">零大小类型</a>，因此我们不需要在初始化表达式中指定任何字段。</p>
<p>现在尝试编译，第一个错误消失了。让我们继续修复第二个错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: `<span class="comment">#[alloc_error_handler]` function required, but not found</span></span><br></pre></td></tr></table></figure>

<h3 id="alloc-error-handler-属性"><a href="#alloc-error-handler-属性" class="headerlink" title="#[alloc_error_handler]属性"></a><code>#[alloc_error_handler]</code>属性</h3><p>正如我们在讨论<code>GlobalAlloc</code>trait时所了解的那样，<code>alloc</code>函数可以通过返回空指针来表示分配错误。那么Rust在运行时应如何应对这种分配失败呢？这就是<code>#[alloc_error_handler]</code>属性起作用的地方了。该属性将指定发生分配错误时调用的处理函数，类似于在发生panic时调用panic处理程序。</p>
<p>我们来添加一个这样的函数以修复该编译错误：</p>
<figure class="highlight rust"><figcaption><span>in src/lib.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(alloc_error_handler)]</span> <span class="comment">// 需要写在源文件开头</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[alloc_error_handler]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">alloc_error_handler</span></span>(layout: alloc::alloc::Layout) -&gt; ! &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;allocation error: &#123;:?&#125;&quot;</span>, layout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>alloc_error_handler</code>函数仍然不稳定，因此我们需要一个特性门来启用它。该函数接收一个参数，即发生分配错误时传递给<code>alloc</code>的<code>Layout</code>实例。我们无法纠正该错误，因此仅在处理函数中进行panic并打印关于<code>Layout</code>实例的信息。</p>
<p>应用该函数就可以修复编译错误。现在我们可以使用<code>alloc</code>的分配器和集合类型了，例如，我们可以使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/boxed/struct.Box.html"><code>Box</code></a>在堆上分配一个值：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> alloc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> alloc::boxed::<span class="built_in">Box</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">kernel_main</span></span>(boot_info: &amp;<span class="symbol">&#x27;static</span> BootInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="comment">// […] print &quot;Hello World!&quot;, call `init`, create `mapper` and `frame_allocator`</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">Box</span>::new(<span class="number">41</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// […] call `test_main` in test mode</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;It did not crash!&quot;</span>);</span><br><span class="line">    blog_os::hlt_loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，我们也需要在<code>main.rs</code>中指定<code>extern crate alloc</code>语句。这是必需的，因为<code>lib.rs</code>和<code>main.rs</code>部分被视为各自独立的crate。但是，我们不需要创建另一个<code>#[global_allocator]</code>静态变量，因为全局分配器适用于项目中的所有crate。实际上，在另一个crate中指定其他分配器将引发错误。</p>
<p>运行上面的代码，我们将看到<code>alloc_error_handler</code>函数被调用：</p>
<p><img src="https://os.phil-opp.com/heap-allocation/qemu-dummy-output.png" alt="QEMU中假分配器的输出"></p>
<p>错误处理程序被调用是因为<code>Box::new</code>函数隐式调用了全局分配器的<code>alloc</code>函数。因为假分配器始终返回空指针，所以每次分配都将会失败。为了解决这个问题，我们需要创建一个真分配器，用以返回可以使用的内存。</p>
<h2 id="创建内核堆"><a href="#创建内核堆" class="headerlink" title="创建内核堆"></a>创建内核堆</h2><p>在创建适当的分配器之前，我们首先需要创建一个堆内存区域，使得分配器可以从该区域分配内存。为此，我们需要为堆区域定义一个虚拟内存范围，然后将该区域映射到物理帧上。有关虚拟内存和页表的介绍，请参见<a target="_blank" rel="noopener" href="https://os.phil-opp.com/paging-introduction/">“<em>内存分页简介</em>”</a>一文。</p>
<p>第一步是为堆定义虚拟内存区域。我们可以选择我们喜欢的任何虚拟地址范围，只要它尚未用于其他内存区域即可。让我们将其定义为从地址<code>0x_4444_4444_0000</code>开始的内存，以便未来可以轻松识别堆指针：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> HEAP_START: <span class="built_in">usize</span> = <span class="number">0x_4444_4444_0000</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> HEAP_SIZE: <span class="built_in">usize</span> = <span class="number">100</span> * <span class="number">1024</span>; <span class="comment">// 100 KiB</span></span><br></pre></td></tr></table></figure>

<p>目前将堆大小设置为100 KiB。如果将来我们需要更多空间，将该值改大即可。</p>
<p>如果我们现在尝试使用此堆区域，就会发生页面错误，因为虚拟内存区域尚未映射到物理内存。为了解决这个问题，我们创建<code>init_heap</code>函数并使用在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/paging-implementation/"><em>“内存分页实现”</em></a>一文中介绍的<a target="_blank" rel="noopener" href="https://os.phil-opp.com/paging-implementation/#using-offsetpagetable"><code>Mapper</code> API</a>映射堆页面：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> x86_64::&#123;</span><br><span class="line">    structures::paging::&#123;</span><br><span class="line">        mapper::MapToError, FrameAllocator, Mapper, Page, PageTableFlags, Size4KiB,</span><br><span class="line">    &#125;,</span><br><span class="line">    VirtAddr,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">init_heap</span></span>(</span><br><span class="line">    mapper: &amp;<span class="keyword">mut</span> <span class="keyword">impl</span> Mapper&lt;Size4KiB&gt;,</span><br><span class="line">    frame_allocator: &amp;<span class="keyword">mut</span> <span class="keyword">impl</span> FrameAllocator&lt;Size4KiB&gt;,</span><br><span class="line">) -&gt; <span class="built_in">Result</span>&lt;(), MapToError&lt;Size4KiB&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> page_range = &#123;</span><br><span class="line">        <span class="keyword">let</span> heap_start = VirtAddr::new(HEAP_START <span class="keyword">as</span> <span class="built_in">u64</span>);</span><br><span class="line">        <span class="keyword">let</span> heap_end = heap_start + HEAP_SIZE - <span class="number">1u64</span>;</span><br><span class="line">        <span class="keyword">let</span> heap_start_page = Page::containing_address(heap_start);</span><br><span class="line">        <span class="keyword">let</span> heap_end_page = Page::containing_address(heap_end);</span><br><span class="line">        Page::range_inclusive(heap_start_page, heap_end_page)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> page_range &#123;</span><br><span class="line">        <span class="keyword">let</span> frame = frame_allocator</span><br><span class="line">            .allocate_frame()</span><br><span class="line">            .ok_or(MapToError::FrameAllocationFailed)?;</span><br><span class="line">        <span class="keyword">let</span> flags = PageTableFlags::PRESENT | PageTableFlags::WRITABLE;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            mapper.map_to(page, frame, flags, frame_allocator)?.flush()</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数接受<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/mapper/trait.Mapper.html"><code>Mapper</code></a>和<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/trait.FrameAllocator.html"><code>FrameAllocator</code></a>实例的可变引用作为参数，这两个实例均使用<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/page/enum.Size4KiB.html"><code>Size4KiB</code></a>作为泛型参数指定页面大小为4KiB。该函数的返回值为<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/result/enum.Result.html"><code>Result</code></a>，以单位类型<code>()</code>作为成功结果，以<code>MapToError</code>作为失败结果，该失败结果是由<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/mapper/trait.Mapper.html#method.map_to"><code>Mapper::map_to</code></a>方法返回的错误类型。之所以在此处复用了该错误类型是因为<code>map_to</code>方法是此函数中错误的主要来源。</p>
<p>实现可以分为两部分：</p>
<ul>
<li><strong>创建页面范围</strong>：首先需要将<code>HEAP_START</code>指针转换为<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/addr/struct.VirtAddr.html"><code>VirtAddr</code></a>类型。然后用起始地址加上<code>HEAP_SIZE</code>计算出堆结束地址。我们想要一个闭区间（堆的最后一个字节的地址），故而减1。接下来使用<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/page/struct.Page.html#method.containing_address"><code>containing_address</code></a>函数将这些地址转换为<code>Page</code>类型。最后使用<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/page/struct.Page.html#method.range_inclusive"><code>Page::range_inclusive</code></a>函数创建从起始页面到结束页面的页面范围。</li>
<li><strong>映射页面</strong>：第二步是映射刚刚创建的页面范围内的所有页面。为此，我们使用<code>for</code>循环遍历该范围内的页面。我们为每个页面执行以下操作：<ul>
<li>使用<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/trait.FrameAllocator.html#tymethod.allocate_frame"><code>FrameAllocator::allocate_frame</code></a>方法将页面应映射到分配的物理帧上。当没有额外的帧时，该方法将返回<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/option/enum.Option.html#variant.None"><code>None</code></a>。遇到没有额外帧的情况时，我们使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/option/enum.Option.html#method.ok_or"><code>Option::ok_or</code></a>方法将错误映射到<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/mapper/enum.MapToError.html#variant.FrameAllocationFailed"><code>MapToError::FrameAllocationFailed</code></a>，然后接<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html">问号运算符</a>以在出错时提前返回。</li>
<li>为页面设置了必要的<code>PRESENT</code>和<code>WRITABLE</code>标志，以允许读取和写入访问，这对于堆内存是有实际意义的。</li>
<li>使用<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/mapper/trait.Mapper.html#method.map_to"><code>Mapper::map_to</code></a>方法在活动页面表中创建映射。该方法可能会失败，因此我们再次使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html">问号运算符</a>将错误传播给调用方。若成功，该方法将返回一个<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/mapper/struct.MapperFlush.html"><code>MapperFlush</code></a>实例，然后使用该实例使用<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/mapper/struct.MapperFlush.html#method.flush"><code>flush</code></a>方法来更新<a target="_blank" rel="noopener" href="https://os.phil-opp.com/paging-introduction/#the-translation-lookaside-buffer">转换后备缓冲区</a>。</li>
</ul>
</li>
</ul>
<p>最后一步是从<code>kernel_main</code>中调用此函数：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">kernel_main</span></span>(boot_info: &amp;<span class="symbol">&#x27;static</span> BootInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">use</span> blog_os::allocator; <span class="comment">// new import</span></span><br><span class="line">    <span class="keyword">use</span> blog_os::memory::&#123;<span class="keyword">self</span>, BootInfoFrameAllocator&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello World&#123;&#125;&quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    blog_os::init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> phys_mem_offset = VirtAddr::new(boot_info.physical_memory_offset);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> mapper = <span class="keyword">unsafe</span> &#123; memory::init(phys_mem_offset) &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> frame_allocator = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        BootInfoFrameAllocator::init(&amp;boot_info.memory_map)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new</span></span><br><span class="line">    allocator::init_heap(&amp;<span class="keyword">mut</span> mapper, &amp;<span class="keyword">mut</span> frame_allocator)</span><br><span class="line">        .expect(<span class="string">&quot;heap initialization failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">Box</span>::new(<span class="number">41</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// […] call `test_main` in test mode</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;It did not crash!&quot;</span>);</span><br><span class="line">    blog_os::hlt_loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码显示了函数完整的上下文。这里仅有的新增行是<code>blog_os::allocator</code>的导入和<code>allocator::init_heap</code>函数的调用。如果<code>init_heap</code>函数返回错误，我们将使用<code>Result::expect</code>方法产生panic，因为目前还没有适当的处理此错误的方法。</p>
<p>现在，我们有一个准备使用的映射堆内存区域。但是<code>Box::new</code>调用仍然使用旧的<code>Dummy</code>分配器，因此如果此时运行仍会看到“内存不足”错误。让我们通过使用适当的分配器来解决此问题。</p>
<h2 id="使用分配器crate"><a href="#使用分配器crate" class="headerlink" title="使用分配器crate"></a>使用分配器crate</h2><p>鉴于实现分配器较为复杂，我们先临时使用已有的分配器crate。在下一篇文章中，我们将学习如何实现自己的分配器。</p>
<p>对于<code>no_std</code>的应用程序，<a target="_blank" rel="noopener" href="https://github.com/phil-opp/linked-list-allocator/"><code>linked_list_allocator</code></a> crate是一个简单的分配器实现。之所以叫这个名字，是因为该crate使用链表数据结构来跟踪释放的内存区域。有关该实现的详情参见下一篇文章。</p>
<p>要使用该crate，首先需要在<code>Cargo.toml</code>中添加其依赖：</p>
<figure class="highlight toml"><figcaption><span>in Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">linked_list_allocator</span> = <span class="string">&quot;0.8.0&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后便可以使用该crate提供的分配器代替我们的假分配器了：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> linked_list_allocator::LockedHeap;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[global_allocator]</span></span><br><span class="line"><span class="keyword">static</span> ALLOCATOR: LockedHeap = LockedHeap::empty();</span><br></pre></td></tr></table></figure>

<p>该结构体叫做<code>LockedHeap</code>，是因为它使用<a target="_blank" rel="noopener" href="https://docs.rs/spinning_top/0.1.0/spinning_top/type.Spinlock.html"><code>spining_top::Spinlock</code></a>类型进行同步。这是必需的，因为多个线程可以同时访问<code>ALLOCATOR</code>静态对象。一如往常，在使用自旋锁或互斥锁时，我们需要注意不要意外引发死锁。这意味着我们不应该在中断处理程序中执行任何分配，因为它们可以在任意时间运行，并且可能会中断正在进行的分配。</p>
<p>仅将<code>LockedHeap</code>设置为全局分配器是不够的。原因是我们使用了构造函数<a target="_blank" rel="noopener" href="https://docs.rs/linked_list_allocator/0.8.0/linked_list_allocator/struct.LockedHeap.html#method.empty"><code>empty</code></a>，创建了一个没有任何后备内存的分配器。就像我们的假分配器一样，它总是在<code>alloc</code>时返回错误。为了解决这个问题，我们需要在创建堆之后初始化分配器：</p>
<figure class="highlight rust"><figcaption><span>in src/allocator.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">init_heap</span></span>(</span><br><span class="line">    mapper: &amp;<span class="keyword">mut</span> <span class="keyword">impl</span> Mapper&lt;Size4KiB&gt;,</span><br><span class="line">    frame_allocator: &amp;<span class="keyword">mut</span> <span class="keyword">impl</span> FrameAllocator&lt;Size4KiB&gt;,</span><br><span class="line">) -&gt; <span class="built_in">Result</span>&lt;(), MapToError&lt;Size4KiB&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// […] map all heap pages to physical frames</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// new</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        ALLOCATOR.lock().init(HEAP_START, HEAP_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在<code>LockedHeap</code>类型的内部自旋锁上使用<a target="_blank" rel="noopener" href="https://docs.rs/lock_api/0.3.3/lock_api/struct.Mutex.html#method.lock"><code>lock</code></a>方法来获取对封装后的<a target="_blank" rel="noopener" href="https://docs.rs/linked_list_allocator/0.8.0/linked_list_allocator/struct.Heap.html"><code>Heap</code></a>实例的排他引用，然后在该实例上调用以堆边界为参数的<a target="_blank" rel="noopener" href="https://docs.rs/linked_list_allocator/0.8.0/linked_list_allocator/struct.Heap.html#method.init"><code>init</code></a>方法。重要的是，我们在映射堆页面<em>之后</em>才初始化堆，因为<a target="_blank" rel="noopener" href="https://docs.rs/linked_list_allocator/0.8.0/linked_list_allocator/struct.Heap.html#method.init"><code>init</code></a>函数已经在尝试写入堆内存了。</p>
<p>初始化堆之后就可以使用内置<code>alloc</code>crate的所有分配和收集类型，而且并不会出现错误：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> alloc::&#123;boxed::<span class="built_in">Box</span>, vec, vec::<span class="built_in">Vec</span>, rc::Rc&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">kernel_main</span></span>(boot_info: &amp;<span class="symbol">&#x27;static</span> BootInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="comment">// […] initialize interrupts, mapper, frame_allocator, heap</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocate a number on the heap</span></span><br><span class="line">    <span class="keyword">let</span> heap_value = <span class="built_in">Box</span>::new(<span class="number">41</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;heap_value at &#123;:p&#125;&quot;</span>, heap_value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a dynamically sized vector</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> vec = <span class="built_in">Vec</span>::new();</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">500</span> &#123;</span><br><span class="line">        vec.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;vec at &#123;:p&#125;&quot;</span>, vec.as_slice());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a reference counted vector -&gt; will be freed when count reaches 0</span></span><br><span class="line">    <span class="keyword">let</span> reference_counted = Rc::new(<span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">let</span> cloned_reference = reference_counted.clone();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;current reference count is &#123;&#125;&quot;</span>, Rc::strong_count(&amp;cloned_reference));</span><br><span class="line">    core::mem::<span class="built_in">drop</span>(reference_counted);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;reference count is &#123;&#125; now&quot;</span>, Rc::strong_count(&amp;cloned_reference));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// […] call `test_main` in test context</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;It did not crash!&quot;</span>);</span><br><span class="line">    blog_os::hlt_loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码展示了<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/boxed/struct.Box.html"><code>Box</code></a>、<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/vec/"><code>Vec</code></a>和<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/rc/"><code>Rc</code></a>类型的部分使用。对于<code>Box</code>和<code>Vec</code>类型，我们使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/fmt/trait.Pointer.html"><code>&#123;:p&#125;</code>格式说明符</a>来打印底层堆指针。为了展示<code>Rc</code>，我们创建一个引用计数的堆值，并在删除实例（使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/mem/fn.drop.html">core::mem::drop</a>）前后分别使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/rc/struct.Rc.html#method.strong_count"><code>Rc::strong_count</code></a>函数两次打印引用计数。</p>
<p>运行将会看到以下内容：</p>
<p><img src="https://os.phil-opp.com/heap-allocation/qemu-alloc-showcase.png" alt="QEMU分配器示例"></p>
<p>不出所料，我们看到<code>Box</code>和<code>Vec</code>值存在于堆中，正如以<code>0x_4444_4444_*</code>为前缀的指针所指示。引用计数值也可以按预期方式运行，调用<code>clone</code>后，引用计数为2，在删除其中一个实例后，引用计数变为1。</p>
<p>向量从偏移量<code>0x800</code>开始的原因并不是<code>Box</code>类型的值大小为<code>0x800</code>字节，而是因为向量需要扩充容量时发生了<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#capacity-and-reallocation">再分配</a>。例如，当向量的容量为32且我们尝试添加下一个元素时，向量将在后台分配一个容量为64的新后备数组，并将所有元素复制到到新数组，然后再释放掉旧分配。</p>
<p>当然，我们还有很多<code>alloc</code>crate中的其他分配器和集合类型可以在内核中使用，包括：</p>
<ul>
<li>线程安全引用计数指针<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/sync/struct.Arc.html"><code>Arc</code></a></li>
<li>Rust的字符串类型<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/string/struct.String.html"><code>String</code></a>和<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/macro.format.html"><code>format!</code></a>格式化宏</li>
<li>链表<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/collections/linked_list/struct.LinkedList.html"><code>LinkedList</code></a></li>
<li>可增长的环形缓冲区<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/collections/vec_deque/struct.VecDeque.html"><code>VecDeque</code></a></li>
<li>优先级队列<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/collections/binary_heap/struct.BinaryHeap.html"><code>BinaryHeap</code></a></li>
<li><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/collections/btree_map/struct.BTreeMap.html"><code>BTreeMap</code></a>和<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/collections/btree_set/struct.BTreeSet.html"><code>BTreeSet</code></a></li>
</ul>
<p>当我们要实现线程列表、调度队列、或async/await支持时，这些类型将会非常有用。</p>
<h2 id="添加测试"><a href="#添加测试" class="headerlink" title="添加测试"></a>添加测试</h2><p>为了确保新的分配器代码不会被意外破坏，我们应该为其添加一个集成测试。首先创建一个新的<code>tests/heap_allocation.rs</code>文件，其内容如下：</p>
<figure class="highlight rust"><figcaption><span>in tests/heap_allocation.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"><span class="meta">#![feature(custom_test_frameworks)]</span></span><br><span class="line"><span class="meta">#![test_runner(blog_os::test_runner)]</span></span><br><span class="line"><span class="meta">#![reexport_test_harness_main = <span class="meta-string">&quot;test_main&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> alloc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> bootloader::&#123;entry_point, BootInfo&#125;;</span><br><span class="line"><span class="keyword">use</span> core::panic::PanicInfo;</span><br><span class="line"></span><br><span class="line">entry_point!(main);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(boot_info: &amp;<span class="symbol">&#x27;static</span> BootInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="built_in">unimplemented!</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">panic</span></span>(info: &amp;PanicInfo) -&gt; ! &#123;</span><br><span class="line">    blog_os::test_panic_handler(info)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们重用了<code>lib.rs</code>中的<code>test_runner</code>和<code>test_panic_handler</code>函数。由于我们要测试分配器，所以需要使用<code>extern crate alloc</code>语句启用<code>alloc</code>crate。 有关测试样板的更多信息，请查看前面的<a target="_blank" rel="noopener" href="https://os.phil-opp.com/testing/"><em>测试</em></a>一文。</p>
<p><code>main</code>函数的实现如下所示：</p>
<figure class="highlight rust"><figcaption><span>in tests/heap_allocation.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(boot_info: &amp;<span class="symbol">&#x27;static</span> BootInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">use</span> blog_os::allocator;</span><br><span class="line">    <span class="keyword">use</span> blog_os::memory::&#123;<span class="keyword">self</span>, BootInfoFrameAllocator&#125;;</span><br><span class="line">    <span class="keyword">use</span> x86_64::VirtAddr;</span><br><span class="line"></span><br><span class="line">    blog_os::init();</span><br><span class="line">    <span class="keyword">let</span> phys_mem_offset = VirtAddr::new(boot_info.physical_memory_offset);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> mapper = <span class="keyword">unsafe</span> &#123; memory::init(phys_mem_offset) &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> frame_allocator = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        BootInfoFrameAllocator::init(&amp;boot_info.memory_map)</span><br><span class="line">    &#125;;</span><br><span class="line">    allocator::init_heap(&amp;<span class="keyword">mut</span> mapper, &amp;<span class="keyword">mut</span> frame_allocator)</span><br><span class="line">        .expect(<span class="string">&quot;heap initialization failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    test_main();</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它与<code>main.rs</code>中的<code>kernel_main</code>函数非常相似，不同之处在于我们不调用<code>println</code>，不包括任何分配示例，并且无条件调用<code>test_main</code>。</p>
<p>现在我们准备添加一些测试用例。首先，我们添加一个测试，以使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/boxed/struct.Box.html"><code>Box</code></a>执行一些简单的分配并检查分配的值，以确保基本分配有效：</p>
<figure class="highlight rust"><figcaption><span>in tests/heap_allocation.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> alloc::boxed::<span class="built_in">Box</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test_case]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">simple_allocation</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> heap_value_1 = <span class="built_in">Box</span>::new(<span class="number">41</span>);</span><br><span class="line">    <span class="keyword">let</span> heap_value_2 = <span class="built_in">Box</span>::new(<span class="number">13</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(*heap_value_1, <span class="number">41</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(*heap_value_2, <span class="number">13</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最重要的是，此测试可验证是否发生分配错误。</p>
<p>接下来，我们循环新建一个大型向量，以测试大型分配和多重分配（以测试再分配）：</p>
<figure class="highlight rust"><figcaption><span>in tests/heap_allocation.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> alloc::vec::<span class="built_in">Vec</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test_case]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">large_vec</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> vec = <span class="built_in">Vec</span>::new();</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">        vec.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(vec.iter().sum::&lt;<span class="built_in">u64</span>&gt;(), (n - <span class="number">1</span>) * n / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过与<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF#Partial_sums">求和公式</a>进行比较来验证向量求和。这使我们确信分配的值都是正确的。</p>
<p>作为第三项测试，我们在执行一万次分配：</p>
<figure class="highlight rust"><figcaption><span>in tests/heap_allocation.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> blog_os::allocator::HEAP_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test_case]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">many_boxes</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..HEAP_SIZE &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="built_in">Box</span>::new(i);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(*x, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此测试确保分配器将释放的内存重新用于后续分配，否则分配器将耗尽内存。这似乎是对分配器的基本要求，但是有些分配器设计并没有这样做。一个示例是线性分配器，我们将在下一篇文章中进行解释。</p>
<p>运行新的集成测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; cargo <span class="built_in">test</span> --<span class="built_in">test</span> heap_allocation</span><br><span class="line">[…]</span><br><span class="line">Running 3 tests</span><br><span class="line">simple_allocation... [ok]</span><br><span class="line">large_vec... [ok]</span><br><span class="line">many_boxes... [ok]</span><br></pre></td></tr></table></figure>

<p>三个测试全部通过！你还可以调用<code>cargo test</code>（不使用<code>--test</code>参数）来运行所有单元测试和集成测试。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在这篇文章中，我们了解了动态内存的概念、为什么要使用动态内存以及需要在什么地方使用动态内存。我们了解了Rust的借用检查器如何防止常见漏洞，以及Rust分配器API的工作方式。</p>
<p>在使用假分配器创建了Rust分配器接口的最小化实现之后，我们为内核创建了一个适当的堆内存区域。为此，我们为堆定义了一个虚拟地址范围，然后使用上一篇文章中的<code>Mapper</code>和<code>FrameAllocator</code>将地址范围中的所有页面映射到物理帧。</p>
<p>最后，我们添加了对<code>linked_list_allocator</code>crate的依赖，以在内核中应用已有的分配器实现。利用此分配器，我们能够使用<code>Box</code>、<code>Vec</code>以及<code>alloc</code>  crate中的其他分配器和集合类型。</p>
<h2 id="下期预告"><a href="#下期预告" class="headerlink" title="下期预告"></a>下期预告</h2><p>虽然我们已经在本文中添加了堆分配支持，但也将大部分工作留给了现成的<code>linked_list_allocator</code>crate。下一篇文章将详细展示如何从头开始实现分配器，并将介绍多种可能的分配器设计，展示如何实现它们的简单版本，并阐述它们的优缺点。</p>
<h2 id="支持本项目"><a href="#支持本项目" class="headerlink" title="支持本项目"></a>支持本项目</h2><p>创建和<a target="_blank" rel="noopener" href="https://os.phil-opp.com/status-update/">维护</a>这个博客和相关库是一项繁重的工作，但我真的很喜欢。通过支持我，您可以让我在新内容、新功能和持续维护上投入更多时间。</p>
<p>支持我的最好方式是<a target="_blank" rel="noopener" href="https://github.com/sponsors/phil-opp">在GitHub上赞助我</a>，因为他们不收取任何中间费用。如果你喜欢其他平台，我也有<a target="_blank" rel="noopener" href="https://www.patreon.com/phil_opp">Patreon</a>和<a target="_blank" rel="noopener" href="https://donorbox.org/phil-opp">Donorbox</a>账户。后者是最灵活的，因为它支持多种货币和一次性捐款。</p>
<p>感谢您的支持！</p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Rust/">Rust</a><a class="link-muted mr-2" rel="tag" href="/tags/Operating-System/">Operating System</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatpay.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/04/06/writing-an-os-in-rust-3.4/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">使用Rust编写操作系统 - 3.4 - 内存分配器设计</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/03/26/writing-an-os-in-rust-3.2/"><span class="level-item">使用Rust编写操作系统 - 3.2 - 内存分页实现</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><script src="https://utteranc.es/client.js" repo="zlotus/comment" issue-term="pathname" label="some-issue-label" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/opm_sq.png" alt="子实"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">子实</p><p class="is-size-6 is-block">程序员</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>陕西/西安</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">78</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">22</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zlotus" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com/qinzishi"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/Zealot_uS"><i class="fab fa-twitter"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.zhihu.com/people/zlotus" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Diary/"><span class="level-start"><span class="level-item">Diary</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">64</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Shell/"><span class="level-start"><span class="level-item">Shell</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Coroutines/"><span class="tag">Coroutines</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">30</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenCV/"><span class="tag">OpenCV</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Operating-System/"><span class="tag">Operating System</span><span class="tag">21</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Paper/"><span class="tag">Paper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">17</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Raspberry-Pi/"><span class="tag">Raspberry Pi</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag">29</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TensorFlow/"><span class="tag">TensorFlow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tokio/"><span class="tag">Tokio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZMQ/"><span class="tag">ZMQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ctpn/"><span class="tag">ctpn</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macOS/"><span class="tag">macOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/obsidion/"><span class="tag">obsidion</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%A5%E8%AE%B0/"><span class="tag">日记</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E8%B0%88/"><span class="tag">杂谈</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B/"><span class="tag">编程</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%84%9A%E6%9C%AC/"><span class="tag">脚本</span><span class="tag">4</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a><p class="is-size-7"><span>&copy; 2023 子实</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>