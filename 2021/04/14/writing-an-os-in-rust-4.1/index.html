<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>使用Rust编写操作系统 - 4.1 - Async/Await - 子实</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="子实"><meta name="msapplication-TileImage" content="/img/avatar-o.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="子实"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="使用Rust编写操作系统 - 4.1 - Async&amp;#x2F;Await"><meta property="og:type" content="article"><meta property="og:title" content="使用Rust编写操作系统 - 4.1 - Async/Await"><meta property="og:url" content="https://zlotus.github.io/2021/04/14/writing-an-os-in-rust-4.1/"><meta property="og:site_name" content="子实"><meta property="og:description" content="使用Rust编写操作系统 - 4.1 - Async&amp;#x2F;Await"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://os.phil-opp.com/async-await/regain-control-on-interrupt.svg"><meta property="og:image" content="https://os.phil-opp.com/async-await/async-example.svg"><meta property="og:image" content="https://os.phil-opp.com/async-await/async-state-machine-states.svg"><meta property="og:image" content="https://os.phil-opp.com/async-await/async-state-machine-basic.svg"><meta property="og:image" content="https://os.phil-opp.com/async-await/self-referential-struct.svg"><meta property="og:image" content="https://os.phil-opp.com/async-await/self-referential-struct-moved.svg"><meta property="og:image" content="https://os.phil-opp.com/async-await/qemu-simple-executor.png"><meta property="og:image" content="https://os.phil-opp.com/async-await/scancode-queue.svg"><meta property="og:image" content="https://os.phil-opp.com/async-await/qemu-keyboard-output.gif"><meta property="og:image" content="https://os.phil-opp.com/async-await/qemu-keyboard-output-again.gif"><meta property="article:published_time" content="2021-04-14T07:18:00.000Z"><meta property="article:modified_time" content="2021-04-14T07:18:00.000Z"><meta property="article:author" content="子实"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Operating System"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://os.phil-opp.com/async-await/regain-control-on-interrupt.svg"><meta property="twitter:creator" content="@Zealot_uS"><meta property="twitter:site" content="Zealot_uS"><link rel="publisher" href="+LotusQin"><meta property="fb:admins" content="qinzishi"><meta property="fb:app_id" content="qinzishi"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zlotus.github.io/2021/04/14/writing-an-os-in-rust-4.1/"},"headline":"使用Rust编写操作系统 - 4.1 - Async/Await","image":["https://os.phil-opp.com/async-await/qemu-simple-executor.png","https://os.phil-opp.com/async-await/qemu-keyboard-output.gif","https://os.phil-opp.com/async-await/qemu-keyboard-output-again.gif"],"datePublished":"2021-04-14T07:18:00.000Z","dateModified":"2021-04-14T07:18:00.000Z","author":{"@type":"Person","name":"子实"},"publisher":{"@type":"Organization","name":"子实","logo":{"@type":"ImageObject","url":"https://zlotus.github.io/img/opm_sq.png"}},"description":"使用Rust编写操作系统 - 4.1 - Async&#x2F;Await"}</script><link rel="icon" href="/img/avatar-o.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/2014/07/09/about-me/">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-14T07:18:00.000Z" title="4/14/2021, 3:18:00 PM">2021-04-14</time>发表</span><span class="level-item"><time dateTime="2021-04-14T07:18:00.000Z" title="4/14/2021, 3:18:00 PM">2021-04-14</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a></span><span class="level-item">3 小时读完 (大约27808个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">使用Rust编写操作系统 - 4.1 - Async/Await</h1><div class="content"><article class="message message-immersive is-warning">
<div class="message-body">
<i class="fas fa-exclamation-triangle mr-2"></i>本文所有内容均为翻译，原文：<a target="_blank" rel="noopener" href="https://os.phil-opp.com/async-await/">Async/Await</a>；原项目：<a target="_blank" rel="noopener" href="https://os.phil-opp.com/">Writing an OS in Rust</a>
</div>
</article>

<p>本文将探讨<em>协作式多任务处理</em>以及Rust的<em>async/await</em>特性。我们将详细研究async/await在Rust中的工作方式，包括<code>Future</code>trait的设计，状态机转换和<em>pinning</em>（译注：内存固定）。然后，我们通过创建异步键盘任务和基本执行器，使得内核具备对async/await的基本支持。</p>
<span id="more"></span>

<p>这个博客是在<a target="_blank" rel="noopener" href="https://github.com/phil-opp/blog_os">GitHub</a>上公开开发的。如果你有任何问题或疑问，请在那里开一个issue。你也可以在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/async-await/#comments">底部</a>留言。这篇文章的完整源代码可以在<a target="_blank" rel="noopener" href="https://github.com/phil-opp/blog_os/tree/post-12">post-12</a>分支中找到。</p>
<h2 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computer_multitasking"><em>多任务</em></a>处理是大多数操作系统的基本特征之一，这是一种能够同时执行多个任务的功能。例如，在看这篇文章时，你可能会打开其他程序，例如文本编辑器或终端窗口。即使只打开一个浏览器窗口，也可能会有各种后台任务来管理桌面窗口，检查更新或为文件建立索引。</p>
<p>尽管所有任务看上去都是并行运行的，但实际在CPU内核上一次只能执行一个任务。为了产生任务可以并行运行的错觉，操作系统会在活动任务之间快速切换，以使得每个任务都可以有一些进展。由于计算机速度很快，因此大多数时候我们不会注意到这些切换。</p>
<p>单核CPU一次只能执行一个任务，而多核CPU可以真正并行地运行多个任务。例如，具有8个内核的CPU可以同时运行8个任务。我们将在以后的文章中解释如何设置多核CPU。在本文中，为简单起见，我们将重点介绍单核CPU。（值得注意的是，所有多核CPU都仅从单个活动核启动，因此我们目前仍然可以将它们视为单核CPU。）</p>
<p>多任务处理有两种形式：<em>协作式</em>多任务要求任务定期放弃对CPU的控制，以便其他任务可以继续执行。<em>抢占式</em>多任务使用操作系统功能通过强行暂停线程，以在任意时间点切换线程。在下文中，我们将更详细地探讨多任务的两种形式，并讨论它们各自的优缺点。</p>
<h3 id="抢占式多任务"><a href="#抢占式多任务" class="headerlink" title="抢占式多任务"></a>抢占式多任务</h3><p>抢占式多任务处理的思路是使用操作系统控制何时切换任务，思路利用了操作系统在每个中断上可以重获CPU控制权这一机制。这样，只要系统有新输入可用，就可以切换任务。例如，当鼠标移动或网络数据包到达时，就可以执行任务切换。操作系统还可以通过配置硬件计时器在到达特定时间时发送中断，来确定允许任务运行的确切时间。</p>
<p>下图说明了硬件中断上的任务切换过程：</p>
<p><img src="https://os.phil-opp.com/async-await/regain-control-on-interrupt.svg" alt="中断时重获控制权"></p>
<p>在第一行中，CPU正在执行程序<code>A</code>的任务<code>A1</code>，所有其他任务均被暂停。在第二行中，硬件中断到达CPU。就像<a target="_blank" rel="noopener" href="https://os.phil-opp.com/hardware-interrupts/">硬件中断</a>一文中介绍的那样，CPU立即停止执行任务<code>A1</code>，并跳转到中断描述符表(IDT)中定义的中断处理程序。通过中断处理程序，操作系统现在可以再次控制CPU，从而使它可以切换到任务<code>B1</code>，而不是继续执行任务<code>A1</code>。</p>
<h4 id="状态保存"><a href="#状态保存" class="headerlink" title="状态保存"></a>状态保存</h4><p>鉴于任务会在任意时间点中断，这些任务可能正处于某些计算中。为了能够在以后恢复这些任务，操作系统必须备份任务的整个状态，包括其<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Call_stack">调用栈</a>和所有CPU寄存器的值。此过程称为<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Context_switch">上下文切换</a>。</p>
<p>由于调用栈可能会非常大，操作系统通常会为每个任务设置单独的调用栈，而不是在每次任务切换时备份调用栈的内容。具有单独调用栈的此类任务称为<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Thread_(computing)">执行线程</a>或简称线程。通过为每个任务设置单独的栈，上下文切换时仅需要保存寄存器的内容即可（包括程序计数器和栈指针）。这种方法可以最大程度地减少上下文切换的性能开销，这非常重要，因为上下文切换通常能够到达每秒100次。</p>
<h4 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h4><p>抢占式多任务处理的主要优点是操作系统可以完全控制任务的执行时间。这样即使不要求任务间的相互协作，也能够确保公平分配各任务的CPU时间。在运行第三方任务时或在多个用户共享系统时，这一点尤其重要。</p>
<p>抢占式的缺点是每个任务都需要自己的调用栈。与共享调用栈相比，这会导致每个任务的内存使用量增加，并且通常会限制系统中的任务的总量。抢占式的另一个缺点是，即使任务仅使用了一小部分寄存器，操作系统在每个任务切换时仍必须保存全部的CPU寄存器状态。</p>
<p>抢占式多任务处理和线程是操作系统的基本要素，因为它们能够使操作系统能够运行不受信任的用户空间程序，我们将在以后的文章中详细讨论这些概念。在本文中，我们将专注于协作式多任务处理，这种方式也能够为内核提供有用的多任务功能。</p>
<h3 id="协作式多任务"><a href="#协作式多任务" class="headerlink" title="协作式多任务"></a>协作式多任务</h3><p>协作多任务处理并不是在任意时间点强行暂停正在运行的任务，而是让每个任务运行到自愿放弃对CPU的控制为止。这使任务可以在方便的时间点暂停自己，比如当该任务需要等待I/O操作时。</p>
<p>合作多任务通常使用在语言层，例如以<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Coroutine">协程</a>或<a target="_blank" rel="noopener" href="https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html">async/await</a>的形式。该思路是由程序员或编译器都将<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Yield_(multithreading)"><em>yield</em></a>操作插入到程序中，从而使该任务放弃对CPU的控制以允许其他任务运行。在复杂循环的每次迭代之后都可以插入一个yield。</p>
<p>协作式多任务通常与<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Asynchronous_I/O">异步操作</a>一起使用。与抢占式的一直等待直到操作完成并在期间阻止其他任务的执行，在协作式中若操作尚未完成，则异步操作将返回一个“未就绪”状态。在这种情况下，等待的任务可以执行一个yield操作以允许其他任务运行。</p>
<h4 id="状态保存-1"><a href="#状态保存-1" class="headerlink" title="状态保存"></a>状态保存</h4><p>由于任务会为自己定义暂停点，因此它们不需要操作系统来保存其状态。与抢占式相比，协作式可以在暂停之前只保存用以在继续时恢复操作的必要的寄存器状态，这通常可以提高性能。例如，刚完成复杂计算的任务可能只需要备份计算的最终结果，因为此时中间结果已经不再需要了。</p>
<p>由语言支持实现的协作任务甚至可以在暂停之前只备份调用堆栈的所需部分。例如，Rust的async/await实现会将所有需要的局部变量存储在自动生成的结构体中（见下文）。通过在暂停之前备份调用堆栈的相关部分，所有任务可以共享一个调用堆栈，从而减少了每个任务的内存消耗。这样就可以创建几乎无限的协作任务，而不用担心内存耗尽。</p>
<h4 id="讨论-1"><a href="#讨论-1" class="headerlink" title="讨论"></a>讨论</h4><p>协作式多任务处理的缺点是，一个非协作的任务可能会无限期地运行下去。那么，恶意程序或有bug的任务可能会阻止其他任务的运行，并拖慢甚至阻塞整个系统。因此，当且仅当所有任务都支持协作时才能使用协作式多任务处理。而让操作系统依赖于任意用户级程序的协作并不是一个好主意。</p>
<p>但是，协作多任务的强大性能和内存优势，使其成为在程序<em>内部</em>使用的好方法，特别是与异步操作结合使用时。由于操作系统内核需要与异步硬件交互，性能至关重要，因此协作多任务似乎是一个实现并发的好方法。</p>
<h2 id="Rust的async-await"><a href="#Rust的async-await" class="headerlink" title="Rust的async/await"></a>Rust的async/await</h2><p>Rust语言以<code>async/await</code>的形式为协作式多任务提供了原生支持。在探讨什么是async/await及其工作原理之前，我们需要了解Rust中的<em>futures</em>和异步编程是如何工作的。</p>
<h3 id="Futures"><a href="#Futures" class="headerlink" title="Futures"></a>Futures</h3><p><em>Future</em>表示一个可能尚不可用的值。例如，这个值可能是由另一个任务计算的整数，也可能是从网络下载的文件。Future并不需要一直要等待到该值可用，它可以继续执行其他代码直到需要用到该值为止。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>最好用一个小例子说明futures的概念：</p>
<p><img src="https://os.phil-opp.com/async-await/async-example.svg" alt="async示例"></p>
<p>此序列图展示了一个<code>main</code>函数，它从文件系统读取文件，然后调用<code>foo</code>函数。图中以不同的方式执行两次此过程：一次是调用同步函数<code>read_file</code>，一次是调用异步函数<code>async_read_file</code>。</p>
<p>在同步调用中，<code>main</code>函数需要一直等待，直到该文件从文件系统中加载完毕。只有这样，它才能继续调用<code>foo</code>函数，并再次等待其执行结果。</p>
<p>通过异步<code>async_read_file</code>调用，文件系统直接返回一个future并在后台异步加载文件。这使<code>main</code>函数可以更早地调用<code>foo</code>函数，然后<code>foo</code>函数与文件加载并行运行。在此示例中，文件加载甚至在<code>foo</code>返回之前就完成了，因此<code>main</code>无需继续等待<code>foo</code>返回，可以直接处理文件。</p>
<h4 id="Rust中的Futures"><a href="#Rust中的Futures" class="headerlink" title="Rust中的Futures"></a>Rust中的Futures</h4><p>在Rust中，futures由<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/future/trait.Future.html"><code>Future</code></a>trait表示，其定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Future</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context) -&gt; Poll&lt;Self::Output&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关联类型<code>Output</code>指定异步返回值的类型。例如，上图中的<code>async_read_file</code>函数将返回一个<code>Output</code>设置为<code>File</code>的<code>Future</code>实例。</p>
<p>调用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/future/trait.Future.html#tymethod.poll"><code>poll</code></a>方法可以检查该值是否已经可用。它将返回一个枚举<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/future/trait.Future.html#tymethod.poll"><code>Poll</code></a>，如下所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">Poll</span></span>&lt;T&gt; &#123;</span><br><span class="line">    Ready(T),</span><br><span class="line">    Pending,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果该值已经可用（例如，已从磁盘中读取完整的文件），则将其封装在<code>Ready</code>变量中返回。否则，将返回<code>Pending</code>变量，以通知调用方该值尚不可用。</p>
<p><code>poll</code>方法采用两个参数：<code>self: Pin&lt;&amp;mut Self&gt;</code>和<code>cx: &amp;mut Context</code>上下文。前者的行为类似于普通的<code>&amp;mut self</code>引用，不同之处在于，<code>Self</code>值<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/pin/index.html"><em>pinned</em></a>在一个固定的内存位置上。如果不先了解async/await的工作原理，就很难理解<code>Pin</code>以及为什么需要<code>Pin</code>。因此，我们将在后文中进行详细解释。</p>
<p><code>cx: &amp;mut Context</code>参数用于将一个<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/task/struct.Waker.html"><code>Waker</code></a>实例传递给异步任务，例如加载文件系统。这个<code>Waker</code>允许异步任务发信号通知任务（或部分任务）已完成，例如该文件已从磁盘加载。由于主任务知道将在<code>Future</code>就绪时将会收到通知，因此就不需要一遍又一遍地调用<code>poll</code>了。我们会在后文中实现自己的waker类型，届时将更加详细地说明此过程。</p>
<h3 id="使用Futures"><a href="#使用Futures" class="headerlink" title="使用Futures"></a>使用Futures</h3><p>现在，我们知道了如何定义future，了解了<code>poll</code>方法的基本思路。但是，我们仍然不知道如何有效地使用futures。由于futures代表异步任务的结果，可能尚不可用。但实际上，我们经常立即需要这些值以进行进一步的计算。所以问题是：在需要时如何有效地检索一个future的值？</p>
<h4 id="等待Futures"><a href="#等待Futures" class="headerlink" title="等待Futures"></a>等待Futures</h4><p>一种可能的答案是一直等待到future就绪为止。该过程看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> future = async_read_file(<span class="string">&quot;foo.txt&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> file_content = <span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> future.poll(…) &#123;</span><br><span class="line">        Poll::Ready(value) =&gt; <span class="keyword">break</span> value,</span><br><span class="line">        Poll::Pending =&gt; &#123;&#125;, <span class="comment">// 什么也不做</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们通过循环中<em>积极地</em>调用<code>poll</code>来等待future完成。在这里<code>poll</code>的参数并不重要，因此已被省略。尽管此方法可行，但是效率很低，因为包含poll的循环会一直用占用CPU直到该值可用为止。</p>
<p>一种较为高效的方法是<em>阻塞</em>当前线程，直到future可用为止。当然，这只有在有线程支持的情况下才可行，因此并不适用于我们的内核，至少目前还不行。即使在支持阻塞的系统上，通常也不会这么做，因为阻塞会将异步任务再次变为同步任务，从而失去了并行任务的性能优势。</p>
<h4 id="Future组合器"><a href="#Future组合器" class="headerlink" title="Future组合器"></a>Future组合器</h4><p>另一种等待方式是使用future组合器。Future组合器是类似于<code>map</code>的方法，它允许将futures链接并组合在一起，就像在<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/core/iter/trait.Iterator.html"><code>Iterator</code></a>上做的那样。这些组合器不等待future，而是自己返回future，即为<code>poll</code>应用了map操作。</p>
<p>下面举个简单的例子，一个用于将<code>Future&lt;Output = String&gt;</code>转换为<code>Future&lt;Output = usize&gt;</code>的<code>string_len</code>组合器可能看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StringLen</span></span>&lt;F&gt; &#123;</span><br><span class="line">    inner_future: F,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;F&gt; Future <span class="keyword">for</span> StringLen&lt;F&gt; <span class="keyword">where</span> F: Future&lt;Output = <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = <span class="built_in">usize</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">mut</span> <span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.inner_future.poll(cx) &#123;</span><br><span class="line">            Poll::Ready(s) =&gt; Poll::Ready(s.len()),</span><br><span class="line">            Poll::Pending =&gt; Poll::Pending,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">string_len</span></span>(string: <span class="keyword">impl</span> Future&lt;Output = <span class="built_in">String</span>&gt;)</span><br><span class="line">    -&gt; <span class="keyword">impl</span> Future&lt;Output = <span class="built_in">usize</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    StringLen &#123;</span><br><span class="line">        inner_future: string,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">file_len</span></span>() -&gt; <span class="keyword">impl</span> Future&lt;Output = <span class="built_in">usize</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> file_content_future = async_read_file(<span class="string">&quot;foo.txt&quot;</span>);</span><br><span class="line">    string_len(file_content_future)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码无法正常工作，因为尚未处理<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/core/pin/index.html"><em>pinning</em></a>，不过作为例子已经足够了。基本思路是<code>string_len</code>函数将给定的实现了<code>Future</code>trait的实例封装到新的<code>StringLen</code>结构体中，而该结构体也实现了<code>Future</code>trait。当poll封装的future时，即是poll其内部的future。如果该值尚未就绪，封装的future也将返回<code>Poll::Pending</code>。如果该值已就绪，则从<code>Poll::Ready</code>变量中获取字符串，并计算其长度。最后再将其封装在<code>Poll::Ready</code>中返回。</p>
<p>通过<code>string_len</code>函数，我们不需要等待一个异步字符串，就可以计算其长度。由于该函数也返回<code>Future</code>，因此调用者无法直接操作返回的值，而需要再次使用组合器函数。这样，整个调用过程就变为异步的了，我们可以高效地在某个时刻一次等待多个future，例如 在<code>main</code>函数上。</p>
<p>手动编写组合器函数比较困难，所以它们通常由库直接提供。尽管Rust标准库本身还没有提供官方组合器方法，但半官方（兼容<code>no_std</code>）的<a target="_blank" rel="noopener" href="https://docs.rs/futures/0.3.4/futures/"><code>future</code></a>crate可以。其<a target="_blank" rel="noopener" href="https://docs.rs/futures/0.3.4/futures/future/trait.FutureExt.html"><code>FutureExt</code></a>特性提供了诸如<a target="_blank" rel="noopener" href="https://docs.rs/futures/0.3.4/futures/future/trait.FutureExt.html#method.map"><code>map</code></a>或<a target="_blank" rel="noopener" href="https://docs.rs/futures/0.3.4/futures/future/trait.FutureExt.html#method.then"><code>then</code></a>之类的高级组合器方法，可用于任意闭合操作结果。</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>Future组合器最大的优点是能够使操作保持异步。这种方法和异步<code>I/O</code>接口结合使用时性能非常高。实际上future组合器将被实现为具有trait的普通结构体，以使编译器能够对其做出进一步优化。有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://aturon.github.io/blog/2016/08/11/futures/">Rust的零成本future</a>一文，就是这篇文章宣布了在Rust生态系统中添加future。</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>尽管future组合器可以编写出非常高效的代码，但由于类型系统和基于闭包的接口的限制，组合器可能会在某些情况下变得难以使用。例如，考虑下面的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">example</span></span>(min_len: <span class="built_in">usize</span>) -&gt; <span class="keyword">impl</span> Future&lt;Output = <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    async_read_file(<span class="string">&quot;foo.txt&quot;</span>).then(<span class="keyword">move</span> |content| &#123;</span><br><span class="line">        <span class="keyword">if</span> content.len() &lt; min_len &#123;</span><br><span class="line">            Either::Left(async_read_file(<span class="string">&quot;bar.txt&quot;</span>).map(|s| content + &amp;s))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Either::Right(future::ready(content))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（<a target="_blank" rel="noopener" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=91fc09024eecb2448a85a7ef6a97b8d8">使用play rust在线运行上面的代码</a>）</p>
<p>代码先读取文件<code>foo.txt</code>，然后使用<a target="_blank" rel="noopener" href="https://docs.rs/futures/0.3.4/futures/future/trait.FutureExt.html#method.then"><code>then</code></a>组合器根据文件内容链接第二个future。如果内容长度小于给定的<code>min_len</code>，我们将读取另一个<code>bar.txt</code>文件，然后使用<a target="_blank" rel="noopener" href="https://docs.rs/futures/0.3.4/futures/future/trait.FutureExt.html#method.map"><code>map</code></a>组合器将其附加到<code>content</code>中。否则，只返回<code>foo.txt</code>的<code>content</code>。</p>
<p>我们需要在传递给<code>then</code>的闭包上使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/keyword.move.html"><code>move</code>关键字</a>，否则<code>min_len</code>变量会产生生命周期错误。使用<a target="_blank" rel="noopener" href="https://docs.rs/futures/0.3.4/futures/future/enum.Either.html"><code>Either</code></a>封装的原因是让<code>if</code>块和<code>else</code>块始终具有相同的类型。由于我们在块中返回了不同的future类型，因此必须使用封装类型将它们统一为一个类型。<a target="_blank" rel="noopener" href="https://docs.rs/futures/0.3.4/futures/future/fn.ready.html"><code>ready</code></a>函数将立刻就绪的值封装到future中。这里需要使用该函数是因为<code>Either</code>封装要求值实现<code>Future</code>trait。</p>
<p>您可以想象，这种用法很快就会导致大型项目的代码变得非常复杂。尤其是再涉及借用和生命周期，就会变得更加复杂。因此，为了使异步代码从根本上更易于编写，我们投入了大量工作来为Rust添加对async/await的支持。</p>
<h3 id="Async-Await模式"><a href="#Async-Await模式" class="headerlink" title="Async/Await模式"></a>Async/Await模式</h3><p>Async/Await的思路是让程序员以编写<em>看起来像</em>同步代码的方式编写异步代码，只不最后是由编译器将同步代码转换为异步代码。它基于两个关键字<code>async</code>和<code>await</code>。在函数签名中使用<code>async</code>关键字，就可以将同步函数转换为一个返回future的异步函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>() -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的函数大概会变编译器转换为：</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>() -&gt; <span class="keyword">impl</span> Future&lt;Output = <span class="built_in">u32</span>&gt; &#123;</span><br><span class="line">    future::ready(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仅使用此关键字并没有那么有用。但是，在异步函数内部，可以使用<code>await</code>关键字来取回future的异步值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">example</span></span>(min_len: <span class="built_in">usize</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> content = async_read_file(<span class="string">&quot;foo.txt&quot;</span>).<span class="keyword">await</span>;</span><br><span class="line">    <span class="keyword">if</span> content.len() &lt; min_len &#123;</span><br><span class="line">        content + &amp;async_read_file(<span class="string">&quot;bar.txt&quot;</span>).<span class="keyword">await</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        content</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（<a target="_blank" rel="noopener" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=d93c28509a1c67661f31ff820281d434">使用play rust在线运行上面的代码</a>）</p>
<p>将<a href="./#%E7%BC%BA%E7%82%B9">上面</a>使用组合器实现的<code>example</code>函数直接转换为async/await模式：使用<code>.await</code>运算符就可以取回future的值，无需使用闭包或<code>Either</code>类型。如此，我们就可以像编写普通的同步代码一样编写<em>异步代码</em>。</p>
<h4 id="状态机转换"><a href="#状态机转换" class="headerlink" title="状态机转换"></a>状态机转换</h4><p>在这种场景中，编译器的作用就是将<code>async</code>函数体转换为一个<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Finite-state_machine">状态机</a>，每个<code>.await</code>调用代表一个不同的状态。对于上面的<code>example</code>函数，编译器创建具有以下四个状态的状态机：</p>
<p><img src="https://os.phil-opp.com/async-await/async-state-machine-states.svg" alt="async状态机的状态"></p>
<p>不同状态代表该函数的不同暂停点。”<em>Start</em>“和”<em>End</em>“状态代表函数在其执行的开始和结束时的状态。”<em>Waiting on foo.txt</em>“状态表示该函数目前正在等待第一个<code>async_read_file</code>的结果。同样的，”<em>Waiting on bar.txt</em>“状态表示函数在等待第二个<code>async_read_file</code>的结果的暂停点。</p>
<p>状态机通过将每个<code>poll</code>调用都变为一个可能的状态转换来实现<code>Future</code>trait：</p>
<p><img src="https://os.phil-opp.com/async-await/async-state-machine-basic.svg" alt="async状态机本质"></p>
<p>图中使用箭头表示状态开关，并使用菱形表示条件路径。例如，如果<code>foo.txt</code>文件尚未准备好，则采用标记为”<em>no</em>“的路径，并达到”<em>Waiting on foo.txt</em>“的状态。否则，就采用标记为“<em>yes</em>”路径。没有字的红色小菱形代表<code>example</code>函数中<code>if content.len() &lt; 100</code>的条件分支。</p>
<p>我们看到第一个<code>poll</code>调用启动了该函数并使它运行，直到遇到一个尚未就绪的future。如果路径上的所有future都已就绪，则该函数可以一直运行到”<em>End</em>“状态，并返回封装在<code>Poll::Ready</code>中的结果。否则，状态机将进入等待状态并返回<code>Poll::Pending</code>。然后在下一个<code>poll</code>调用中，状态机从上一个等待状态开始重试其最后一次操作。</p>
<h4 id="状态保存-2"><a href="#状态保存-2" class="headerlink" title="状态保存"></a>状态保存</h4><p>为了能够从上一个等待状态中恢复，状态机必须在内部跟踪当前状态。此外，它还必须保存在下一个<code>poll</code>调用中恢复执行所需的变量。这就是编译器真正发挥作用的地方：由于编译器知道在何时要使用哪些变量，因此它可以自动生成具有所需变量的结构体。</p>
<p>作为示例，编译器为上面的<code>example</code>函数生成类似于下面这样的结构体：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是async版的`example`函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">example</span></span>(min_len: <span class="built_in">usize</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> content = async_read_file(<span class="string">&quot;foo.txt&quot;</span>).<span class="keyword">await</span>;</span><br><span class="line">    <span class="keyword">if</span> content.len() &lt; min_len &#123;</span><br><span class="line">        content + &amp;async_read_file(<span class="string">&quot;bar.txt&quot;</span>).<span class="keyword">await</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        content</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是编译器生成的状态结构体</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StartState</span></span> &#123;</span><br><span class="line">    min_len: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WaitingOnFooTxtState</span></span> &#123;</span><br><span class="line">    min_len: <span class="built_in">usize</span>,</span><br><span class="line">    foo_txt_future: <span class="keyword">impl</span> Future&lt;Output = <span class="built_in">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WaitingOnBarTxtState</span></span> &#123;</span><br><span class="line">    content: <span class="built_in">String</span>,</span><br><span class="line">    bar_txt_future: <span class="keyword">impl</span> Future&lt;Output = <span class="built_in">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EndState</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在”<em>Start</em>“和”<em>Waiting on foo.txt</em>“状态下，需要存储<code>min_len</code>参数，因为稍后与<code>content.len()</code>做比较时需要使用该参数。”<em>Waiting on foo.txt</em>“状态还存储了一个<code>foo_txt_future</code>，用来表示<code>async_read_file</code>调用返回的future。状态机继续运行时会再次poll该future，因此需要将其保存。</p>
<p>“<em>Waiting on bar.txt</em>“状态包含<code>content</code>变量，是因为在<code>bar.txt</code>就绪后需要使用该变量进行字符串连接。该状态还存储了一个<code>bar_txt_future</code>，用来表示正在加载中的<code>bar.txt</code>。该结构体不包含<code>min_len</code>变量，因为在<code>content.len()</code>比较之后就不再需要该变量了。在”<em>End</em>“状态下，没有存储任何变量，因为此时函数已经运行完毕。</p>
<p>请记住，这只是编译器可能生成的代码的一个示例。结构体名称和字段布局是实现细节，可能会有所不同。</p>
<h4 id="全状态机类型"><a href="#全状态机类型" class="headerlink" title="全状态机类型"></a>全状态机类型</h4><p>尽管编译器生成的确切代码是实现细节，但这个示例还是有助于我们理解并想象<code>example</code>函数生成的状态机可能的样子。我们已经定义了代表不同状态的结构体，并给出了其中包含的所需变量。为了基于这些结构体创建一个状态机，我们可以将它们组合成一个枚举：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ExampleStateMachine</span></span> &#123;</span><br><span class="line">    Start(StartState),</span><br><span class="line">    WaitingOnFooTxt(WaitingOnFooTxtState),</span><br><span class="line">    WaitingOnBarTxt(WaitingOnBarTxtState),</span><br><span class="line">    End(EndState),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们为每个状态定义一个单独的枚举变量，并将对应状态的结构体作为字段添加到每个变量。为了实现状态转换，编译器根据<code>example</code>函数实现<code>Future</code>trait：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Future <span class="keyword">for</span> ExampleStateMachine &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = <span class="built_in">String</span>; <span class="comment">// `example`函数的返回类型</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context) -&gt; Poll&lt;Self::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">match</span> <span class="keyword">self</span> &#123; <span class="comment">// <span class="doctag">TODO:</span> 处理pinning</span></span><br><span class="line">                ExampleStateMachine::Start(state) =&gt; &#123;…&#125;</span><br><span class="line">                ExampleStateMachine::WaitingOnFooTxt(state) =&gt; &#123;…&#125;</span><br><span class="line">                ExampleStateMachine::WaitingOnBarTxt(state) =&gt; &#123;…&#125;</span><br><span class="line">                ExampleStateMachine::End(state) =&gt; &#123;…&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该<code>Future</code>的<code>Output</code>类型为<code>String</code>，即<code>example</code>函数的返回类型。为了实现<code>poll</code>函数，我们在<code>loop</code>内的当前状态上使用<code>match</code>语句。思路是我们尽可能长时间地切换到下一个状态，并在无法继续时显式的使用<code>return Poll::Pending</code>。</p>
<p>为简单起见，这里仅给出简化的代码，且暂不处理<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/core/pin/index.html">pinning</a>、所有权、生命周期等内容。因此，这里的代码和下面的代码应被看做伪代码，不能直接使用。当然，真正的编译器生成的代码可以正确处理所有内容，尽管可能使用了与我们不同的方式。</p>
<p>为了使示意的代码更简洁，我们将分别显示每个匹配分支的代码。从”Start”状态开始：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ExampleStateMachine::Start(state) =&gt; &#123;</span><br><span class="line">    <span class="comment">// from body of `example`</span></span><br><span class="line">    <span class="keyword">let</span> foo_txt_future = async_read_file(<span class="string">&quot;foo.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// `.await` operation</span></span><br><span class="line">    <span class="keyword">let</span> state = WaitingOnFooTxtState &#123;</span><br><span class="line">        min_len: state.min_len,</span><br><span class="line">        foo_txt_future,</span><br><span class="line">    &#125;;</span><br><span class="line">    *<span class="keyword">self</span> = ExampleStateMachine::WaitingOnFooTxt(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当状态机处于<code>Start</code>状态时，其对应位置正是函数体的最开始。在这种情况下，我们将执行<code>example</code>函数体中的所有代码，直到遇到第一个<code>.await</code>。为了处理<code>.await</code>操作，我们将<code>self</code>状态机的状态修改为<code>WaitingOnFooTxt</code>，并令状态中包含<code>WaitingOnFooTxtState</code>结构体。</p>
<p>由于<code>match self &#123;…&#125;</code>语句是在循环中执行的，因此该执行将跳至下一个分支<code>WaitingOnFooTxt</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ExampleStateMachine::WaitingOnFooTxt(state) =&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> state.foo_txt_future.poll(cx) &#123;</span><br><span class="line">        Poll::Pending =&gt; <span class="keyword">return</span> Poll::Pending,</span><br><span class="line">        Poll::Ready(content) =&gt; &#123;</span><br><span class="line">            <span class="comment">// from body of `example`</span></span><br><span class="line">            <span class="keyword">if</span> content.len() &lt; state.min_len &#123;</span><br><span class="line">                <span class="keyword">let</span> bar_txt_future = async_read_file(<span class="string">&quot;bar.txt&quot;</span>);</span><br><span class="line">                <span class="comment">// `.await` operation</span></span><br><span class="line">                <span class="keyword">let</span> state = WaitingOnBarTxtState &#123;</span><br><span class="line">                    content,</span><br><span class="line">                    bar_txt_future,</span><br><span class="line">                &#125;;</span><br><span class="line">                *<span class="keyword">self</span> = ExampleStateMachine::WaitingOnBarTxt(state);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                *<span class="keyword">self</span> = ExampleStateMachine::End(EndState));</span><br><span class="line">                <span class="keyword">return</span> Poll::Ready(content);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这一匹配分支中，我们首先调用<code>foo_txt_future</code>的<code>poll</code>函数。如果尚未就绪，则退出循环并返回<code>Poll::Pending</code>。由于在这种情况下<code>self</code>仍位于<code>WaitingOnFooTxt</code>状态，因此状态机的下一次<code>poll</code>调用也将进入相同的匹配分支并重试<code>foo_txt_future</code>。</p>
<p>当<code>foo_txt_future</code>就绪时，我们将结果赋给<code>content</code>变量，然后继续执行<code>example</code>函数的代码：如果<code>content.len()</code>小于状态结构体中保存的<code>min_len</code>，则异步读取<code>bar.txt</code>文件。我们再次将<code>.await</code>操作转换为状态更改，而这次应转换为<code>WaitingOnBarTxt</code>状态。由于我们是在循环内执行匹配，因此下一轮循环将直接跳转到新状态的匹配分支，然后在该状态下poll<code>bar_txt_future</code>。</p>
<p>如果我们进入<code>else</code>分支，则不会进行进一步的<code>.await</code>操作。此时已到达函数的结尾，并将<code>content</code>封装在<code>Poll::Ready</code>中返回。我们还需要将当前状态更改为<code>End</code>状态。</p>
<p><code>WaitingOnBarTxt</code>状态的代码如下所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ExampleStateMachine::WaitingOnBarTxt(state) =&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> state.bar_txt_future.poll(cx) &#123;</span><br><span class="line">        Poll::Pending =&gt; <span class="keyword">return</span> Poll::Pending,</span><br><span class="line">        Poll::Ready(bar_txt) =&gt; &#123;</span><br><span class="line">            *<span class="keyword">self</span> = ExampleStateMachine::End(EndState));</span><br><span class="line">            <span class="comment">// from body of `example`</span></span><br><span class="line">            <span class="keyword">return</span> Poll::Ready(state.content + &amp;bar_txt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与<code>WaitingOnFooTxt</code>状态类似，我们从poll<code>bar_txt_future</code>开始。如果仍未就绪，则退出循环并返回<code>Poll::Pending</code>。否则，我们就执行<code>example</code>函数的最后一个操作：用<code>content</code>变量与future的结果做字符串连接。我们将状态机更新为<code>End</code>状态，然后将结果封装在<code>Poll::Ready</code>中返回。</p>
<p>最后，<code>End</code>状态的代码如下所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExampleStateMachine::End(_) =&gt; &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;poll called after Poll::Ready was returned&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Future返回<code>Poll::Ready</code>后就不应再被poll了，因此，当我们已经处于<code>End</code>状态时，如果再次调用<code>poll</code>，就产生一个panic。</p>
<p>现在我们知道了编译器<em>可能</em>会生成怎样的状态机，以及怎样去给状态机实现<code>Future</code>trait。但实际上，编译器会以不同的方式生成代码。（如果您感兴趣的话，该实现目前基于<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/unstable-book/language-features/generators.html"><em>生成器</em></a>，不过这只是实现细节。）</p>
<p>最后一步是为<code>example</code>函数本身生成代码。记住，函数签名是这样定义的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">example</span></span>(min_len: <span class="built_in">usize</span>) -&gt; <span class="built_in">String</span></span><br></pre></td></tr></table></figure>

<p>由于现在整个函数体是由状态机实现的，因此该函数唯一需要做的就是初始化状态机并将其返回。为此生成的代码如下所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">example</span></span>(min_len: <span class="built_in">usize</span>) -&gt; ExampleStateMachine &#123;</span><br><span class="line">    ExampleStateMachine::Start(StartState &#123;</span><br><span class="line">        min_len,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数不再使用<code>async</code>修饰符，因为它现在显式返回一个实现了<code>Future</code>trait的<code>ExampleStateMachine</code>类型。如预期的那样，状态机被初始化为<code>Start</code>状态，并且使用<code>min_len</code>参数初始化了对应的状态结构体。</p>
<p>请注意，此函数并不会直接启动状态机。这是Rust中future的一个基本设计决策：在第一次被poll之前什么也不做。</p>
<h3 id="Pinning"><a href="#Pinning" class="headerlink" title="Pinning"></a>Pinning</h3><p>在这篇文章中，我们已经遇到<em>pinning</em>很多次了。现在终于是时候看看究竟什么是pinning以及为什么需要pinning了。</p>
<h4 id="自引用结构体"><a href="#自引用结构体" class="headerlink" title="自引用结构体"></a>自引用结构体</h4><p>如上所述，状态机转换将每个暂停点的局部变量存储在结构体中。对于像<code>example</code>函数这样的小例子就很简单，并不会导致任何问题。但是，当变量相互引用时，事情就会变得困难。例如，考虑以下函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">pin_example</span></span>() -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> element = &amp;array[<span class="number">2</span>];</span><br><span class="line">    async_write_file(<span class="string">&quot;foo.txt&quot;</span>, element.to_string()).<span class="keyword">await</span>;</span><br><span class="line">    *element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数创建一个包含<code>1</code>、<code>2</code>、<code>3</code>的小数组。然后再创建对最后一个数组元素的引用，存储在<code>element</code>变量中。接下来，该函数将转换为字符串的数字异步写入到<code>foo.txt</code>文件中。最后返回由<code>element</code>引用的数字。</p>
<p>由于该函数使用了一个<code>await</code>操作，因此结果状态机具有三种状态：”Start”、”End”、”Waiting on write”。该函数没有参数，因此开始状态对应的结构体为空。像以前一样，结束状态对应的结构体也为空，因为该函数此时已完成。而”Waiting on write”状态对应的结构体就很有趣：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WaitingOnWriteState</span></span> &#123;</span><br><span class="line">    array: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    element: <span class="number">0x1001c</span>, <span class="comment">// 最后一个数组元素的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要存储<code>array</code>和<code>element</code>变量，因为返回值需要<code>element</code>，而<code>element</code>又引用了<code>array</code>。由于<code>element</code>是一个引用，因此它存储指向所引用元素的<em>指针</em>（即内存地址）。我们在这里使用<code>0x1001c</code>作为示例存储地址。而实际上，<code>element</code>字段必须是<code>array</code>字段最后一个元素的地址，所以这与该结构体在内存中的位置有关。由于此类结构体对自身的某些字段做了引用，因此这种具有内部指针的结构体也叫做<em>自引用</em>结构体。</p>
<h4 id="自引用结构体的问题"><a href="#自引用结构体的问题" class="headerlink" title="自引用结构体的问题"></a>自引用结构体的问题</h4><p>自引用结构的内部指针将导致一个很基本的问题，尤其是在查看其内存布局时会更加明显：</p>
<p><img src="https://os.phil-opp.com/async-await/self-referential-struct.svg" alt="自引用结构体"></p>
<p><code>array</code>字段从地址<code>0x10014</code>开始，<code>element</code>字段从地址<code>0x10020</code>开始。它指向地址<code>0x1001c</code>，即最后一个数组元素的地址。至此仍没什么问题。但是，当我们将此结构体移动到其他内存地址时，就会发生问题：</p>
<p><img src="https://os.phil-opp.com/async-await/self-referential-struct-moved.svg" alt="自引用结构体移动后"></p>
<p>稍微移动该结构体，现在使其从地址<code>0x10024</code>开始。这是有可能的，例如当我们将该结构体作为函数参数传递时，或是将其分配给其他栈变量时。问题在于，尽管最后一个数组元素现已位于地址<code>0x1002c</code>，但<code>element</code>字段仍指向地址<code>0x1001c</code>。于是指针悬空，结果就是在下一个<code>poll</code>调用中发生未定义的行为。</p>
<h4 id="可行的解决方案"><a href="#可行的解决方案" class="headerlink" title="可行的解决方案"></a>可行的解决方案</h4><p>有三种解决指针悬空问题的基本方法：</p>
<ul>
<li><strong>在移动时更新指针</strong>：思路是每当结构体在内存中移动时都更新其内部指针，以使该指针在移动后仍然有效。不幸的是，这种方法需要对Rust进行大量更改，并可能导致巨大的性能损失。因为如果实现这种方法，就需要某种运行时持续跟踪结构体中各种类型的字段，并在每次移动发生时检查是否需要更新指针。</li>
<li><strong>存储偏移量而不是自引用</strong>：为了不去更新指针，编译器可以尝试将自引用存储为从结构体开始地址算起的偏移量。例如，上面的<code>WaitingOnWriteState</code>结构的<code>element</code>字段可以以<code>element_offset</code>字段的形式存储，其值为8，因为该引用指向的数组元素位于该结构体的起始地址后的第8个字节处。由于在移动结构时偏移量保持不变，因此不需要字段更新。<br>问题是，如果实现这种方法，就必须让编译器检测所有自引用。这在编译时是不可能的，因为引用的值可能取决于用户输入，因此这又需要使用运行时系统来分析引用，从而正确地创建状态结构体。这不仅会导致运行时成本增加，而且还会阻止某些编译器优化，从而又会导致较大的性能损失。</li>
<li><strong>禁止移动结构体</strong>：如上所示，仅当我们在内存中移动该结构体时，才会出现悬空指针。那么，通过完全禁止对自引用结构的移动操作，就可以避免该问题。这种方法的最大优点是可以实现在类型系统级别，并不会增加运行时成本。不过它的缺点是需要程序员自己处理在可能的自引用结构体上发生的移动操作。</li>
</ul>
<p>为了遵守提供零成本抽象的原则（这意味着抽象不应产生额外的运行时成本），Rust选择了第三种解决方案。为此，在<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rfcs/blob/master/text/2349-pin.md">RFC 2349</a>中提出了<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/core/pin/index.html"><em>pinning</em></a> API。在下文中，我们将简要概述此API，并说明它将如何与async/await和futures一起使用。</p>
<h4 id="堆上的值"><a href="#堆上的值" class="headerlink" title="堆上的值"></a>堆上的值</h4><p>首先，很明显，<a target="_blank" rel="noopener" href="https://os.phil-opp.com/heap-allocation/">堆分配</a>的值在大多数情况下已经具有固定的内存地址。这些值是由<code>allocate</code>调用创建，并由如类似<code>Box&lt;T&gt;</code>的指针类型进行引用的。尽管这种指针类型可以移动，但指针所指向的堆值将始终位于相同的内存地址中，除非调用<code>deallocate</code>将其释放否则地址将一直不变。</p>
<p>使用堆分配，我们可以尝试创建一个自引用结构体：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> heap_value = <span class="built_in">Box</span>::new(SelfReferential &#123;</span><br><span class="line">        self_ptr: <span class="number">0</span> <span class="keyword">as</span> *<span class="keyword">const</span> _,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> ptr = &amp;*heap_value <span class="keyword">as</span> *<span class="keyword">const</span> SelfReferential;</span><br><span class="line">    heap_value.self_ptr = ptr;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;heap value at: &#123;:p&#125;&quot;</span>, heap_value);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;internal reference: &#123;:p&#125;&quot;</span>, heap_value.self_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SelfReferential</span></span> &#123;</span><br><span class="line">    self_ptr: *<span class="keyword">const</span> <span class="keyword">Self</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（<a target="_blank" rel="noopener" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=ce1aff3a37fcc1c8188eeaf0f39c97e8">使用play rust在线运行上面的代码</a>）</p>
<p>我们创建一个名为<code>SelfReferential</code>的简单结构体，其中包含一个指针字段。首先，我们使用空指针初始化结构体，然后使用<code>Box::new</code>将其分配到堆上。接下来，我们确定分配给堆的结构体的内存地址，并将其存储在<code>ptr</code>变量中。最后，通过将<code>ptr</code>变量分配给<code>self_ptr</code>字段，将结构体变为自引用结构体。</p>
<p>在<a target="_blank" rel="noopener" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=ce1aff3a37fcc1c8188eeaf0f39c97e8">play rust</a>上执行此代码时，会看到堆值的地址及其内部指针地址相同，这意味着<code>self_ptr</code>字段是有效的自引用。由于<code>heap_value</code>变量仅是一个指针，因此移动它（例如，通过将其传递给函数）不会更改结构体本身的地址，因此，即使移动了指针，<code>self_ptr</code>也依然有效。</p>
<p>但是，还是有一种方法可以破坏这个例子：我们可以移出<code>Box&lt;T&gt;</code>或替换其内容：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stack_value = mem::replace(&amp;<span class="keyword">mut</span> *heap_value, SelfReferential &#123;</span><br><span class="line">    self_ptr: <span class="number">0</span> <span class="keyword">as</span> *<span class="keyword">const</span> _,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;value at: &#123;:p&#125;&quot;</span>, &amp;stack_value);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;internal reference: &#123;:p&#125;&quot;</span>, stack_value.self_ptr);</span><br></pre></td></tr></table></figure>

<p>（<a target="_blank" rel="noopener" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=e160ee8a64cba4cebc1c0473dcecb7c8">使用play rust在线运行上面的代码</a>）</p>
<p>这里我们使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/mem/fn.replace.html"><code>mem::replace</code></a>函数，将堆分配内存中的原值替换为一个新结构体实例。这使我们可以将堆分配中的原值<code>heap_value</code>移动到栈中，而现在该结构体的<code>self_ptr</code>字段就是一个悬空指针了，它仍然指向旧的堆地址。当你尝试在<a target="_blank" rel="noopener" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=e160ee8a64cba4cebc1c0473dcecb7c8">play rust</a>上运行该代码时，就会看到<em>“value at:”</em>行和<em>“internal reference:”</em>行确实打印了不同的指针地址。因此，堆分配的值并不能完全保证自引用的安全性。</p>
<p>导致上述现象的根本问题是<code>Box&lt;T&gt;</code>允许我们获取对堆分配值的<code>&amp;mut T</code>引用。通过<code>&amp;mut</code>引用，就可以使用诸如<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/mem/fn.replace.html"><code>mem::replace</code></a>或<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/mem/fn.swap.html"><code>mem::swap</code></a>一类的方法来使堆分配的自引用值无效。要解决此问题，我们必须禁止创建对自引用结构的<code>&amp;mut</code>引用。</p>
<h4 id="Pin-lt-Box-lt-T-gt-gt-与Unpin"><a href="#Pin-lt-Box-lt-T-gt-gt-与Unpin" class="headerlink" title="Pin&lt;Box&lt;T&gt;&gt;与Unpin"></a><code>Pin&lt;Box&lt;T&gt;&gt;</code>与<code>Unpin</code></h4><p>Pinning API用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/core/pin/struct.Pin.html"><code>Pin</code></a>封装类型和<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/std/marker/trait.Unpin.html"><code>Unpin</code></a>标记trait的方式为<code>&amp;mut T</code>问题提供了解决方案。其思路是为<code>Pin</code>类型中所有可用于从<code>Unpin</code>trait上获取其封装值<code>&amp;mut</code>可变引用方法（例如<code>get_mut</code>或<code>deref_mut</code>）设置关卡。<code>Unpin</code>trait是<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits">自动trait</a>，即对于所有类型（显式声明退出的类型除外）都默认自动实现。而如果让自引用结构体显式声明退出<code>Unpin</code>，就再也没有（安全的）方法能够从<code>Pin&lt;Box&lt;T&gt;&gt;</code>类型中获取<code>&amp;mut T</code>可变引用了。如此便能够保证它们的内部自引用始终有效。</p>
<p>让我们更新上面的<code>SelfReferential</code>类型以选择取消<code>Unpin</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> core::marker::PhantomPinned;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SelfReferential</span></span> &#123;</span><br><span class="line">    self_ptr: *<span class="keyword">const</span> <span class="keyword">Self</span>,</span><br><span class="line">    _pin: PhantomPinned,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过为结构体添加类型为<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/marker/struct.PhantomPinned.html"><code>PhantomPinned</code></a>的第二个字段<code>_pin</code>来退出trait。这是一个零大小的标记类型，唯一目的就是<em>退出</em><code>Unpin</code>trait。鉴于自动trait的工作方式，只需一个非<code>Unpin</code>的字段就可以使整个结构体退出<code>Unpin</code>。</p>
<p>第二步是将示例中的<code>Box&lt;SelfReferential&gt;</code>类型更改为<code>Pin&lt;Box&lt;SelfReferential&gt;&gt;</code>类型。最简单的方法是使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html#method.pin"><code>Box::pin</code></a>函数代替<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html#method.new"><code>Box::new</code></a>来创建堆分配的值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> heap_value = <span class="built_in">Box</span>::pin(SelfReferential &#123;</span><br><span class="line">    self_ptr: <span class="number">0</span> <span class="keyword">as</span> *<span class="keyword">const</span> _,</span><br><span class="line">    _pin: PhantomPinned,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>除了将<code>Box::new</code>改为<code>Box::pin</code>，还需要在结构体初始字段中添加新的<code>_pin</code>字段。由于<code>PhantomPinned</code>是零大小的类型，因此我们只需要使用其类型名称即可进行初始化。</p>
<p>现在，当我们尝试<a target="_blank" rel="noopener" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=961b0db194bbe851ff4d0ed08d3bd98a">在play rust中运行修改后的示例代码</a>，会发现代码有编译错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">error[E0594]: cannot assign to data <span class="keyword">in</span> a dereference of `std::pin::Pin&lt;std::boxed::Box&lt;SelfReferential&gt;&gt;`</span><br><span class="line">  --&gt; src/main.rs:10:5</span><br><span class="line">   |</span><br><span class="line">10 |     heap_value.self_ptr = ptr;</span><br><span class="line">   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign</span><br><span class="line">   |</span><br><span class="line">   = <span class="built_in">help</span>: trait `DerefMut` is required to modify through a dereference, but it is not implemented <span class="keyword">for</span> `std::pin::Pin&lt;std::boxed::Box&lt;SelfReferential&gt;&gt;`</span><br><span class="line"></span><br><span class="line">error[E0596]: cannot borrow data <span class="keyword">in</span> a dereference of `std::pin::Pin&lt;std::boxed::Box&lt;SelfReferential&gt;&gt;` as mutable</span><br><span class="line">  --&gt; src/main.rs:16:36</span><br><span class="line">   |</span><br><span class="line">16 |     <span class="built_in">let</span> stack_value = mem::replace(&amp;mut *heap_value, SelfReferential &#123;</span><br><span class="line">   |                                    ^^^^^^^^^^^^^^^^ cannot borrow as mutable</span><br><span class="line">   |</span><br><span class="line">   = <span class="built_in">help</span>: trait `DerefMut` is required to modify through a dereference, but it is not implemented <span class="keyword">for</span> `std::pin::Pin&lt;std::boxed::Box&lt;SelfReferential&gt;&gt;`</span><br></pre></td></tr></table></figure>

<p>发生这两个错误都是由<code>Pin&lt;Box&lt;SelfReferential&gt;&gt;</code>类型不再实现<code>DerefMut</code>trait引起的。这正是我们期望的，因为<code>DerefMut</code>trait会返回一个<code>&amp;mut</code>引用，而我们希望禁止该引用。这两个错误就是因为我们既退出了<code>Unpin</code>，又将<code>Box::new</code>更改为<code>Box::pin</code>。</p>
<p>现在的问题是，编译器不仅禁止在第16行中移动该类型，而且还禁止在第10行中初始化<code>self_ptr</code>字段。之所以发生这种情况，是因为编译器无法区分<code>&amp;mut</code>引用的有效使用与无效使用。为了修复初始化一行的报错，我们必须使用非安全的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/pin/struct.Pin.html#method.get_unchecked_mut"><code>get_unchecked_mut</code></a>方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处操作是安全的，因为仅修改了结构体字段，而未进行整个结构体的移动</span></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> mut_ref = Pin::as_mut(&amp;<span class="keyword">mut</span> heap_value);</span><br><span class="line">    Pin::get_unchecked_mut(mut_ref).self_ptr = ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（<a target="_blank" rel="noopener" href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=b9ebbb11429d9d79b3f9fffe819e2018">使用play rust在线运行上面的代码</a>）</p>
<p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/pin/struct.Pin.html#method.get_unchecked_mut"><code>get_unchecked_mut</code></a>函数的参数应为<code>Pin&lt;&amp;mut T&gt;</code>而不是<code>Pin&lt;Box&lt;T&gt;&gt;</code>，因此我们必须先使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/pin/struct.Pin.html#method.as_mut"><code>Pin::as_mut</code></a>做转换。然后，我们就可以使用<code>get_unchecked_mut</code>返回的<code>&amp;mut</code>引用来设置<code>self_ptr</code>字段了。</p>
<p>现在剩下的错误就是我们期望的<code>mem::replace</code>一行的错误。请记住，此操作尝试将堆分配的值移动到栈上，这会破坏存储在<code>self_ptr</code>字段中的自引用。通过退出<code>Unpin</code>并使用<code>Pin&lt;Box&lt;T&gt;&gt;</code>，就可以在编译时禁止执行此类操作，从而可以安全地使用自引用结构体。如我们所见，编译器（目前）还不能检测创建的自引用结构体是否安全，因此我们需要使用非安全块并自己确保其正确性。</p>
<h4 id="栈上的pinning与Pin-lt-amp-mut-T-gt"><a href="#栈上的pinning与Pin-lt-amp-mut-T-gt" class="headerlink" title="栈上的pinning与Pin&lt;&amp;mut T&gt;"></a>栈上的pinning与<code>Pin&lt;&amp;mut T&gt;</code></h4><p>在上一节中，我们学习了如何使用<code>Pin&lt;Box&lt;T&gt;&gt;</code>安全地创建堆分配上的自引用结构体。尽管这种方法可以很好地工作并且相对安全（除了非安全的初始化），但方法所要求的堆分配会带来一些性能损失。由于Rust始终希望尽可能的提供<em>零成本抽象</em>，因此pinning API还允许创建指向栈分配值的<code>Pin&lt;&amp;mut T&gt;</code>实例。</p>
<p>与拥有封装值<em>所有权</em>的<code>Pin&lt;Box&lt;T&gt;&gt;</code>实例不同，<code>Pin&lt;&amp;mut T&gt;</code>实例仅临时借用其封装的值。这使事情变得更加复杂，因为它需要程序员自己确保引用带来的附加的条件。最重要的是，在被引用<code>T</code>的整个生命周期中，<code>Pin&lt;&amp;mut T&gt;</code>必须保持在pin的状态，这对于基于栈的变量来说会更加难以检查。为了处理这种问题，的确存在像<a target="_blank" rel="noopener" href="https://docs.rs/pin-utils/0.1.0-alpha.4/pin_utils/"><code>pin-utils</code></a>这样的crate，但是除非你真的知道自己在做什么，一般都不建议使用栈上的pinning。</p>
<p>要进一步阅读，请查看<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/pin/index.html"><code>pin</code>模块</a>和<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/pin/struct.Pin.html#method.new_unchecked"><code>Pin::new_unchecked</code></a>方法的文档。</p>
<h4 id="Pinning和Future"><a href="#Pinning和Future" class="headerlink" title="Pinning和Future"></a>Pinning和Future</h4><p>正如我们在本文中已经看到的那样，<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/future/trait.Future.html#tymethod.poll"><code>Future::poll</code></a>方法使用的pinning参数为<code>Pin&lt;&amp;mut Self&gt;</code>形式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context) -&gt; Poll&lt;Self::Output&gt;</span><br></pre></td></tr></table></figure>

<p>该方法采用<code>self: Pin&lt;&amp;mut Self&gt;</code>而不是常规<code>&amp;mut self</code>作参数的原因如<a href="./#%E8%87%AA%E5%BC%95%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93">前文</a>所述，从async/await创建的future实例通常是自引用的。通过将<code>Self</code>封装为<code>Pin</code>，并使编译器令async/await生成的自引用future退出<code>Unpin</code>，可以确保future在两次<code>poll</code>调用之间不会在内存中移动。如此便可以确保所有内部引用仍然有效。</p>
<p>值得注意的是，在第一个<code>poll</code>调用之前，移动future是可行的。这是因为future是惰性的，它在第一次poll之前什么也不做。所以生成状态机的”Start”状态仅包含函数参数，而没有内部引用。为了调用<code>poll</code>，调用者必须先将future封装到<code>Pin</code>中，以确保future不会在内存中移动。由于正确的使用栈pinning会更加困难，因此建议始终结合使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html#method.pin"><code>Box::pin</code></a>与<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/pin/struct.Pin.html#method.as_mut"><code>Pin::as_mut</code></a>。</p>
<p>如果你有兴趣了解如何使用栈pinning来安全地实现future组合器函数，可以选择查看<code>future</code>crate中<a target="_blank" rel="noopener" href="https://docs.rs/futures-util/0.3.4/src/futures_util/future/future/map.rs.html"><code>map</code>组合器方法源码</a>（该方法的源码相对简单），以及阅读有关pin文档中<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/pin/index.html#projections-and-structural-pinning">投影和结构的pinning</a>部分。</p>
<h3 id="执行器和唤醒器"><a href="#执行器和唤醒器" class="headerlink" title="执行器和唤醒器"></a>执行器和唤醒器</h3><p>使用async/await，可以最大限度的以完全异步的方式使用future。但是，正如我们从上面了解到的那样，future在被poll之前什么都不做。这意味着我们必须在某些时候发起对它们的<code>poll</code>，否则异步代码将永远不会执行。</p>
<p>对于单个future，我们总是可以使用<a href="./#%E7%AD%89%E5%BE%85Futures">上述</a>循环手动等待每个future。但是，这种方式效率很低，而且对于那些创建大量future的程序实际上并不可行。针对此问题的最常见解决方案是定义一个全局执行器，以负责轮询系统中的所有future，直到它们全部完成。</p>
<h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p>执行器的作用是将future生成为任务，通常是使用一些<code>spawn</code>方法。然后，执行器负责轮询所有future，直到它们全部完成。集中管理所有future的最大好处是，只要future返回<code>Poll::Pending</code>，执行器就可以切换到另一个future。所以异步操作可以并行运行，CPU也因此持续作业。</p>
<p>许多执行器的实现也能够利用多核CPU系统的优点。这些实现会创建一个<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Thread_pool">线程池</a>，如果提供足够多的任务，线程池就能利用所有内核，并使用像<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Work_stealing">work stealing</a>之类的技术来平衡核心间的负载。嵌入式系统还会有一些特殊的执行器实现，专门为降低延迟和减少内存开销做了优化。</p>
<p>为了避免重复轮询future的开销，执行器通常还利用Rust的future支持的唤醒器API。</p>
<h4 id="唤醒器"><a href="#唤醒器" class="headerlink" title="唤醒器"></a>唤醒器</h4><p>唤醒器API的思路是，将特殊的<code>Waker</code>类型封装在<code>Context</code>类型中，传递给每一次<code>poll</code>调用。这个<code>Waker</code>类型是由执行器创建的，异步任务可以用该类型表示任务已（部分）完成。于是，除非相应的唤醒器通知执行器，否则执行器都不需要在先前返回<code>Poll::Pending</code>的future上再进行<code>poll</code>调用了。</p>
<p>举个小例子可以很好地说明这一点：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">write_file</span></span>() &#123;</span><br><span class="line">    async_write_file(<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;Hello&quot;</span>).<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函数将字符串”Hello”异步写入<code>foo.txt</code>文件。由于硬盘写入需要一些时间，因此该future上的第一次<code>poll</code>调用可能会返回<code>Poll::Pending</code>。硬盘驱动将在内部存储传递给<code>poll</code>调用的<code>Waker</code>，并在完成文件写入时使用它通知执行器。如此，执行器在收到唤醒器的通知前，都不需要再在这个future上尝试<code>poll</code>了。</p>
<p>我们将在本文的实现一节创建具有唤醒器支持的执行器，届时将详细的看到<code>Waker</code>类型的工作原理。</p>
<h3 id="协作式多任务？"><a href="#协作式多任务？" class="headerlink" title="协作式多任务？"></a>协作式多任务？</h3><p>在本文的开头，我们讨论了抢先式多任务和协作式多任务。抢占式多任务依靠操作系统在运行中的任务间做强制切换，而协作式多任务则要求任务定期通过<em>yield</em>操作主动放弃对CPU的控制。协作式的最大优点是任务可以自己保存状态，从而更高效地进行上下文切换，并可以在任务间共享相同的调用栈。</p>
<p>这可能不够直观，不过future和async/await就是协作式多任务模式的实现：</p>
<ul>
<li>添加到执行器的每个future本质上都是一个协作任务。</li>
<li>Future不使用显式的yield操作，而是通过返回<code>Poll::Pending</code>（或完成时的<code>Poll::Ready</code>）来放弃对CPU核心的控制。<ul>
<li>没有什么可以强制future放弃CPU。如果它们愿意，就能够永不从<code>poll</code>中返回，如在一个无限循环中打转。</li>
<li>由于每个future都可以阻止执行器中其他future的执行，因此我们需要信任它们不是恶意的。</li>
</ul>
</li>
<li>Future在内部存储它在下一次<code>poll</code>调用时恢复执行所需的所有状态。使用async/await，编译器会自动检测所需的所有变量，并将其存储在生成的状态机中。<ul>
<li>仅保存恢复执行所需的最少状态。</li>
<li>由于<code>poll</code>方法在返回时会放弃调用栈，因此该栈可用于poll其他的future。</li>
</ul>
</li>
</ul>
<p>我们看到future和async/await完美契合协作式多任务，区别就是使用了一些不同的术语。因此，在下文中，我们将交替使用术语“任务”和“future”。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>现在，我们了解了Rust中基于future和async/await的协作式多任务的工作原理，是时候向我们的内核中添加对多任务的支持了。由于<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/future/trait.Future.html"><code>Future</code></a>trait是<code>core</code>库的一部分，而async/await是Rust语言本身的功能，因此在<code>#![no_std]</code>内核中使用无需其他操作就可以使用它们。唯一的要求是我们至少应使用Rust在2020-03-25之后的nightly版本，因为之前的async/await是不兼容<code>no_std</code>的。</p>
<p>只要使用较近的nightly版本，我们就可以在<code>main.rs</code>中使用async/await：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">async_number</span></span>() -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">example_task</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> number = async_number().<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;async number: &#123;&#125;&quot;</span>, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>async_number</code>函数是一个<code>async fn</code>，因此编译器将其转换为实现了<code>Future</code>trait的状态机。由于该函数仅返回<code>42</code>，因此生成的future将在首次<code>poll</code>调用时直接返回<code>Poll::Ready(42)</code>。像<code>async_number</code>一样，<code>example_task</code>函数也是一个<code>async fn</code>。 它等待<code>async_number</code>返回的数字，然后使用println宏将其打印出来。</p>
<p>要运行<code>example_task</code>返回的future，我们需要一直对其调用<code>poll</code>，到它通过返回<code>Poll::Ready</code>告知其已完成为止。为此，我们需要创建一个简单的执行器类型。</p>
<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>在实现执行器之前，我们要创建一个具有<code>Task</code>类型的新模块<code>task</code>：</p>
<figure class="highlight rust"><figcaption><span>in src/lib.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> task;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><figcaption><span>in src/task/mod.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> core::&#123;future::Future, pin::Pin&#125;;</span><br><span class="line"><span class="keyword">use</span> alloc::boxed::<span class="built_in">Box</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Task</span></span> &#123;</span><br><span class="line">    future: Pin&lt;<span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Future&lt;Output = ()&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Task</code>结构体是一个新的类型封装器，它封装了一个内存固定的、堆分配的、以空类型<code>()</code>作为输出的动态分发的future。让我们详细研究一下：</p>
<ul>
<li>我们要求与任务关联的future返回<code>()</code>。这意味着任务不会返回任何结果，只是为了执行其中的副作用。例如，我们上面定义的<code>example_task</code>函数也没有返回值，但是作为副作用，函数将一些信息打印在了屏幕上。</li>
<li><code>dyn</code>关键字告诉我们存放在<code>Box</code>中的是一个<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">trait对象</a>。这意味着future上的方法是<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch">动态分发</a>的，因此我们才可以在<code>Task</code>类型中存储不同类型的future。这很重要，因为每个<code>async fn</code>都有自己的future类型，而我们希望能够创建多个不同的任务。</li>
<li>正如我们在<a href="./#Pinning">pinning一节</a>了解到的那样，<code>Pin&lt;Box&gt;</code>类型通过将值放在堆上并防止对值创建&amp;mut引用来确保该值不会在内存中移动。这很重要，因为async/await生成的future可能是自引用的，即包含指向自身的指针，而该指针将在future移动时失效。</li>
</ul>
<p>为了能够适应future创建<code>Task</code>结构体，我们编写一个<code>new</code>函数：</p>
<figure class="highlight rust"><figcaption><span>in src/task/mod.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Task &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(future: <span class="keyword">impl</span> Future&lt;Output = ()&gt; + <span class="symbol">&#x27;static</span>) -&gt; Task &#123;</span><br><span class="line">        Task &#123;</span><br><span class="line">            future: <span class="built_in">Box</span>::pin(future),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数接受输出类型为<code>()</code>的任意future，然后通过<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html#method.pin"><code>Box::pin</code></a>函数将其固定在内存中。然后，函数将future封装在Task结构体中并返回。这里需要使用<code>&#39;static</code>生命周期，因为返回的<code>Task</code>生存时间不确定，因此future也必须在该时间内保持有效。</p>
<p>我们还添加了一个<code>poll</code>方法，使执行器可以轮询存储的future：</p>
<figure class="highlight rust"><figcaption><span>in src/task/mod.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> core::task::&#123;Context, Poll&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Task &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, context: &amp;<span class="keyword">mut</span> Context) -&gt; Poll&lt;()&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.future.as_mut().poll(context)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>Future</code>trait的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/future/trait.Future.html#tymethod.poll"><code>poll</code></a>方法需要在<code>Pin&lt;&amp;mut T&gt;</code>类型上调用，因此我们先要使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/pin/struct.Pin.html#method.as_mut"><code>Pin::as_mut</code></a>方法转换类型为<code>Pin&lt;Box&lt;T&gt;&gt;</code>的<code>self.future</code>字段。然后，在转换后的<code>self.future</code>字段上调用<code>poll</code>并返回结果。由于<code>Task::poll</code>方法仅应由我们稍后创建的执行器调用，因此保持其为<code>task</code>模块的私有函数。</p>
<h3 id="简单执行器"><a href="#简单执行器" class="headerlink" title="简单执行器"></a>简单执行器</h3><p>由于执行器可能非常复杂，因此我们有意在开始仅创建一个非常基本的执行器，然后再渐进的实现更多功能。为此，我们先创建一个新的<code>task::simple_executor</code>子模块：</p>
<figure class="highlight rust"><figcaption><span>in src/task/mod.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> simple_executor;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><figcaption><span>in src/task/simple_executor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> super::Task;</span><br><span class="line"><span class="keyword">use</span> alloc::collections::VecDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">SimpleExecutor</span></span> &#123;</span><br><span class="line">    task_queue: VecDeque&lt;Task&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> SimpleExecutor &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; SimpleExecutor &#123;</span><br><span class="line">        SimpleExecutor &#123;</span><br><span class="line">            task_queue: VecDeque::new(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">spawn</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, task: Task) &#123;</span><br><span class="line">        <span class="keyword">self</span>.task_queue.push_back(task)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该结构体包含一个<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/alloc/collections/vec_deque/struct.VecDeque.html"><code>VecDeque</code></a>类型的字段<code>task_queue</code>，这是一个在两端都能执行push和pop操作的向量。使用这种类型的思路是，通过<code>spawn</code>在队尾方法插入新任务，并从队首弹出要执行的下一个任务。这样，我们就得到了一个简单的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)">FIFO队列</a>（“先进先出”）。</p>
<h4 id="假唤醒器"><a href="#假唤醒器" class="headerlink" title="假唤醒器"></a>假唤醒器</h4><p>为了调用<code>poll</code>方法，我们需要创建一个<code>Context</code>类型，用来封装<code>Waker</code>类型。简单起见，我们将首先创建一个不执行任何操作的假唤醒器。为此，我们创建了<code>RawWaker</code>实例，用以定义不同<code>Waker</code>方法的实现，然后使用<code>Waker::from_raw</code>函数将其转换为<code>Waker</code>：</p>
<figure class="highlight rust"><figcaption><span>in src/task/simple_executor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> core::task::&#123;Waker, RawWaker&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dummy_raw_waker</span></span>() -&gt; RawWaker &#123;</span><br><span class="line">    todo!();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dummy_waker</span></span>() -&gt; Waker &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; Waker::from_raw(dummy_raw_waker()) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>from_raw</code>函数是非安全的，因为如果程序员不按照<code>RawWaker</code>文档的要求使用，就可能导致未定义的行为。在查看<code>dummy_raw_waker</code>函数的实现之前，我们首先尝试了解<code>RawWaker</code>类型的工作方式。</p>
<h5 id="RawWaker"><a href="#RawWaker" class="headerlink" title="RawWaker"></a><code>RawWaker</code></h5><p><code>RawWaker</code>类型要求程序员显式定义一个<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Virtual_method_table"><em>虚拟方法表</em></a>(<em>vtable</em>)，用以指定在克隆，唤醒、删除<code>RawWaker</code>时应调用的函数。vtable的布局由<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/core/task/struct.RawWakerVTable.html"><code>RawWakerVTable</code></a>类型定义。每个函数都接收一个<code>*const ()</code>参数，该参数本质上是一个指向某结构体的<em>擦除类型</em>的<code>&amp;self</code>指针，例如在堆上的分配。使用<code>*const ()</code>指针而不是某适当引用的原因是<code>RawWaker</code>类型应该是非泛型的，但仍需支持任意类型。作为参数传递给函数的指针值为给<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/core/task/struct.RawWaker.html#method.new"><code>RawWaker::new</code></a>的<code>data</code>指针。</p>
<p>通常，<code>RawWaker</code>结构体是为封装在<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/alloc/boxed/struct.Box.html"><code>Box</code></a>或<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/alloc/sync/struct.Arc.html"><code>Arc</code></a>类型中的某些堆分配而创建的。对于这些类型，可以使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/alloc/boxed/struct.Box.html#method.into_raw"><code>Box::into_raw</code></a>之类的方法将<code>Box&lt;T&gt;</code>转换为<code>*const T</code>指针。然后可以将该指针转换为匿名<code>*const ()</code>指针，再传递给<code>RawWaker::new</code>。由于每个vtable函数都使用相同的<code>*const ()</code>作为参数，因此这些函数可以安全地将指针转换回<code>Box&lt;T&gt;</code>或<code>&amp;T</code>以执行操作。可以想象，此过程非常危险，很容易出错导致未定义行为。因此，若非必要，则并不建议手动创建<code>RawWaker</code>。</p>
<h5 id="一个假的RawWaker"><a href="#一个假的RawWaker" class="headerlink" title="一个假的RawWaker"></a>一个假的<code>RawWaker</code></h5><p>虽然不建议手动创建<code>RawWaker</code>，但目前还没有其他方法可以创建不执行任何操作的假<code>Waker</code>。幸运的是，不执行任何操作也会使得实现<code>dummy_raw_waker</code>函数变得相对安全：</p>
<figure class="highlight rust"><figcaption><span>in src/task/simple_executor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> core::task::RawWakerVTable;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dummy_raw_waker</span></span>() -&gt; RawWaker &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">no_op</span></span>(_: *<span class="keyword">const</span> ()) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clone</span></span>(_: *<span class="keyword">const</span> ()) -&gt; RawWaker &#123;</span><br><span class="line">        dummy_raw_waker()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> vtable = &amp;RawWakerVTable::new(clone, no_op, no_op, no_op);</span><br><span class="line">    RawWaker::new(<span class="number">0</span> <span class="keyword">as</span> *<span class="keyword">const</span> (), vtable)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们定义两个名为<code>no_op</code>和<code>clone</code>的内部函数。<code>no_op</code>函数接受<code>* const()</code>指针，不执行任何操作。<code>clone</code>函数也接受<code>* const()</code>指针，并通过再次调用<code>dummy_raw_waker</code>返回一个新的<code>RawWaker</code>。我们使用这两个函数来创建最小化的<code>RawWakerVTable</code>：<code>clone</code>函数用于克隆操作，<code>no_op</code>函数用于其他所有操作。由于<code>RawWaker</code>不执行任何操作，因此从<code>clone</code>返回的是一个新<code>RawWaker</code>还是一个真正的克隆其实并不重要。</p>
<p>创建<code>vtable</code>之后，我们使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/core/task/struct.RawWaker.html#method.new"><code>RawWaker::new</code></a>函数创建<code>RawWaker</code>。传递的<code>* const()</code>无关紧要，因为并没有任何vtable的函数会使用它。于是我们只传递了一个空指针。</p>
<h4 id="一个run方法"><a href="#一个run方法" class="headerlink" title="一个run方法"></a>一个<code>run</code>方法</h4><p>现在，我们有了创建<code>Waker</code>实例的方法，就可以使用它在执行器上实现<code>run</code>方法。最简单的<code>run</code>方法是在循环中不停的poll所有队列中的任务，直到所有任务均已完成。这并不高效，因为它没有利用<code>Waker</code>类型的通知功能，但是它是使示例能够运行起来的的最简单方法：</p>
<figure class="highlight rust"><figcaption><span>in src/task/simple_executor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> core::task::&#123;Context, Poll&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> SimpleExecutor &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="keyword">mut</span> task) = <span class="keyword">self</span>.task_queue.pop_front() &#123;</span><br><span class="line">            <span class="keyword">let</span> waker = dummy_waker();</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> context = Context::from_waker(&amp;waker);</span><br><span class="line">            <span class="keyword">match</span> task.poll(&amp;<span class="keyword">mut</span> context) &#123;</span><br><span class="line">                Poll::Ready(()) =&gt; &#123;&#125; <span class="comment">// 任务已完成</span></span><br><span class="line">                Poll::Pending =&gt; <span class="keyword">self</span>.task_queue.push_back(task),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数使用<code>while let</code>循环来处理<code>task_queue</code>中的所有任务。对于每个任务，我们首先把由<code>dummy_waker</code>函数返回的<code>Waker</code>实例封装为<code>Context</code>类型。然后调用<code>Task::poll</code>方法并使用该<code>context</code>做参数。如果<code>poll</code>方法返回<code>Poll :: Ready</code>，则说明任务已完成，就可以继续执行下一个任务。如果任务仍然处于<code>Poll::Pending</code>，则将其再次添加到队尾，以便在后续的循环中再次轮询它。</p>
<h4 id="尝试运行"><a href="#尝试运行" class="headerlink" title="尝试运行"></a>尝试运行</h4><p>使用我们的<code>SimpleExecutor</code>类型，现在就可以尝试在<code>main.rs</code>中运行<code>example_task</code>函数返回的任务了：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> blog_os::task::&#123;Task, simple_executor::SimpleExecutor&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">kernel_main</span></span>(boot_info: &amp;<span class="symbol">&#x27;static</span> BootInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="comment">// […] initialization routines, including `init_heap`</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> executor = SimpleExecutor::new();</span><br><span class="line">    executor.spawn(Task::new(example_task()));</span><br><span class="line">    executor.run();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// […] test_main, &quot;it did not crash&quot; message, hlt_loop</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Below is the example_task function again so that you don&#x27;t have to scroll up</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">async_number</span></span>() -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">example_task</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> number = async_number().<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;async number: &#123;&#125;&quot;</span>, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码，将看到预期的消息”<em>async number: 42</em>“打印到屏幕上：</p>
<p><img src="https://os.phil-opp.com/async-await/qemu-simple-executor.png" alt="QEMU简单执行器"></p>
<p>我们来总结一下示例中执行的各个步骤：</p>
<ul>
<li>首先，我们创建一个带有空<code>task_queue</code>的<code>SimpleExecutor</code>类型实例。</li>
<li>接下来，我们调用异步<code>example_task</code>函数，该函数返回的是future。将这个future封装在<code>Task</code>类型中，以将其移动到堆中并固定在内存中，然后通过<code>spawn</code>方法将该任务添加到执行器的<code>task_queue</code>中。</li>
<li>然后，我们调用<code>run</code>方法以开始执行队列中的单个任务。这涉及：<ul>
<li>从<code>task_queue</code>队首弹出任务。</li>
<li>为任务创建<code>RawWaker</code>，将其转换为<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/task/struct.Waker.html"><code>Waker</code></a>实例，然后用它创建<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/task/struct.Context.html"><code>Context</code></a>实例。</li>
<li>在任务的future上调用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/future/trait.Future.html#tymethod.poll"><code>poll</code></a>方法，并传入我们刚才创建的<code>Context</code>实例。</li>
<li>由于<code>example_task</code>不会等待任何操作，因此可以直接运行到第一次<code>poll</code>调用为止。这就是打印”<em>async number: 42</em>“位置。</li>
<li>由于<code>example_task</code>将立刻返回<code>Poll::Ready</code>，因此并不会将其再添加回任务队列。</li>
</ul>
</li>
</ul>
<p>在<code>task_queue</code>为空后，<code>run</code>方法返回。之后，我们的<code>kernel_main</code>函数将继续执行，并打印”<em>It did not crash!</em>“信息。</p>
<h3 id="异步键盘输入"><a href="#异步键盘输入" class="headerlink" title="异步键盘输入"></a>异步键盘输入</h3><p>这个简单执行器并不能利用<code>Waker</code>通知，只会循环遍历所有任务直到它们完成。对于我们的示例，这并不是问题，因为我们的<code>example_task</code>在首次执行<code>poll</code>时就可以直接完成。要能观察到一个正确的<code>Waker</code>实现所带来的性能优势，我们首先需要创建一个真正异步的任务，即可能会在首次<code>poll</code>调用中返回<code>Poll::Pending</code>的任务。</p>
<p>其实我们的系统中已经存在了一些异步特性：硬件中断。正如我们在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/hardware-interrupts/"><em>硬件中断</em></a>一文中了解到的那样，硬件中断可以在任意时刻发生，这是由某些外部设备所决定的。例如，在经过一段预定义的时间后，硬件计时器会将中断发送到CPU。当CPU接收到中断时，它会立即将控制权转移给在中断描述符表(IDT)中定义的相应处理函数。</p>
<p>下面，我们将基于键盘中断创建一个异步任务。键盘中断是一个很好的选择，因为它既具有不确定性又对延迟有很高的要求。不确定性意味着无法预测下一次按键的发生时间，因为这完全取决于用户。低延迟是指我们要及时处理键盘输入，否则用户会感到滞后。为了以一种更高效的方式支持此类任务，执行器就需要对<code>Waker</code>通知提供适当的支持。</p>
<h4 id="键盘扫描码队列"><a href="#键盘扫描码队列" class="headerlink" title="键盘扫描码队列"></a>键盘扫描码队列</h4><p>我们当前仍是直接在中断处理程序中处理键盘输入。长远考虑这并不是一个好主意，因为中断处理程序应保持尽可能短，以免长时间中断重要工作。因此，中断处理程序应仅执行必要的最少量的工作（如键盘扫描码的读取），而将其余工作（如键盘扫描码的解释）留给后台任务。</p>
<p>将工作委派给后台任务的常见模式是创建某种队列。中断处理程序将工作单元推送到队列，而后台任务处理程序从队列中取出工作以进行处理。对于我们的键盘中断，就是中断处理程序仅从键盘读取扫描代码，并将其推送到队列，然后直接返回。键盘任务从队列的另一端取出扫描码，并对每个扫描码进行解释和处理：</p>
<p><img src="https://os.phil-opp.com/async-await/scancode-queue.svg" alt="扫描码队列"></p>
<p>可以用一个由互斥锁保护的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/alloc/collections/vec_deque/struct.VecDeque.html"><code>VecDeque</code></a>来简单的实现该队列。但是，在中断处理程序中使用互斥锁并不是一个好主意，因为很容易导致死锁。例如，当用户在键盘任务锁定队列时又按下了某个键，中断处理程序将再次尝试获取该锁，这会导致死锁。这种方法的另一个问题是，当<code>VecDeque</code>已满时，就会通过执行新的堆分配来自动增加队列容量。这可能又会导致死锁，因为我们的分配器还在内部使用了互斥锁。还有更深层次的问题，当堆碎片化时，堆分配可能会花费大量时间甚至会分配失败。</p>
<p>为避免这些问题，我们需要一个<code>push</code>操作不涉及互斥量或堆分配的队列实现。这种队列可以通过使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/sync/atomic/index.html">无锁原子操作</a>来实现元素的push和pop。如此，就可以创建只需要<code>&amp;self</code>引用即可使用的<code>push</code>和<code>pop</code>操作，因此也无需互斥锁。为了避免在<code>push</code>时执行堆分配，可以通过预先分配的固定大小的缓冲区来支持队列空间扩展。尽管这会让队列有界（即有最大长度限制），但在实际操作中通常能够为队列长度定义一个合理的上限，这并不是一个大问题。</p>
<h5 id="crossbeamcrate"><a href="#crossbeamcrate" class="headerlink" title="crossbeamcrate"></a><code>crossbeam</code>crate</h5><p>以正确且高效的方式实现这样的队列是一件非常困难的事，因此建议使用经过良好测试的现有实现。<code>crossbeam</code>是一个流行的Rust项目，它实现了多种用于并发编程的无互斥类型。该crate提供的<code>ArrayQueue</code>正是我们需要的类型。更加幸运的是，该类型恰好与具有堆分配支持的<code>no_std</code>crate完全兼容。</p>
<p>要使用该类型，我们需要添加<code>crossbeam-queue</code>crate依赖：</p>
<figure class="highlight toml"><figcaption><span>in Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies.crossbeam-queue]</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.2.1&quot;</span></span><br><span class="line"><span class="attr">default-features</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">features</span> = [<span class="string">&quot;alloc&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>该crate默认依赖标准库。为了使其与<code>no_std</code>兼容，我们需要禁用其默认特性并启用<code>alloc</code>特性。（请注意，在这里选择主<code>crossbeam</code>crate作为依赖将不能工作，因为它缺少用于<code>no_std</code>的<code>queue</code>模块导出。我们提交了一个<a target="_blank" rel="noopener" href="https://github.com/crossbeam-rs/crossbeam/pull/480">pull请求</a>来解决此问题，但该修改尚未在crates.io上发布。）</p>
<h5 id="队列实现"><a href="#队列实现" class="headerlink" title="队列实现"></a>队列实现</h5><p>有了<code>ArrayQueue</code>类型，我们就可以在新的<code>task::keyboard</code>模块中创建全局的扫描码队列了：</p>
<figure class="highlight rust"><figcaption><span>in src/task/mod.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> keyboard;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><figcaption><span>in src/task/keyboard.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> conquer_once::spin::OnceCell;</span><br><span class="line"><span class="keyword">use</span> crossbeam_queue::ArrayQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> SCANCODE_QUEUE: OnceCell&lt;ArrayQueue&lt;<span class="built_in">u8</span>&gt;&gt; = OnceCell::uninit();</span><br></pre></td></tr></table></figure>

<p>由于<a target="_blank" rel="noopener" href="https://docs.rs/crossbeam/0.7.3/crossbeam/queue/struct.ArrayQueue.html#method.new"><code>ArrayQueue::new</code></a>需要执行堆分配，而这在编译时是不可行的（<a target="_blank" rel="noopener" href="https://github.com/rust-lang/const-eval/issues/20">到目前为止</a>），所以我们不能直接初始化该静态变量。为此，我们使用了<a target="_blank" rel="noopener" href="https://docs.rs/conquer-once/0.2.0/conquer_once/index.html"><code>conquer_once</code></a>crate的<a target="_blank" rel="noopener" href="https://docs.rs/conquer-once/0.2.0/conquer_once/raw/struct.OnceCell.html"><code>OnceCell</code></a>类型，以能够安全的执行一次性静态变量的初始化。为了使用该crate，我们需要将其作为依赖项添加到<code>Cargo.toml</code>中：</p>
<figure class="highlight toml"><figcaption><span>in Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies.conquer-once]</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.2.0&quot;</span></span><br><span class="line"><span class="attr">default-features</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>我们确实也可以在这里使用<a target="_blank" rel="noopener" href="https://docs.rs/lazy_static/1.4.0/lazy_static/index.html"><code>lazy_static</code></a>宏来代替<a target="_blank" rel="noopener" href="https://docs.rs/conquer-once/0.2.0/conquer_once/raw/struct.OnceCell.html"><code>OnceCell</code></a>。不过<code>OnceCell</code>类型的优点是能够确保初始化不会在中断处理程序中发生，从而阻止中断处理程序执行堆分配。</p>
<h4 id="填充队列"><a href="#填充队列" class="headerlink" title="填充队列"></a>填充队列</h4><p>为了填充扫描代队列，我们创建了一个新的<code>add_scancode</code>函数，以从中断处理程序中调用：</p>
<figure class="highlight rust"><figcaption><span>in src/task/keyboard.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::println;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 由键盘中断调用程序调用</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// 该函数不应阻塞或执行堆分配</span></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">crate</span>) <span class="function"><span class="keyword">fn</span> <span class="title">add_scancode</span></span>(scancode: <span class="built_in">u8</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Ok</span>(queue) = SCANCODE_QUEUE.try_get() &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Err</span>(_) = queue.push(scancode) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;WARNING: scancode queue full; dropping keyboard input&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;WARNING: scancode queue uninitialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<a target="_blank" rel="noopener" href="https://docs.rs/conquer-once/0.2.0/conquer_once/raw/struct.OnceCell.html#method.try_get"><code>OnceCell::try_get</code></a>函数来获取对初始化队列的引用。如果队列尚未初始化，就忽略键盘扫描码并直接打印警告。要注意的是，不能在此函数中初始化队列，因为它将被中断处理程序调用，而我们不应该在中断处理的过程中执行堆分配。由于不应从<code>main.rs</code>中调用此函数，因此我们使用<code>pub(crate)</code>使该函数仅可在<code>lib.rs</code>中使用。</p>
<p><a target="_blank" rel="noopener" href="https://docs.rs/crossbeam/0.7.3/crossbeam/queue/struct.ArrayQueue.html#method.push"><code>ArrayQueue::push</code></a>方法只需<code>&amp;self</code>引用即可执行，这使得我们能够非常简单的从静态队列上调用该方法。<code>ArrayQueue</code>类型本身执行所有必要的同步，因此这里不需要使用互斥类封装。如果队列已满，我们也会打印警告。</p>
<p>要在键盘中断上调用<code>add_scancode</code>函数，就需要在<code>interrupts</code>模块中更新<code>keyboard_interrupt_handler</code>函数：</p>
<figure class="highlight rust"><figcaption><span>in src/interrupts.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;x86-interrupt&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">keyboard_interrupt_handler</span></span>(</span><br><span class="line">    _stack_frame: &amp;<span class="keyword">mut</span> InterruptStackFrame</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">use</span> x86_64::instructions::port::Port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> port = Port::new(<span class="number">0x60</span>);</span><br><span class="line">    <span class="keyword">let</span> scancode: <span class="built_in">u8</span> = <span class="keyword">unsafe</span> &#123; port.read() &#125;;</span><br><span class="line">    crate::task::keyboard::add_scancode(scancode); <span class="comment">// new</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        PICS.lock()</span><br><span class="line">            .notify_end_of_interrupt(InterruptIndex::Keyboard.as_u8());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们从该函数中删除了所有键盘事件处理的代码，并添加了对<code>add_scancode</code>函数的调用，其余代码保持不变。</p>
<p>正如预期，现在使用<code>cargo run</code>运行内核时，每次按键不再显示在屏幕上，取而代之的是，每次按键时都会看到队列未初始化的警告。</p>
<h4 id="扫描码流"><a href="#扫描码流" class="headerlink" title="扫描码流"></a>扫描码流</h4><p>为了初始化<code>SCANCODE_QUEUE</code>并以异步方式从队列中读取扫描码，我们创建了一个新的<code>ScancodeStream</code>类型：</p>
<figure class="highlight rust"><figcaption><span>in src/task/keyboard.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ScancodeStream</span></span> &#123;</span><br><span class="line">    _private: (),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> ScancodeStream &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        SCANCODE_QUEUE.try_init_once(|| ArrayQueue::new(<span class="number">100</span>))</span><br><span class="line">            .expect(<span class="string">&quot;ScancodeStream::new should only be called once&quot;</span>);</span><br><span class="line">        ScancodeStream &#123; _private: () &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_private</code>字段用于阻止从本模块外构造结构体的行为。这使得<code>new</code>函数成为构造该类的唯一方法。在函数中，我们首先尝试初始化<code>SCANCODE_QUEUE</code>静态变量。如果它已初始化，我们就产生一个panic，如此确保只会存在一个<code>ScancodeStream</code>实例。</p>
<p>为了使扫描码可用于异步任务，下一步是实现一个类似<code>poll</code>的方法，以尝试从队列中弹出下一个扫描码。虽然这听上去似乎是我们应该为该类型实现<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/future/trait.Future.html"><code>Future</code></a>trait，但在这里实际上并不是。问题在于，<code>Future</code>trait仅对单个异步值进行抽象，并且期望在它返回<code>Poll::Ready</code>之后不会再次调用<code>poll</code>方法。但是，我们的扫描码队列包含多个异步值，因此可以持续对其进行轮询。</p>
<h5 id="Streamtrait"><a href="#Streamtrait" class="headerlink" title="Streamtrait"></a><code>Stream</code>trait</h5><p>由于产生多个异步值的类型很常见，因此<a target="_blank" rel="noopener" href="https://docs.rs/futures/0.3.4/futures/"><code>future</code></a>crate为此类提供了有用的抽象：<a target="_blank" rel="noopener" href="https://rust-lang.github.io/async-book/05_streams/01_chapter.html"><code>Stream</code></a>trait。其定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Stream</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll_next</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context)</span><br><span class="line">        -&gt; Poll&lt;<span class="built_in">Option</span>&lt;Self::Item&gt;&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此定义与<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/future/trait.Future.html"><code>Future</code></a>trait非常相似，但有以下区别：</p>
<ul>
<li>关联的类型叫做<code>Item</code>而不是<code>Output</code>。</li>
<li>与返回<code>Poll&lt;Self::Item&gt;</code>的<code>poll</code>方法不同，<code>Stream</code>trait定义了一个返回<code>Poll&lt;Option&lt;Self::Item&gt;&gt;</code>的<code>poll_next</code>方法（请注意附加的<code>Option</code>）。</li>
</ul>
<p>此外还有一个语义上的区别：<code>poll_next</code>可以被重复调用，直到返回<code>Poll::Ready(None)</code>来表示流已完成。从这方面来看，该方法类似于<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/core/iter/trait.Iterator.html#tymethod.next"><code>Iterator::next</code></a>方法，即也会在返回最后一个值之后就只返回<code>None</code>。</p>
<h5 id="实现Stream"><a href="#实现Stream" class="headerlink" title="实现Stream"></a>实现<code>Stream</code></h5><p>让我们为<code>ScancodeStream</code>实现<code>Stream</code>trait，以便使用异步方式提供<code>SCANCODE_QUEUE</code>中的值。为此，我们首先需要添加对<code>futures-util</code>crate的依赖，其中就包含<code>Stream</code>类型：</p>
<figure class="highlight toml"><figcaption><span>in Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies.futures-util]</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.3.4&quot;</span></span><br><span class="line"><span class="attr">default-features</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">features</span> = [<span class="string">&quot;alloc&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>我们禁用默认特性以使crate兼容<code>no_std</code>，并启用<code>alloc</code>特性以使其基于堆分配的类型可用（稍后将需要它）。（请注意，我们确实可以添加对主<code>futures</code>crate的依赖，从而重新导出<code>futures-util</code>crate，但这将产生更多的依赖和更长的编译时间。）</p>
<p>现在我们可以导入并实现<code>Stream</code>trait：</p>
<figure class="highlight rust"><figcaption><span>in src/task/keyboard.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> core::&#123;pin::Pin, task::&#123;Poll, Context&#125;&#125;;</span><br><span class="line"><span class="keyword">use</span> futures_util::stream::Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Stream <span class="keyword">for</span> ScancodeStream &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = <span class="built_in">u8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll_next</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context) -&gt; Poll&lt;<span class="built_in">Option</span>&lt;<span class="built_in">u8</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> queue = SCANCODE_QUEUE.try_get().expect(<span class="string">&quot;not initialized&quot;</span>);</span><br><span class="line">        <span class="keyword">match</span> queue.pop() &#123;</span><br><span class="line">            <span class="literal">Ok</span>(scancode) =&gt; Poll::Ready(<span class="literal">Some</span>(scancode)),</span><br><span class="line">            <span class="literal">Err</span>(crossbeam_queue::PopError) =&gt; Poll::Pending,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先使用<a target="_blank" rel="noopener" href="https://docs.rs/conquer-once/0.2.0/conquer_once/raw/struct.OnceCell.html#method.try_get"><code>OnceCell::try_get</code></a>方法来获取初始化的扫描码队列的引用。此操作应该不会失败，因为我们已在<code>new</code>函数中执行了队列初始化，所以可以放心的使用<code>expect</code>，以在未初始化队列时直接panic。接下来，我们使用<a target="_blank" rel="noopener" href="https://docs.rs/crossbeam/0.7.3/crossbeam/queue/struct.ArrayQueue.html#method.pop"><code>ArrayQueue::pop</code></a>方法尝试从队列中获取下一个元素。如果成功，我们将返回封装在<code>Poll::Ready(Some(…))</code>中的扫描代码。如果失败，则意味着队列已空。在这种情况下，我们返回<code>Poll::Pending</code>。</p>
<h4 id="唤醒器支持"><a href="#唤醒器支持" class="headerlink" title="唤醒器支持"></a>唤醒器支持</h4><p>与<code>Futures::poll</code>方法类似，<code>Stream::poll_next</code>方法要求异步任务在返回<code>Poll::Pending</code>之后才就绪时通知执行器。如此，执行器就不需要再次轮询相同的任务，任务完成会自动通知执行器，这大大降低了等待任务时的性能开销。</p>
<p>要发送此类通知，任务应从参数<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/task/struct.Context.html"><code>Context</code></a>引用中获取<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/task/struct.Waker.html"><code>Waker</code></a>并将其储存在某处。当任务就绪时，它应该在储存的<code>Waker</code>上调用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/core/task/struct.Waker.html#method.wake"><code>wake</code></a>方法，以通知执行者应该再次轮询该任务了。</p>
<h5 id="原子化的唤醒器"><a href="#原子化的唤醒器" class="headerlink" title="原子化的唤醒器"></a>原子化的唤醒器</h5><p>要为我们的<code>ScancodeStream</code>实现<code>Waker</code>通知功能，就需要一个可以在两次轮询调用之间储存<code>Waker</code>的地方。不能将其存储为<code>ScancodeStream</code>的字段中，因为我们需要从<code>add_scancode</code>函数进行访问。解决方案是使用由<code>Futures-util</code>crate提供的<a target="_blank" rel="noopener" href="https://docs.rs/futures-util/0.3.4/futures_util/task/struct.AtomicWaker.html"><code>AtomicWaker</code></a>类型创建静态变量。与<code>ArrayQueue</code>类型类似，此类型基于原子化的指令，可以被安全地存放在静态变量中，并支持并发修改。</p>
<p>定义一个<a target="_blank" rel="noopener" href="https://docs.rs/futures-util/0.3.4/futures_util/task/struct.AtomicWaker.html"><code>AtomicWaker</code></a>类型的静态变量<code>WAKER</code>：</p>
<figure class="highlight rust"><figcaption><span>in src/task/keyboard.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> futures_util::task::AtomicWaker;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> WAKER: AtomicWaker = AtomicWaker::new();</span><br></pre></td></tr></table></figure>

<p>思路是<code>poll_next</code>的实现将当前的唤醒器存储在此静态变量中，当将新的扫描码添加到队列时，<code>add_scancode</code>函数将在其上调用<code>wake</code>函数。</p>
<h5 id="储存唤醒器"><a href="#储存唤醒器" class="headerlink" title="储存唤醒器"></a>储存唤醒器</h5><p><code>poll</code>/<code>poll_next</code>的协议要求任务在返回<code>Poll::Pending</code>时为传递的<code>Waker</code>注册唤醒。让我们修改<code>poll_next</code>的实现以满足此要求：</p>
<figure class="highlight rust"><figcaption><span>in src/task/keyboard.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Stream <span class="keyword">for</span> ScancodeStream &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = <span class="built_in">u8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll_next</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context) -&gt; Poll&lt;<span class="built_in">Option</span>&lt;<span class="built_in">u8</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> queue = SCANCODE_QUEUE</span><br><span class="line">            .try_get()</span><br><span class="line">            .expect(<span class="string">&quot;scancode queue not initialized&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fast path</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Ok</span>(scancode) = queue.pop() &#123;</span><br><span class="line">            <span class="keyword">return</span> Poll::Ready(<span class="literal">Some</span>(scancode));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WAKER.register(&amp;cx.waker());</span><br><span class="line">        <span class="keyword">match</span> queue.pop() &#123;</span><br><span class="line">            <span class="literal">Ok</span>(scancode) =&gt; &#123;</span><br><span class="line">                WAKER.take();</span><br><span class="line">                Poll::Ready(<span class="literal">Some</span>(scancode))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">Err</span>(crossbeam_queue::PopError) =&gt; Poll::Pending,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像以前一样，我们首先使用<a target="_blank" rel="noopener" href="https://docs.rs/conquer-once/0.2.0/conquer_once/raw/struct.OnceCell.html#method.try_get"><code>OnceCell::try_get</code></a>函数来获取对初始化的扫描码队列的引用。然后，我们乐观地尝试从队列中<code>pop</code>任务并在成功时返回<code>Poll::Ready</code>。如此，就可以避免在队列非空时注册唤醒其的性能开销。</p>
<p>如果对<code>queue.pop()</code>的第一次调用并未成功，则该队列有可能为空。仅仅有可能为空，是因为中断处理程序也许是在轮询检查后立即异步填充了队列。由于此竞争条件可能在下一次轮询检查时再次发生，因此我们需要在第二次检查之前在<code>WAKER</code>静态变量中注册<code>Waker</code>。这样，尽管在<code>Poll::Pending</code>返回之前也可能发起唤醒，但是可以保证我们能够收到所有在轮询检查后推送的扫描码。</p>
<p>使用<a target="_blank" rel="noopener" href="https://docs.rs/futures-util/0.3.4/futures_util/task/struct.AtomicWaker.html#method.register"><code>AtomicWaker::register</code></a>函数注册<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/task/struct.Context.html"><code>Context</code></a>参数中包含的<code>Waker</code>之后，我们再次尝试从队列中弹出任务。如果这次能成功，则返回<code>Poll::Ready</code>。此时还需要使用<a target="_blank" rel="noopener" href="https://docs.rs/futures/0.3.4/futures/task/struct.AtomicWaker.html#method.take"><code>AtomicWaker::take</code></a>删除这个注册的唤醒器，因为任务已完成就不再需要唤醒器通知了。如果<code>queue.pop()</code>又失败了，我们仍将像以前一样返回<code>Poll::Pending</code>，区别是这次注册了唤醒器。</p>
<p>请注意，对于没有（或尚未）返回<code>Poll::Pending</code>的任务，可以通过两种方式进行唤醒。一种方法是在唤醒立刻发生于返回<code>Poll::Pending</code>之前，那么就使用上面提到的竞争条件。另一种方法是由于注册了唤醒器使得队列不再为空时，返回<code>Poll::Ready</code>。由于这些假唤醒是无法避免的，因此执行器必须能够正确处理它们。</p>
<h5 id="唤醒储存的唤醒器"><a href="#唤醒储存的唤醒器" class="headerlink" title="唤醒储存的唤醒器"></a>唤醒储存的唤醒器</h5><p>为了唤醒存储的<code>Waker</code>，我们在<code>add_scancode</code>函数中添加对<code>WAKER.wake()</code>的调用：</p>
<figure class="highlight rust"><figcaption><span>in src/task/keyboard.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span>(<span class="keyword">crate</span>) <span class="function"><span class="keyword">fn</span> <span class="title">add_scancode</span></span>(scancode: <span class="built_in">u8</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Ok</span>(queue) = SCANCODE_QUEUE.try_get() &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Err</span>(_) = queue.push(scancode) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;WARNING: scancode queue full; dropping keyboard input&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            WAKER.wake(); <span class="comment">// new</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;WARNING: scancode queue uninitialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处的唯一修改就是，如果成功推送到扫描码队列，就调用<code>WAKER.wake()</code>。如果静态变量<code>WAKER</code>中已经注册了一个唤醒器，则此方法将在其上调用同名的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/core/task/struct.Waker.html#method.wake"><code>wake</code></a>方法，以通知执行器。否则，该操作将为空操作，即没有任何效果。</p>
<p>重要的是，我们必须在推送到队列后才能调用<code>wake</code>，否则在队列仍然为空时可能会过早唤醒任务。一个可能的例子，就是一个多线程执行器在CPU的其他核心中并发的唤醒任务时。虽然现在内核还不支持线程，但也会尽快添加，我们当然不希望那时再出问题。</p>
<h4 id="键盘任务"><a href="#键盘任务" class="headerlink" title="键盘任务"></a>键盘任务</h4><p>我们为<code>ScancodeStream</code>实现了<code>Stream</code>trait，现在就可以创建异步键盘任务了：</p>
<figure class="highlight rust"><figcaption><span>n src/task/keyboard.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> futures_util::stream::StreamExt;</span><br><span class="line"><span class="keyword">use</span> pc_keyboard::&#123;layouts, DecodedKey, HandleControl, Keyboard, ScancodeSet1&#125;;</span><br><span class="line"><span class="keyword">use</span> crate::print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">print_keypresses</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> scancodes = ScancodeStream::new();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> keyboard = Keyboard::new(layouts::Us104Key, ScancodeSet1,</span><br><span class="line">        HandleControl::Ignore);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(scancode) = scancodes.next().<span class="keyword">await</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Ok</span>(<span class="literal">Some</span>(key_event)) = keyboard.add_byte(scancode) &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(key) = keyboard.process_keyevent(key_event) &#123;</span><br><span class="line">                <span class="keyword">match</span> key &#123;</span><br><span class="line">                    DecodedKey::Unicode(character) =&gt; <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, character),</span><br><span class="line">                    DecodedKey::RawKey(key) =&gt; <span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, key),</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码与本文修改之前在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/hardware-interrupts/#interpreting-the-scancodes">键盘中断处理程序</a>中使用的代码非常相似。唯一的区别是，我们不是从I/O端口读取扫描码，而是从<code>ScancodeStream</code>中获取。为此，我们首先创建一个新的<code>Scancode</code>流，然后重复使用<code>StreamExt</code>trait所提供的<code>next</code>方法来获取<code>Future</code>，即为该流中的下一个元素。通过在其上使用<code>await</code>运算符，我们可以异步等待future的结果。</p>
<p>使用<code>while let</code>循环，直到流返回<code>None</code>表示结束为止。由于我们的<code>poll_next</code>方法从不返回<code>None</code>，因此这实际上是一个无休止的循环，即<code>print_keypresses</code>任务永远不会完成。</p>
<p>让我们在<code>main.rs</code>中的执行器中添加<code>print_keypresses</code>任务，以再次获得有效的键盘输入：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> blog_os::task::keyboard; <span class="comment">// new</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">kernel_main</span></span>(boot_info: &amp;<span class="symbol">&#x27;static</span> BootInfo) -&gt; ! &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// […] initialization routines, including init_heap, test_main</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> executor = SimpleExecutor::new();</span><br><span class="line">    executor.spawn(Task::new(example_task()));</span><br><span class="line">    executor.spawn(Task::new(keyboard::print_keypresses())); <span class="comment">// new</span></span><br><span class="line">    executor.run();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// […] &quot;it did not crash&quot; message, hlt_loop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在执行<code>cargo run</code>，将看到键盘输入再次起作用：</p>
<p><img src="https://os.phil-opp.com/async-await/qemu-keyboard-output.gif" alt="QEMU键盘输出"></p>
<p>如果你密切注意计算机的CPU使用率，就会发现<code>QEMU</code>进程会令CPU持续繁忙。发生这种情况是因为我们的<code>SimpleExecutor</code>在一个循环中不停地轮询任务。因此，即使我们没有按键盘上的任何键，执行器也会在<code>print_keypresses</code>任务上不停的调用<code>poll</code>，即使该任务并未取得任何进展而每次都会返回<code>Poll::Pending</code>。</p>
<h3 id="带有唤醒器支持的执行器"><a href="#带有唤醒器支持的执行器" class="headerlink" title="带有唤醒器支持的执行器"></a>带有唤醒器支持的执行器</h3><p>要解决性能问题，我们需要创建一个能够正确利用<code>Waker</code>通知的执行器。这样，当下一个键盘中断发生时，将通知执行器，因此就不需要再不停的轮询<code>print_keypresses</code>任务了。</p>
<h4 id="任务ID"><a href="#任务ID" class="headerlink" title="任务ID"></a>任务ID</h4><p>要创建能够正确支持唤醒器通知的执行器，第一步就是为每个任务分配唯一的ID。这是必需的，因为我们需要一种方法来指定希望唤醒的任务。首先，创建一个新的<code>TaskId</code>封装类型：</p>
<figure class="highlight rust"><figcaption><span>in src/task/mod.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TaskId</span></span>(<span class="built_in">u64</span>);</span><br></pre></td></tr></table></figure>

<p><code>TaskId</code>结构体其实是对<code>u64</code>的简单封装。我们为它派生了许多trait，使其可打印、复制、比较、排序。其中可排序很重要，因为我们接下来将使用<code>TaskId</code>作为<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/collections/btree_map/struct.BTreeMap.html"><code>BTreeMap</code></a>的键。</p>
<p>要生成一个新唯一ID，需要创建一个<code>TaskID::new</code>函数：</p>
<figure class="highlight rust"><figcaption><span>in src/task/mod.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> core::sync::atomic::&#123;AtomicU64, Ordering&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> TaskId &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> NEXT_ID: AtomicU64 = AtomicU64::new(<span class="number">0</span>);</span><br><span class="line">        TaskId(NEXT_ID.fetch_add(<span class="number">1</span>, Ordering::Relaxed))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数使用<code>AtomicU64</code>类型的静态变量<code>NEXT_ID</code>来确保每个ID仅分配一次。<code>fetch_add</code>方法以原子化的方式自增，并在同一个原子操作中返回上一个值。这意味着即使并行调用<code>TaskId::new</code>方法，每个ID也会返回一次。<code>Ordering</code>参数定义是否允许编译器在指令流中对<code>fetch_add</code>操作重新排序。因为我们只要求ID是唯一的，所以在这种情况下，使用最弱的<code>Relaxed</code>排序就足够了。</p>
<p>现在，我们可以使用附加的<code>id</code>字段来扩展<code>Task</code>类型：</p>
<figure class="highlight rust"><figcaption><span>in src/task/mod.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Task</span></span> &#123;</span><br><span class="line">    id: TaskId, <span class="comment">// new</span></span><br><span class="line">    future: Pin&lt;<span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Future&lt;Output = ()&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Task &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(future: <span class="keyword">impl</span> Future&lt;Output = ()&gt; + <span class="symbol">&#x27;static</span>) -&gt; Task &#123;</span><br><span class="line">        Task &#123;</span><br><span class="line">            id: TaskId::new(), <span class="comment">// new</span></span><br><span class="line">            future: <span class="built_in">Box</span>::pin(future),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新的<code>id</code>字段使唯一地命名任务成为可能，这是唤醒指定任务所必需的。</p>
<h4 id="Executor类型"><a href="#Executor类型" class="headerlink" title="Executor类型"></a><code>Executor</code>类型</h4><p>我们在<code>task::executor</code>模块中创建新的<code>Executor</code>类型：</p>
<figure class="highlight rust"><figcaption><span>in src/task/mod.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> executor;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><figcaption><span>in src/task/executor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> super::&#123;Task, TaskId&#125;;</span><br><span class="line"><span class="keyword">use</span> alloc::&#123;collections::BTreeMap, sync::Arc&#125;;</span><br><span class="line"><span class="keyword">use</span> core::task::Waker;</span><br><span class="line"><span class="keyword">use</span> crossbeam_queue::ArrayQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Executor</span></span> &#123;</span><br><span class="line">    tasks: BTreeMap&lt;TaskId, Task&gt;,</span><br><span class="line">    task_queue: Arc&lt;ArrayQueue&lt;TaskId&gt;&gt;,</span><br><span class="line">    waker_cache: BTreeMap&lt;TaskId, Waker&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Executor &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        Executor &#123;</span><br><span class="line">            tasks: BTreeMap::new(),</span><br><span class="line">            task_queue: Arc::new(ArrayQueue::new(<span class="number">100</span>)),</span><br><span class="line">            waker_cache: BTreeMap::new(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们没有像在<code>SimpleExecutor</code>中那样将任务存储在<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/alloc/collections/vec_deque/struct.VecDeque.html"><code>VecDeque</code></a>中，而是存放在一个包含任务ID的<code>task_queue</code>字段和包含实际<code>Task</code>实例的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/collections/btree_map/struct.BTreeMap.html"><code>BTreeMap</code></a>类型的<code>tasks</code>字段中。该映射由<code>TaskId</code>索引，以允许有效地恢复执行特定任务。</p>
<p><code>task_queue</code>字段是有任务ID组成的<a target="_blank" rel="noopener" href="https://docs.rs/crossbeam/0.7.3/crossbeam/queue/struct.ArrayQueue.html"><code>ArrayQueue</code></a>，并封装为实现了<em>引用计数</em>的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/alloc/sync/struct.Arc.html"><code>Arc</code></a>类型。引用计数使得在多个所有者之间共享变量所有权成为可能。它在堆上分配变量，并计算对变量的活动引用数。当活动引用数达到零时，即不再需要该值，因此会将其释放。</p>
<p>我们将这种<code>Arc&lt;ArrayQueue&gt;</code>类型用于<code>task_queue</code>，以使其能够被执行者和唤醒者共享。这个思路是唤醒者将已唤醒任务的ID推送到队列中。而执行器位于队列的接收端，从<code>task</code>映射中按其ID取回已唤醒的任务，并运行任务。使用固定大小的队列而不是无限制队列（如<a target="_blank" rel="noopener" href="https://docs.rs/crossbeam-queue/0.2.1/crossbeam_queue/struct.SegQueue.html"><code>SegQueue</code></a>）的原因是，不应在中断处理程序中进行堆分配，将推送到此队列。</p>
<p>除了<code>task_queue</code>和<code>tasks</code>映射外，<code>Executor</code>类型还具有一个<code>waker_cache</code>字段，它也是一个映射。在创建任务后，此映射将缓存任务的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/task/struct.Waker.html"><code>Waker</code></a>。首先，可以使用同一个唤醒器对同一个任务做多次唤醒操作，这相较于每次唤醒均创建一个唤醒器而言更高效。其次，它确保唤醒器的引用计数不会在中断处理程序内被释放，而这可能会导致死锁（有关此问题的更多信息，请参见下文）。</p>
<p>要创建<code>Executor</code>，我们可以编写一个简单的<code>new</code>函数。我们为<code>task_queue</code>选择100的容量，这对可预见的未来而言已经足够了。如果我们的系统在某个时刻真的保有超过100个并发任务，也可以轻松地修改这个值。</p>
<h4 id="生成任务"><a href="#生成任务" class="headerlink" title="生成任务"></a>生成任务</h4><p>与<code>SimpleExecutor</code>类似，我们也在<code>Executor</code>类型上编写一个<code>spawn</code>方法，该方法将给定任务添加到<code>tasks</code>映射，并通过将其ID推送到<code>task_queue</code>中来立刻执行唤醒：</p>
<figure class="highlight rust"><figcaption><span>in src/task/executor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Executor &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">spawn</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, task: Task) &#123;</span><br><span class="line">        <span class="keyword">let</span> task_id = task.id;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.tasks.insert(task.id, task).is_some() &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;task with same ID already in tasks&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.task_queue.push(task_id).expect(<span class="string">&quot;queue full&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果映射中已经存在具有相同ID的任务，则<code>BTreeMap::insert</code>方法将直接返回它。由于每个任务都有唯一的ID，理论上不应发生这种情况，因此若出现这种情况我们就产生panic，表明代码中存在错误。同样，当<code>task_queue</code>填满时也会产生panic，因为如果设置的队列大小合适，就不应该发生这种情况。</p>
<h4 id="运行任务"><a href="#运行任务" class="headerlink" title="运行任务"></a>运行任务</h4><p>要执行<code>task_queue</code>中的所有任务，我们创建一个私有的<code>run_ready_tasks</code>方法：</p>
<figure class="highlight rust"><figcaption><span>in src/task/executor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> core::task::&#123;Context, Poll&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Executor &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">run_ready_tasks</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 解构`self`以避免借用检查出错</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">            tasks,</span><br><span class="line">            task_queue,</span><br><span class="line">            waker_cache,</span><br><span class="line">        &#125; = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Ok</span>(task_id) = task_queue.pop() &#123;</span><br><span class="line">            <span class="keyword">let</span> task = <span class="keyword">match</span> tasks.get_mut(&amp;task_id) &#123;</span><br><span class="line">                <span class="literal">Some</span>(task) =&gt; task,</span><br><span class="line">                <span class="literal">None</span> =&gt; <span class="keyword">continue</span>, <span class="comment">// 任务已不存在</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">let</span> waker = waker_cache</span><br><span class="line">                .entry(task_id)</span><br><span class="line">                .or_insert_with(|| TaskWaker::new(task_id, task_queue.clone()));</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> context = Context::from_waker(waker);</span><br><span class="line">            <span class="keyword">match</span> task.poll(&amp;<span class="keyword">mut</span> context) &#123;</span><br><span class="line">                Poll::Ready(()) =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 任务完成 -&gt; 删除任务及其缓存唤醒器</span></span><br><span class="line">                    tasks.remove(&amp;task_id);</span><br><span class="line">                    waker_cache.remove(&amp;task_id);</span><br><span class="line">                &#125;</span><br><span class="line">                Poll::Pending =&gt; &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的基本思路与<code>SimpleExecutor</code>类似：遍历<code>task_queue</code>中的任务，为每个任务创建唤醒器，并轮询该任务。但我们并不直接将待处理的任务添加到<code>task_queue</code>的队尾，而是让<code>TaskWaker</code>负责将唤醒的任务添加回队列。稍后将显示该唤醒器类型的实现。</p>
<p>让我们研究一下<code>run_ready_tasks</code>方法的一些实现细节：</p>
<ul>
<li>我们将<code>self</code><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#destructuring-to-break-apart-values">解构</a>为三个字段，以避免某些借用检查器错误。即我们的实现需要从闭包内部访问<code>self.task_queue</code>，而目前的闭包会尝试直接借用整个<code>self</code>。这本质上是借阅检查器自己的问题，且将在<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/issues/53488">实现</a><a target="_blank" rel="noopener" href="https://github.com/rust-lang/rfcs/pull/2229">RFC 2229</a>时解决。</li>
<li>对于每个弹出的任务ID，我们从<code>tasks</code>映射中取出其对应任务的可变引用。由于我们的<code>ScancodeStream</code>会在检查任务是否需要休眠之前就注册唤醒器，因此可能会发生为已经不存在的任务执行唤醒的情况。在这种情况下，我们只需忽略唤醒并继续执行队列中的下一个ID即可。</li>
<li>为了避免在每个轮询中新建唤醒器所带来的性能开销，我们在每个任务创建后将其唤醒器缓存到<code>waker_cache</code>映射中。为此，我们结合使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/collections/btree_map/struct.BTreeMap.html#method.entry"><code>BTreeMap::entry</code></a>方法和<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/collections/btree_map/enum.Entry.html#method.or_insert_with"><code>Entry::or_insert_with</code></a>，若唤醒器尚不存在则新建一个，再获得其的可变引用。为了创建新的唤醒器，我们克隆了<code>task_queue</code>并将其与任务ID一起传给<code>TaskWaker::new</code>函数（其实现见下文）。由于<code>task_queue</code>封装在<code>Arc</code>中，因此<code>clone</code>只会增加其引用计数，而仍指向同一堆分配的队列。请注意，并非所有唤醒器的实现都可以进行这种重用，但是我们的<code>TaskWaker</code>实现是允许重复的。</li>
</ul>
<p>任务完成时将返回<code>Poll::Ready</code>。在这种情况下，我们使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/collections/btree_map/struct.BTreeMap.html#method.remove"><code>BTreeMap::remove</code></a>方法从<code>tasks</code>映射中删除该任务。如果该任务还有缓存的唤醒器，我们也会将其移除。</p>
<h4 id="唤醒器设计"><a href="#唤醒器设计" class="headerlink" title="唤醒器设计"></a>唤醒器设计</h4><p>唤醒器用于将已唤醒的任务ID推送到执行器的<code>task_queue</code>。我们创建一个新的<code>TaskWaker</code>结构体，以存储任务ID和一个<code>task_queue</code>引用：</p>
<figure class="highlight rust"><figcaption><span>in src/task/executor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TaskWaker</span></span> &#123;</span><br><span class="line">    task_id: TaskId,</span><br><span class="line">    task_queue: Arc&lt;ArrayQueue&lt;TaskId&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>task_queue</code>的所有权由执行器和唤醒器共享，因此我们使用<code>Arc</code>封装类型来实现共享所有权的引用计数。</p>
<p>唤醒操作的实现非常简单：</p>
<figure class="highlight rust"><figcaption><span>in src/task/executor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> TaskWaker &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">wake_task</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.task_queue.push(<span class="keyword">self</span>.task_id).expect(<span class="string">&quot;task_queue full&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将<code>task_id</code>推送到引用的<code>task_queue</code>中。由于对<code>ArrayQueue</code>类型的修改仅需要共享的引用，因此我们都不需要<code>&amp;mut self</code>，仅用<code>&amp;self</code>即可实现。</p>
<h5 id="Waketrait"><a href="#Waketrait" class="headerlink" title="Waketrait"></a><code>Wake</code>trait</h5><p>为了能够使用<code>TaskWaker</code>类型轮询future，我们首先要将其转为<code>Waker</code>实例。这是必需的，因为<code>Future::poll</code>方法使用<code>Context</code>的实例作参数，而该实例只能基于<code>Waker</code>类型构造。尽管确实可以通过提供一个<code>RawWaker</code>实现来做到这一点，但是使用基于<code>Arc</code>的<code>Wake</code>trait，然后再用标准库提供的<code>From</code>trait的实现来构造<code>Waker</code>，将会更简单且安全。</p>
<p><code>Wake</code>Trait实现如下所示：</p>
<figure class="highlight rust"><figcaption><span>in src/task/executor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> alloc::task::Wake;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Wake <span class="keyword">for</span> TaskWaker &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">wake</span></span>(<span class="keyword">self</span>: Arc&lt;<span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.wake_task();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">wake_by_ref</span></span>(<span class="keyword">self</span>: &amp;Arc&lt;<span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.wake_task();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于唤醒器通常在执行器和异步任务之间共享，因此<code>trait</code>方法要求将<code>Self</code>的实例封装在<code>Arc</code>类型中，以实现所有权的引用计数。这意味着我们必须将<code>TaskWaker</code>放在<code>Arc</code>中才能进行调用。</p>
<p><code>wake</code>和<code>wake_by_ref</code>方法之间的区别在于，后者仅需要<code>Arc</code>的引用，而前者需要<code>Arc</code>的所有权，因此通常需要增加引用计数。并非所有类型都支持通过引用调用唤醒，因此方法<code>wake_by_ref</code>的实现是可选的，不过由于该方法可以避免不必要的引用计数修改，所以性能较高。对我们来说，可以在两个trait方法中都简单地继续调用<code>wake_task</code>函数，该函数仅需要一个共享的<code>&amp;self</code>引用。</p>
<h5 id="创建唤醒器"><a href="#创建唤醒器" class="headerlink" title="创建唤醒器"></a>创建唤醒器</h5><p>由于所有<code>Arc</code>封装的实现了<code>Waker</code>trait的类型都支持使用<code>From</code>转换，因此我们现在可以实现<code>Executor::run_ready_tasks</code>方法所需的<code>TaskWaker::new</code>函数了：</p>
<figure class="highlight rust"><figcaption><span>in src/task/executor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> TaskWaker &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(task_id: TaskId, task_queue: Arc&lt;ArrayQueue&lt;TaskId&gt;&gt;) -&gt; Waker &#123;</span><br><span class="line">        Waker::from(Arc::new(TaskWaker &#123;</span><br><span class="line">            task_id,</span><br><span class="line">            task_queue,</span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>task_id</code>和<code>task_queue</code>作为参数创建<code>TaskWaker</code>。然后，我们将<code>TaskWaker</code>封装在<code>Arc</code>中，并使用<code>Waker::from</code>将其转换为<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/task/struct.Waker.html"><code>Waker</code></a>。此from方法负责为TaskWaker类型构造<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/core/task/struct.RawWakerVTable.html">RawWakerVTable</a>和<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/core/task/struct.RawWaker.html">RawWaker</a>实例。这个<code>from</code>方法用于<code>TaskWaker</code>类型构造一个<code>RawWakerVTable</code>和一个<code>RawWaker</code>实例。如果你对它的详细工作方式感兴趣，请查看<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/blob/cdb50c6f2507319f29104a25765bfb79ad53395c/src/liballoc/task.rs#L58-L87"><code>alloc</code>crate中的实现</a>。</p>
<h4 id="run方法"><a href="#run方法" class="headerlink" title="run方法"></a><code>run</code>方法</h4><p>在实现了唤醒器之后，我们终于可以为执行器添加一个<code>run</code>方法了：</p>
<figure class="highlight rust"><figcaption><span>in src/task/executor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Executor &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; ! &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.run_ready_tasks();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法仅循环调用<code>run_ready_tasks</code>函数。理论上，当<code>tasks</code>映射为空时我们确实可以从令函数返回，不过这并不会发生因为<code>keyboard_task</code>永远不会完成，因此一个简单的<code>loop</code>就足够了。鉴于该函数永不返回，因此我们使用返回类型<code>!</code>以告诉编译器此为<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/rust-by-example/fn/diverging.html">发散</a>函数。</p>
<p>现在，我们可以更改<code>kernel_main</code>，以使用新的<code>Executor</code>来代替<code>SimpleExecutor</code>：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> blog_os::task::executor::Executor; <span class="comment">// new</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">kernel_main</span></span>(boot_info: &amp;<span class="symbol">&#x27;static</span> BootInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="comment">// […] initialization routines, including init_heap, test_main</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> executor = Executor::new(); <span class="comment">// new</span></span><br><span class="line">    executor.spawn(Task::new(example_task()));</span><br><span class="line">    executor.spawn(Task::new(keyboard::print_keypresses()));</span><br><span class="line">    executor.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只需要更改导入类型和类型名称。由于<code>run</code>是发散函数，编译器知道它永不返回，因此我们不再需要在<code>kernel_main</code>函数末尾调用<code>hlt_loop</code>。</p>
<p>当我们现在使用<code>cargo run</code>运行内核时，将看到键盘输入依然有效：</p>
<p><img src="https://os.phil-opp.com/async-await/qemu-keyboard-output-again.gif" alt="QEMU键盘输出"></p>
<p>不过，QEMU的CPU使用率并没有降低。这是因为我们仍然使CPU始终保持忙碌状态。现在虽然在任务唤通知醒前都不再执行轮询，但仍在循环中检查<code>task_queue</code>。要解决此问题，我们需要在CPU没有其他工作时进入睡眠状态。</p>
<h4 id="空闲时睡眠"><a href="#空闲时睡眠" class="headerlink" title="空闲时睡眠"></a>空闲时睡眠</h4><p>基本思路就是在<code>task_queue</code>为空时执行<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/HLT_(x86_instruction)"><code>hlt</code>指令</a>。该指令使CPU进入睡眠状态，直到下一个中断到达。CPU在中断后立即会再次激活，这确保了当中断处理程序向<code>task_queue</code>推送任务时，CPU仍然可以直接做出反应。</p>
<p>为了实现这一点，我们在执行器中创建一个新的<code>sleep_if_idle</code>方法，并从<code>run</code>方法中调用它：</p>
<figure class="highlight rust"><figcaption><span>in src/task/executor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Executor &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; ! &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.run_ready_tasks();</span><br><span class="line">            <span class="keyword">self</span>.sleep_if_idle();   <span class="comment">// new</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">sleep_if_idle</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.task_queue.is_empty() &#123;</span><br><span class="line">            x86_64::instructions::hlt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们在<code>run_ready_tasks</code>之后直接调用<code>sleep_if_idle</code>，这将一直循环直到<code>task_queue</code>为空，因此似乎无需再次检查队列。但是，硬件中断可能紧接着在<code>run_ready_tasks</code>返回之后发生，因此在调用<code>sleep_if_idle</code>函数时队列中可能还有一个新任务。仅当队列仍然为空时，我们才通过<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/index.html"><code>x86_64</code></a>crate提供的<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/instructions/fn.hlt.html"><code>instructions::hlt</code></a>函数执行<code>hlt</code>指令，使CPU进入睡眠状态。</p>
<p>不幸的是，在此实现中仍然存在微妙的竞争条件。由于中断是异步的且可以随时发生，因此有可能在<code>is_empty</code>检查和<code>hlt</code>调用之间发生中断：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.task_queue.is_empty() &#123;</span><br><span class="line">    <span class="comment">/// &lt;--- 这里也可能发生中断</span></span><br><span class="line">    x86_64::instructions::hlt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>万一此中断推送到<code>task_queue</code>，即使现在确实有一个就绪的任务，CPU也会进入睡眠状态。在最坏的情况下，这可能会将键盘中断的处理，延迟到下一次按键或下一个定时器中断。那么我们应该如何预防呢？</p>
<p>答案是在检查之前禁用CPU上的中断，并与<code>hlt</code>指令一起以原子化操作再启用中断。那么，此间发生的所有中断都将延迟到<code>hlt</code>指令之后，从而不会丢失任何唤醒。为了实现该方法，我们可以使用<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/index.html"><code>x86_64</code></a>crate提供的<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/instructions/interrupts/fn.enable_and_hlt.html"><code>interrupts::enable_and_hlt</code></a>函数。</p>
<p>修改后的<code>sleep_if_idle</code>函数如下所示：</p>
<figure class="highlight rust"><figcaption><span>in src/task/executor.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Executor &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">sleep_if_idle</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">use</span> x86_64::instructions::interrupts::&#123;<span class="keyword">self</span>, enable_and_hlt&#125;;</span><br><span class="line"></span><br><span class="line">        interrupts::disable();</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.task_queue.is_empty() &#123;</span><br><span class="line">            enable_and_hlt();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            interrupts::enable();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免竞争条件，我们在检查<code>task_queue</code>是否为空之前禁用中断。如果队列确实为空，我们将通过一个原子化操作，使用<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/instructions/interrupts/fn.enable_and_hlt.html"><code>enable_and_hlt</code></a>函数启用中断，同时让CPU进入睡眠。如果队列不再为空，则意味着在返回<code>run_ready_tasks</code>之后，中断会唤醒任务。在这种情况下，我们将再次启用中断，且不再<code>hlt</code>而直接继续让程序执行。</p>
<p>现在，执行器在没有任务的情况下能够正确地让CPU进入睡眠状态。我们可以看到，当再次使用<code>cargo run</code>运行内核时，QEMU进程的CPU利用率要低得多。</p>
<h4 id="可能的扩展"><a href="#可能的扩展" class="headerlink" title="可能的扩展"></a>可能的扩展</h4><p>我们的执行器现在可以高效地运行任务。它利用唤醒器通知来避免持续轮询等待的任务，并在无任何工作时使CPU进入睡眠状态。但是，我们的执行器仍然非常基础，而且可以通过许多方式来扩展功能：</p>
<ul>
<li><strong>调度</strong>：目前，我们使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/alloc/collections/vec_deque/struct.VecDeque.html"><code>VecDeque</code></a>类型为<code>task_queue</code>实现<em>先进先出</em>（FIFO）策略，这通常也称为<em>循环调度</em>。此策略对于其上的所有任务负载可能并不是最高效的。例如，优先考虑延迟敏感的任务或执行大量I/O的任务可能更加高效。有关更多信息，请参见<a target="_blank" rel="noopener" href="http://pages.cs.wisc.edu/~remzi/OSTEP/">Operating Systems: Three Easy Pieces</a>一书中的<a target="_blank" rel="noopener" href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched.pdf">scheduling chapter</a>章节，或<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Scheduling_(computing)">Wikipedia上关于调度的文章</a>。</li>
<li><strong>任务生成</strong>：我们的<code>Executor::spawn</code>方法当前需要<code>&amp;mut self</code>引用，因此在启动<code>run</code>方法之后将不再可用。为了解决这个问题，我们可以再创建一个额外的<code>Spawner</code>类型，该类型与执行器共享某种队列，并允许从任务自己创建新任务。例如，队列可以直接使用<code>task_queue</code>，也可以是一个在执行器中循环检查的单独的队列。</li>
<li><strong>使用线程</strong>：我们尚不支持线程，但会在下一篇文章中添加。这将使我们能够在不同的线程中启动多个执行器实例。这种方法的优点是可以减少长时长任务带来的延迟，因为其他任务可以同时运行。这种方法还可以利用多个CPU内核。</li>
<li><strong>负载均衡</strong>：添加线程支持时，如何在执行器间分配任务，以确保所有CPU核心都能够被用到将变得很重要。常见的技术是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Work_stealing"><em>work stealing</em></a>。</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在这篇文章的开始，我们介绍了<strong>多任务</strong>，并区分了抢占式多任务（强制性地定期中断正在运行的任务）和协作式多任务（使任务一直运行到自愿放弃对CPU的控制）之间的区别。</p>
<p>然后，我们探讨了Rust的<strong>async/await</strong>如何提供协作式多任务的语言级实现。Rust的实现基于基于轮询的<code>Future</code>trait，该特质抽象了异步任务。使用async/await，就可以像编写普通同步代码一样处理future。不同之处在于异步函数会再次返回<code>Future</code>，为了运行它，需要在某个时刻将其添加到执行器中。</p>
<p>在后台，编译器将async/await代码转换为<em>状态机</em>，每个<code>.await</code>操作对应一个可能的暂停点。通过利用程序对自身执行步骤的了解，编译器就能够为每个暂停点保存最小化的状态信息，从而使每个任务的内存消耗极小。而其中的一个挑战是，生成的状态机可能包含<em>自引用</em>结构体，例如，当异步函数的局部变量相互引用时。为了防止指针失效，Rust使用<code>Pin</code>类型来确保future在被第一次轮询后就不再能够在内存中移动了。</p>
<p>接下来介绍了如何实现，我们首先创建了一个非常简单的执行程序，它会在一个循环中持续轮询所有生成的任务，且完全不使用<code>Waker</code>类型。然后，我们通过实现异步键盘任务来展示了唤醒通知的优点。该任务使用<code>crossbeam</code>crate提供的无互斥的<code>ArrayQueue</code>类型定义了一个静态变量<code>SCANCODE_QUEUE</code>。现在，键盘中断处理程序不会再直接处理按键，而会将所有接收到的扫描代码放入队列中，然后唤醒已注册的<code>Waker</code>，以发送信号表示有新的输入可用。在接收端，我们创建了一个<code>ScancodeStream</code>类型，以提供一个用于获取队列中下一个<code>scancode</code>的<code>Future</code>。这样就可以创建一个异步<code>print_keypresses</code>任务，以使用<code>async/await</code>来解释并打印队列中的扫描码。</p>
<p>为了利用键盘任务的唤醒通知，我们创建了一个新的<code>Executor</code>类型，该类型使用<code>Arc</code>封装<code>task_queue</code>，以使得就绪任务可共享。我们实现了一个<code>TaskWaker</code>类型，以将唤醒的任务的ID直接推送到<code>task_queue</code>，然后使用执行器进行轮询。为了在空闲时时节省CPU，我们利用<code>hlt</code>指令添加了对CPU在空闲时睡眠的支持。最后，我们讨论了执行器的一些潜在扩展，例如，提供多核支持。</p>
<h2 id="下期预告"><a href="#下期预告" class="headerlink" title="下期预告"></a>下期预告</h2><p>我们利用async/await使内核具备了对协作多任务的基本支持。尽管协作式多任务处理非常有效，但是当单个任务运行太长时间并导致其他任务无法运行时，系统就会出现延迟。因此，在我们的内核中添加对抢占式多任务的支持也是合理的。</p>
<p>在下一篇文章中，我们将介绍抢占式多任务处理的最常见形式，<em>线程</em>。除了解决长时长任务的问题，线程还能够利用多个CPU核心，并支持运行不受信任的用户程序。</p>
<h2 id="支持本项目"><a href="#支持本项目" class="headerlink" title="支持本项目"></a>支持本项目</h2><p>创建和<a target="_blank" rel="noopener" href="https://os.phil-opp.com/status-update/">维护</a>这个博客和相关库是一项繁重的工作，但我真的很喜欢。通过支持我，您可以让我在新内容、新功能和持续维护上投入更多时间。</p>
<p>支持我的最好方式是<a target="_blank" rel="noopener" href="https://github.com/sponsors/phil-opp">在GitHub上赞助我</a>，因为他们不收取任何中间费用。如果你喜欢其他平台，我也有<a target="_blank" rel="noopener" href="https://www.patreon.com/phil_opp">Patreon</a>和<a target="_blank" rel="noopener" href="https://donorbox.org/phil-opp">Donorbox</a>账户。后者是最灵活的，因为它支持多种货币和一次性捐款。</p>
<p>感谢您的支持！</p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Rust/">Rust</a><a class="link-muted mr-2" rel="tag" href="/tags/Operating-System/">Operating System</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatpay.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/06/14/stereo-with-rpi-airplay/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">使用树莓派为音响添加AirPlay功能</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/04/06/writing-an-os-in-rust-3.4/"><span class="level-item">使用Rust编写操作系统 - 3.4 - 内存分配器设计</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><script src="https://utteranc.es/client.js" repo="zlotus/comment" issue-term="pathname" label="some-issue-label" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/opm_sq.png" alt="子实"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">子实</p><p class="is-size-6 is-block">程序员</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>陕西/西安</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">80</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">23</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zlotus" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com/qinzishi"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/Zealot_uS"><i class="fab fa-twitter"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.zhihu.com/people/zlotus" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Diary/"><span class="level-start"><span class="level-item">Diary</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">66</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Shell/"><span class="level-start"><span class="level-item">Shell</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Coroutines/"><span class="tag">Coroutines</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">32</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenCV/"><span class="tag">OpenCV</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Operating-System/"><span class="tag">Operating System</span><span class="tag">21</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Paper/"><span class="tag">Paper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Raspberry-Pi/"><span class="tag">Raspberry Pi</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag">29</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TensorFlow/"><span class="tag">TensorFlow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tokio/"><span class="tag">Tokio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZMQ/"><span class="tag">ZMQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ctpn/"><span class="tag">ctpn</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/llama/"><span class="tag">llama</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macOS/"><span class="tag">macOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/obsidion/"><span class="tag">obsidion</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%A5%E8%AE%B0/"><span class="tag">日记</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E8%B0%88/"><span class="tag">杂谈</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B/"><span class="tag">编程</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%84%9A%E6%9C%AC/"><span class="tag">脚本</span><span class="tag">4</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a><p class="is-size-7"><span>&copy; 2024 子实</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>