<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>使用Rust编写操作系统 - 1.3 - VGA文本模式 - 子实</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="子实"><meta name="msapplication-TileImage" content="/img/avatar-o.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="子实"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="使用Rust编写操作系统 - 1.3 - VGA文本模式"><meta property="og:type" content="article"><meta property="og:title" content="使用Rust编写操作系统 - 1.3 - VGA文本模式"><meta property="og:url" content="https://zlotus.github.io/2021/02/28/writing-an-os-in-rust-1.3/"><meta property="og:site_name" content="子实"><meta property="og:description" content="使用Rust编写操作系统 - 1.3 - VGA文本模式"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://os.phil-opp.com/vga-text-mode/vga-hello.png"><meta property="og:image" content="https://os.phil-opp.com/vga-text-mode/vga-hello-world.png"><meta property="og:image" content="https://os.phil-opp.com/vga-text-mode/vga-panic.png"><meta property="article:published_time" content="2021-02-28T13:57:00.000Z"><meta property="article:modified_time" content="2021-02-28T13:57:00.000Z"><meta property="article:author" content="子实"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Operating System"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://os.phil-opp.com/vga-text-mode/vga-hello.png"><meta property="twitter:creator" content="@Zealot_uS"><meta property="twitter:site" content="Zealot_uS"><link rel="publisher" href="+LotusQin"><meta property="fb:admins" content="qinzishi"><meta property="fb:app_id" content="qinzishi"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zlotus.github.io/2021/02/28/writing-an-os-in-rust-1.3/"},"headline":"使用Rust编写操作系统 - 1.3 - VGA文本模式","image":["https://os.phil-opp.com/vga-text-mode/vga-hello.png","https://os.phil-opp.com/vga-text-mode/vga-hello-world.png","https://os.phil-opp.com/vga-text-mode/vga-panic.png"],"datePublished":"2021-02-28T13:57:00.000Z","dateModified":"2021-02-28T13:57:00.000Z","author":{"@type":"Person","name":"子实"},"publisher":{"@type":"Organization","name":"子实","logo":{"@type":"ImageObject","url":"https://zlotus.github.io/img/opm_sq.png"}},"description":"使用Rust编写操作系统 - 1.3 - VGA文本模式"}</script><link rel="icon" href="/img/avatar-o.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/2014/07/09/about-me/">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-28T13:57:00.000Z" title="2/28/2021, 9:57:00 PM">2021-02-28</time>发表</span><span class="level-item"><time dateTime="2021-02-28T13:57:00.000Z" title="2/28/2021, 9:57:00 PM">2021-02-28</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a></span><span class="level-item">1 小时读完 (大约7170个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">使用Rust编写操作系统 - 1.3 - VGA文本模式</h1><div class="content"><article class="message message-immersive is-warning">
<div class="message-body">
<i class="fas fa-exclamation-triangle mr-2"></i>本文所有内容均为翻译，原文：<a target="_blank" rel="noopener" href="https://os.phil-opp.com/vga-text-mode/">VGA Text Mode</a>；原项目：<a target="_blank" rel="noopener" href="https://os.phil-opp.com/">Writing an OS in Rust</a>
</div>
</article>

<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/VGA-compatible_text_mode">VGA文本模式</a>是一种简单的将文本打印到屏幕上的方法。在这篇文章中，我们将创建一个接口，通过将所有的非安全代码封装在一个单独的模块中，使其使用变得安全和简单。我们还将实现对Rust中<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/fmt/#related-macros">格式化宏</a>的支持。</p>
<span id="more"></span>

<p>这个博客是在<a target="_blank" rel="noopener" href="https://github.com/phil-opp/blog_os">GitHub</a>上公开开发的。如果你有任何问题或疑问，请在那里开一个issue。你也可以在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/vga-text-mode/#comments">底部</a>留言。这篇文章的完整源代码可以在<a target="_blank" rel="noopener" href="https://github.com/phil-opp/blog_os/tree/post-03">post-03</a>分支中找到。</p>
<h2 id="VGA文本缓冲区"><a href="#VGA文本缓冲区" class="headerlink" title="VGA文本缓冲区"></a>VGA文本缓冲区</h2><p>在VGA文本模式下，要想把一个字符打印到屏幕上，则需要把它写入VGA硬件的文本缓冲区。VGA文本缓冲区是一个二维数组，通常有25行80列，将直接渲染在屏幕上。每个数组元素通过以下格式描述一个屏幕字符：</p>
<table>
<thead>
<tr>
<th>位</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>0-7</td>
<td>ASCII 码点</td>
</tr>
<tr>
<td>8-11</td>
<td>前景色</td>
</tr>
<tr>
<td>12-14</td>
<td>背景色</td>
</tr>
<tr>
<td>15</td>
<td>闪烁</td>
</tr>
</tbody></table>
<p>第一个字节代表应该用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ASCII">ASCII编码</a>打印的字符。准确地说，它并不完全是ASCII码，而是一个名为<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Code_page_437">代码页437</a>的字符集，并添加了一些额外的字符和轻微的修改。为了简单起见，我们在这篇文章中继续称它为ASCII字符。</p>
<p>第二个字节定义了字符的显示方式。前四位定义前景色，后三位定义背景色，最后一位定义字符是否应该闪烁。以下是可用的颜色：</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>颜色</th>
<th>代码 + 高亮位</th>
<th>高亮色</th>
</tr>
</thead>
<tbody><tr>
<td>0x0</td>
<td>Black</td>
<td>0x8</td>
<td>Dark Gray</td>
</tr>
<tr>
<td>0x1</td>
<td>Blue</td>
<td>0x9</td>
<td>Light Blue</td>
</tr>
<tr>
<td>0x2</td>
<td>Green</td>
<td>0xa</td>
<td>Light Green</td>
</tr>
<tr>
<td>0x3</td>
<td>Cyan</td>
<td>0xb</td>
<td>Light Cyan</td>
</tr>
<tr>
<td>0x4</td>
<td>Red</td>
<td>0xc</td>
<td>Light Red</td>
</tr>
<tr>
<td>0x5</td>
<td>Magenta</td>
<td>0xd</td>
<td>Pink</td>
</tr>
<tr>
<td>0x6</td>
<td>Brown</td>
<td>0xe</td>
<td>Yellow</td>
</tr>
<tr>
<td>0x7</td>
<td>Light Gray</td>
<td>0xf</td>
<td>White</td>
</tr>
</tbody></table>
<p>第4位是<em>高亮位</em>，例如它能将蓝色高亮变成了浅蓝色。对于背景色，该位被重新用作闪烁位。</p>
<p>VGA文本缓冲区可以通过<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">内存映射I/O</a>访问地址<code>0xb8000</code>。这意味着对该地址的读写不访问RAM，而是直接访问VGA硬件上的文本缓冲区。这意味着我们可以通过正常的内存操作对该地址进行读写。</p>
<p>需要注意的是，内存映射的硬件可能不支持所有正常的RAM操作。例如，一个设备可能只支持按字节读取，当读取一个<code>u64</code>时，就会返回垃圾。幸运的是，文本缓冲区支持<a target="_blank" rel="noopener" href="https://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/vgamem.htm#manip">正常读写</a>，所以我们不必以特殊的方式对待它。</p>
<h2 id="编写Rust模块"><a href="#编写Rust模块" class="headerlink" title="编写Rust模块"></a>编写Rust模块</h2><p>现在我们知道了VGA缓冲区的工作原理，我们可以创建一个Rust模块来处理打印。</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> vga_buffer;</span><br></pre></td></tr></table></figure>

<p>我们创建一个新文件<code>src/vga_buffer.rs</code>来编写这个模块。下面所有的代码都会在我们的新模块中编写（除非另有说明）。</p>
<h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>首先，我们用一个枚举来表示不同的颜色：</p>
<figure class="highlight rust"><figcaption><span>in src/vga_buffer.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[allow(dead_code)]</span></span><br><span class="line"><span class="meta">#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span></span><br><span class="line"><span class="meta">#[repr(u8)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span> &#123;</span><br><span class="line">    Black = <span class="number">0</span>,</span><br><span class="line">    Blue = <span class="number">1</span>,</span><br><span class="line">    Green = <span class="number">2</span>,</span><br><span class="line">    Cyan = <span class="number">3</span>,</span><br><span class="line">    Red = <span class="number">4</span>,</span><br><span class="line">    Magenta = <span class="number">5</span>,</span><br><span class="line">    Brown = <span class="number">6</span>,</span><br><span class="line">    LightGray = <span class="number">7</span>,</span><br><span class="line">    DarkGray = <span class="number">8</span>,</span><br><span class="line">    LightBlue = <span class="number">9</span>,</span><br><span class="line">    LightGreen = <span class="number">10</span>,</span><br><span class="line">    LightCyan = <span class="number">11</span>,</span><br><span class="line">    LightRed = <span class="number">12</span>,</span><br><span class="line">    Pink = <span class="number">13</span>,</span><br><span class="line">    Yellow = <span class="number">14</span>,</span><br><span class="line">    White = <span class="number">15</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在这里使用一个<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/rust-by-example/custom_types/enum/c_like.html">C型枚举</a>来显式地指定每种颜色的值。由于repr(u8)属性，每个枚举变量都存储为<code>u8</code>。其实4位就够了，但Rust没有<code>u4</code>类型。</p>
<p>通常编译器会对每个未使用的变量发出警告。通过使用<code>#[allow(dead_code)]</code>属性，我们可以禁用<code>Color</code>枚举的这些警告。</p>
<p>通过<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/rust-by-example/trait/derive.html">派生</a><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html"><code>Copy</code></a>、<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html"><code>Clone</code></a>、<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html"><code>Debug</code></a>、<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html"><code>PartialEq</code></a>和<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html"><code>Eq</code></a>五个trait，我们实现了类型的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/1.30.0/book/first-edition/ownership.html#copy-types">复制语义</a>，并使其可打印、可比较。</p>
<p>为了表示指定前景色和背景色的全部色码，我们在<code>u8</code>的基础上创建一个<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/rust-by-example/generics/new_types.html">新类型</a>：</p>
<figure class="highlight rust"><figcaption><span>in src/vga_buffer.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span></span><br><span class="line"><span class="meta">#[repr(transparent)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ColorCode</span></span>(<span class="built_in">u8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> ColorCode &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(foreground: Color, background: Color) -&gt; ColorCode &#123;</span><br><span class="line">        ColorCode((background <span class="keyword">as</span> <span class="built_in">u8</span>) &lt;&lt; <span class="number">4</span> | (foreground <span class="keyword">as</span> <span class="built_in">u8</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ColorCode结构体包含完整的颜色字节——前景色和背景色。像之前一样，我们为它派生出<code>Copy</code>和<code>Debug</code>特征。为了确保<code>ColorCode</code>的数据类型布局与<code>u8</code>完全相同，我们使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nomicon/other-reprs.html#reprtransparent"><code>repr(transparent)</code></a>属性。</p>
<p>（译者注：关于<code>repr(transparent)</code>，可以参考<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/1.26.2/unstable-book/language-features/repr-transparent.html"><code>repr_transparent</code></a>的解释。）</p>
<h3 id="文本缓冲区"><a href="#文本缓冲区" class="headerlink" title="文本缓冲区"></a>文本缓冲区</h3><p>现在我们可以添加结构体来表示屏幕字符和文本缓冲区了：</p>
<figure class="highlight rust"><figcaption><span>in src/vga_buffer.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScreenChar</span></span> &#123;</span><br><span class="line">    ascii_character: <span class="built_in">u8</span>,</span><br><span class="line">    color_code: ColorCode,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BUFFER_HEIGHT: <span class="built_in">usize</span> = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">const</span> BUFFER_WIDTH: <span class="built_in">usize</span> = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(transparent)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Buffer</span></span> &#123;</span><br><span class="line">    chars: [[ScreenChar; BUFFER_WIDTH]; BUFFER_HEIGHT],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于Rust默认布局下结构体中的字段没有顺序，所以我们需要<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/nomicon/other-reprs.html#reprc"><code>repr(C)</code></a>属性。它可以保证Rust结构体的字段布局和C结构体中的字段完全一样，从而保证字段排序的正确性。对于Buffer结构，我们再次使用<code>repr(transparent)</code>来保证它的内存布局与其中的单字段相同。</p>
<p>为了实际写到屏幕上，我们现在创建一个写类型：</p>
<figure class="highlight rust"><figcaption><span>in src/vga_buffer.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Writer</span></span> &#123;</span><br><span class="line">    column_position: <span class="built_in">usize</span>,</span><br><span class="line">    color_code: ColorCode,</span><br><span class="line">    buffer: &amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> Buffer,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写的方式总是写到最后一行，当一行满了的时候（或者遇到<code>\n</code>），就会把行数往上移。<code>column_position</code>字段会跟踪最后一行的实时位置；<code>color_code</code>指定当前的前景色和背景色；<code>buffer</code>中存储一个VGA缓冲区的引用。需要注意的是，我们在这里需要指定一个<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-annotation-syntax">显式生命周期</a>来告诉编译器这个引用的有效期是多久。<code>&#39;static</code>生命周期指定了引用在整个程序运行时间内都是有效的（这对VGA文本缓冲区来说是事实）。</p>
<h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><p>现在我们可以使用<code>Writer</code>来修改缓冲区的字符。首先我们创建一个方法来写入一个ASCII字节：</p>
<figure class="highlight rust"><figcaption><span>in src/vga_buffer.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Writer &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">write_byte</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, byte: <span class="built_in">u8</span>) &#123;</span><br><span class="line">        <span class="keyword">match</span> byte &#123;</span><br><span class="line">            <span class="string">b&#x27;\n&#x27;</span> =&gt; <span class="keyword">self</span>.new_line(),</span><br><span class="line">            byte =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">self</span>.column_position &gt;= BUFFER_WIDTH &#123;</span><br><span class="line">                    <span class="keyword">self</span>.new_line();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> row = BUFFER_HEIGHT - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">let</span> col = <span class="keyword">self</span>.column_position;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> color_code = <span class="keyword">self</span>.color_code;</span><br><span class="line">                <span class="keyword">self</span>.buffer.chars[row][col] = ScreenChar &#123;</span><br><span class="line">                    ascii_character: byte,</span><br><span class="line">                    color_code,</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">self</span>.column_position += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new_line</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;<span class="comment">/* TODO */</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这个字节是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Newline">换行</a>字节<code>\n</code>，那么writer就不会打印任何内容，而是调用<code>new_line</code>方法，这个方法我们将在后面实现。在第二种匹配情况下，其他字节会被打印到屏幕上。</p>
<p>在打印字节时，writer会检查当前的行是否已满。若当前行已满，需要先调用<code>new_line</code>来结束这一行。然后，它将一个新的<code>ScreenChar</code>写入当前位置的缓冲区。最后，将当前列的位置前进一个字符。</p>
<p>要打印整个字符串，我们可以将它们转换成字节，然后逐一打印：</p>
<figure class="highlight rust"><figcaption><span>in src/vga_buffer.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Writer &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">write_string</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> byte <span class="keyword">in</span> s.bytes() &#123;</span><br><span class="line">            <span class="keyword">match</span> byte &#123;</span><br><span class="line">                <span class="comment">// 若属于可打印的ASCII字符或换行符，则打印</span></span><br><span class="line">                <span class="number">0x20</span>..=<span class="number">0x7e</span> | <span class="string">b&#x27;\n&#x27;</span> =&gt; <span class="keyword">self</span>.write_byte(byte),</span><br><span class="line">                <span class="comment">// 若不属于可打印的ASCII字符，则打印0xfe</span></span><br><span class="line">                _ =&gt; <span class="keyword">self</span>.write_byte(<span class="number">0xfe</span>),</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VGA文本缓冲区只支持ASCII字符和<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Code_page_437">代码页437</a>的附加字符。Rust字符串默认为<code>UTF-8</code>，所以它们可能包含VGA文本缓冲区不支持的字节。我们使用匹配来区分可打印的ASCII字节（换行或空格符和<code>~</code>字符之间的任何字符）和不可打印的字节。对于不可打印的字节，我们打印一个<code>■</code>字符，它在VGA硬件上的十六进制代码为<code>0xfe</code>。</p>
<h4 id="试试吧"><a href="#试试吧" class="headerlink" title="试试吧"></a>试试吧</h4><p>要在屏幕上写一些字符，可以创建一个临时函数：</p>
<figure class="highlight rust"><figcaption><span>in src/vga_buffer.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">print_something</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> writer = Writer &#123;</span><br><span class="line">        column_position: <span class="number">0</span>,</span><br><span class="line">        color_code: ColorCode::new(Color::Yellow, Color::Black),</span><br><span class="line">        buffer: <span class="keyword">unsafe</span> &#123; &amp;<span class="keyword">mut</span> *(<span class="number">0xb8000</span> <span class="keyword">as</span> *<span class="keyword">mut</span> Buffer) &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    writer.write_byte(<span class="string">b&#x27;H&#x27;</span>);</span><br><span class="line">    writer.write_string(<span class="string">&quot;ello &quot;</span>);</span><br><span class="line">    writer.write_string(<span class="string">&quot;Wörld!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数首先创建一个新的Writer，指向位于<code>0xb8000</code>的VGA缓冲区，这里的语法看起来可能有点奇怪。首先，我们把整数<code>0xb8000</code>作为一个可变的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer">裸指针</a>。然后我们通过解引用（使用<code>*</code>运算符）将其转换为可变引用，并立即再次借用（通过<code>&amp;mut</code>）。这种转换需要一个<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html"><code>unsafe</code>块</a>，因为编译器不能保证裸指针是有效的。</p>
<p>然后它将字节<code>b&#39;H&#39;</code>写入其中。<code>b</code>前缀创建了一个<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/reference/tokens.html#byte-literals">文字字节</a>，它代表一个ASCII字符。通过写入字符串<code>&quot;ello &quot;</code>和<code>&quot;Wörld!&quot;</code>，我们测试了我们的<code>write_string</code>方法和对不可打印字符的处理。为了看到输出，我们需要从<code>_start</code>函数中调用<code>print_something</code>函数：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>() -&gt; ! &#123;</span><br><span class="line">    vga_buffer::print_something();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在运行项目时，屏幕左下角应该会打印出一个黄色的<code>Hello W■■rld！</code>。</p>
<p><img src="https://os.phil-opp.com/vga-text-mode/vga-hello.png" alt="QEMU左下角中输出黄色的&quot;Hello W■■rld!&quot;"></p>
<p>注意到<code>ö</code>被打印成两个<code>■</code>字符。这是因为<code>ö</code>在<a target="_blank" rel="noopener" href="https://www.fileformat.info/info/unicode/utf8.htm">UTF-8</a>中由两个字节表示，这两个字节都不属于可打印的ASCII范围。实际上这是UTF-8的一个基本属性：多字节值的单个字节永远不是有效的ASCII码。</p>
<h3 id="易失性操作"><a href="#易失性操作" class="headerlink" title="易失性操作"></a>易失性操作</h3><p>我们刚刚看到信息被正确打印出来了。然而，它可能无法与未来更加积极优化的Rust编译器一起工作。</p>
<p>问题在于，是我们只对<code>Buffer</code>进行写入，而没有再从中读取。编译器不知道我们的确访问了VGA缓冲区内存（而不是正常内存），也不知道一些字符已经出现在屏幕上的额外效果。所以编译器可能决定这些写入是不必要的，可以省略。为了避免这种错误的优化，我们需要将这些写入指定为<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Volatile_(computer_programming)">易失的</a>。这就告诉编译器，这个写有副作用，不应该被优化掉。</p>
<p>为了对VGA缓冲区使用易失性写，我们使用<code>volatile</code>库。这个crate（在Rust世界中，包是这样称呼的）提供了一个带有<code>read</code>和<code>write</code>方法的<code>Volatile</code>包装类型。这些方法在内部使用了核心库的<code>read_volatile</code>和<code>write_volatile</code>函数，从而保证了读/写操作不会被优化掉。</p>
<p>我们可以通过在<code>Cargo.toml</code>的<code>dependencies</code>部分添加一个对<code>volatile</code>crate的依赖：</p>
<figure class="highlight toml"><figcaption><span>n Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">volatile</span> = <span class="string">&quot;0.2.6&quot;</span></span><br></pre></td></tr></table></figure>

<p>确保指定<code>volatile</code>版本为<code>0.2.6</code>。新版本的crate不兼容本文。0.2.6是<a target="_blank" rel="noopener" href="https://semver.org/">语义</a>版本号。更多信息，请参见cargo文档的<a target="_blank" rel="noopener" href="https://doc.crates.io/specifying-dependencies.html">指定依赖指南</a>。</p>
<p>让我们用它来进行VGA缓冲区的易失性写入，更新的Buffer类型如下：</p>
<figure class="highlight rust"><figcaption><span>in src/vga_buffer.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> volatile::Volatile;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Buffer</span></span> &#123;</span><br><span class="line">    chars: [[Volatile&lt;ScreenChar&gt;; BUFFER_WIDTH]; BUFFER_HEIGHT],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在使用<code>Volatile&lt;ScreenChar&gt;</code>来代替<code>ScreenChar</code>，（<code>Volatile</code>是<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch10-01-syntax.html">泛型</a>，几乎可以包装任何类型）。这确保了我们不能通过“普通”的写方法（译者注：如赋值）意外地写入到它。相反，我们现在必须调用<code>write</code>方法。</p>
<p>这意味着我们必须更新<code>Writer::write_byte</code>方法：</p>
<figure class="highlight rust"><figcaption><span>in src/vga_buffer.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Writer &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">write_byte</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, byte: <span class="built_in">u8</span>) &#123;</span><br><span class="line">        <span class="keyword">match</span> byte &#123;</span><br><span class="line">            <span class="string">b&#x27;\n&#x27;</span> =&gt; <span class="keyword">self</span>.new_line(),</span><br><span class="line">            byte =&gt; &#123;</span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">                <span class="keyword">self</span>.buffer.chars[row][col].write(ScreenChar &#123;</span><br><span class="line">                    ascii_character: byte,</span><br><span class="line">                    color_code,</span><br><span class="line">                &#125;);</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在使用的是<code>write</code>方法，而不是使用<code>=</code>的普通赋值。这样可以保证编译器永远不会优化掉这个写操作。</p>
<h3 id="格式化宏"><a href="#格式化宏" class="headerlink" title="格式化宏"></a>格式化宏</h3><p>如果能支持Rust的格式化宏就更好了。这样一来，我们就可以轻松地打印不同的类型，如整数或浮点数。接下来，我们需要实现<code>core::fmt::Write</code>trait。这个trait唯一需要实现方法是<code>write_str</code>，它看起来和我们的<code>write_string</code>方法很相似，只不过返回类型为<code>fmt::Result</code>：</p>
<figure class="highlight rust"><figcaption><span>in src/vga_buffer.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> core::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> fmt::Write <span class="keyword">for</span> Writer &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write_str</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;<span class="built_in">str</span>) -&gt; fmt::<span class="built_in">Result</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.write_string(s);</span><br><span class="line">        <span class="literal">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Ok(())</code>只是一个包含<code>()</code>类型的<code>Ok</code> Result。</p>
<p>现在我们可以使用Rust内置的<code>write!</code>/<code>writeln!</code>格式化宏了：</p>
<figure class="highlight rust"><figcaption><span>in src/vga_buffer.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">print_something</span></span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> core::fmt::Write;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> writer = Writer &#123;</span><br><span class="line">        column_position: <span class="number">0</span>,</span><br><span class="line">        color_code: ColorCode::new(Color::Yellow, Color::Black),</span><br><span class="line">        buffer: <span class="keyword">unsafe</span> &#123; &amp;<span class="keyword">mut</span> *(<span class="number">0xb8000</span> <span class="keyword">as</span> *<span class="keyword">mut</span> Buffer) &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    writer.write_byte(<span class="string">b&#x27;H&#x27;</span>);</span><br><span class="line">    writer.write_string(<span class="string">&quot;ello! &quot;</span>);</span><br><span class="line">    <span class="built_in">write!</span>(writer, <span class="string">&quot;The numbers are &#123;&#125; and &#123;&#125;&quot;</span>, <span class="number">42</span>, <span class="number">1.0</span>/<span class="number">3.0</span>).unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在你应该在屏幕底部看到<code>Hello! The numbers are 42 and 0.3333333333333333</code>。<code>write!</code>会返回一个<code>Result</code>，如果不使用会引起警告，所以我们在上面调用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/result/enum.Result.html#method.unwrap"><code>unwrap</code></a>函数，如果发生错误，它会panic。现阶段并没有这种问题，因为对VGA缓冲区的写入不会失败。</p>
<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>截至上一节，我们都忽略了换行或字符超出一行容量的情况。遇到这种情况时，我们希望将每个字符向上移动一行（最上面的一行被删除），然后从最后一行的行首重新开始。要做到这一点，我们为<code>Writer</code>的<code>new_line</code>方法添加一个实现：</p>
<figure class="highlight rust"><figcaption><span>in src/vga_buffer.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Writer &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new_line</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="number">1</span>..BUFFER_HEIGHT &#123;</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="number">0</span>..BUFFER_WIDTH &#123;</span><br><span class="line">                <span class="keyword">let</span> character = <span class="keyword">self</span>.buffer.chars[row][col].read();</span><br><span class="line">                <span class="keyword">self</span>.buffer.chars[row - <span class="number">1</span>][col].write(character);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.clear_row(BUFFER_HEIGHT - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">self</span>.column_position = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clear_row</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, row: <span class="built_in">usize</span>) &#123;<span class="comment">/* TODO */</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们对所有屏幕字符进行迭代，并将每个字符向上移动一行。请注意，区间范围(<code>..</code>)是前开后闭的。此外，我们也不迭代第<code>0</code>行（第一个循环从<code>1</code>开始），因为它是被移出屏幕的那一行。</p>
<p>为了完成换行代码，我们再添加<code>clear_row</code>方法：</p>
<figure class="highlight rust"><figcaption><span>in src/vga_buffer.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Writer &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clear_row</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, row: <span class="built_in">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> blank = ScreenChar &#123;</span><br><span class="line">            ascii_character: <span class="string">b&#x27; &#x27;</span>,</span><br><span class="line">            color_code: <span class="keyword">self</span>.color_code,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="number">0</span>..BUFFER_WIDTH &#123;</span><br><span class="line">            <span class="keyword">self</span>.buffer.chars[row][col].write(blank);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法通过用空格字符覆盖所有字符来清除一行。</p>
<h2 id="全局接口"><a href="#全局接口" class="headerlink" title="全局接口"></a>全局接口</h2><p>提供一个全局<code>Writer</code>作为接口，可以使其他模块免去自己实例化<code>Writer</code>的麻烦，我们试着创建一个静态变量<code>WRITER</code>：</p>
<figure class="highlight rust"><figcaption><span>in src/vga_buffer.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">static</span> WRITER: Writer = Writer &#123;</span><br><span class="line">    column_position: <span class="number">0</span>,</span><br><span class="line">    color_code: ColorCode::new(Color::Yellow, Color::Black),</span><br><span class="line">    buffer: <span class="keyword">unsafe</span> &#123; &amp;<span class="keyword">mut</span> *(<span class="number">0xb8000</span> <span class="keyword">as</span> *<span class="keyword">mut</span> Buffer) &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是，如果我们现在尝试编译它，会出现以下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">error[E0015]: calls <span class="keyword">in</span> statics are limited to constant <span class="built_in">functions</span>, tuple structs and tuple variants</span><br><span class="line"> --&gt; src/vga_buffer.rs:7:17</span><br><span class="line">  |</span><br><span class="line">7 |     color_code: ColorCode::new(Color::Yellow, Color::Black),</span><br><span class="line">  |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line"></span><br><span class="line">error[E0396]: raw pointers cannot be dereferenced <span class="keyword">in</span> statics</span><br><span class="line"> --&gt; src/vga_buffer.rs:8:22</span><br><span class="line">  |</span><br><span class="line">8 |     buffer: unsafe &#123; &amp;mut *(0xb8000 as *mut Buffer) &#125;,</span><br><span class="line">  |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereference of raw pointer <span class="keyword">in</span> constant</span><br><span class="line"></span><br><span class="line">error[E0017]: references <span class="keyword">in</span> statics may only refer to immutable values</span><br><span class="line"> --&gt; src/vga_buffer.rs:8:22</span><br><span class="line">  |</span><br><span class="line">8 |     buffer: unsafe &#123; &amp;mut *(0xb8000 as *mut Buffer) &#125;,</span><br><span class="line">  |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ statics require immutable values</span><br><span class="line"></span><br><span class="line">error[E0017]: references <span class="keyword">in</span> statics may only refer to immutable values</span><br><span class="line"> --&gt; src/vga_buffer.rs:8:13</span><br><span class="line">  |</span><br><span class="line">8 |     buffer: unsafe &#123; &amp;mut *(0xb8000 as *mut Buffer) &#125;,</span><br><span class="line">  |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ statics require immutable values</span><br></pre></td></tr></table></figure>

<p>为了理解这里发生的事情，我们需要知道，与普通变量在运行时初始化不同的是，静态变量是在编译时初始化的。Rust编译器中对此类初始化表达式进行求值的组件叫做 “<a target="_blank" rel="noopener" href="https://rustc-dev-guide.rust-lang.org/const-eval.html">常量求值器</a>”。虽然它的功能现在还仍然有限，不过对其功能的扩展工作也在进行中，例如RFC“<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rfcs/pull/2345">允许常量中的panic</a>”。</p>
<p>关于<code>ColorCode::new</code>的问题可以利用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/unstable-book/language-features/const-fn.html"><code>const</code>函数</a>来解决，但这里的根本问题是Rust的常量求值器无法在编译时将原始指针转换为引用。也许未来的某一天将会支持该功能，但在那之前，我们必须找到另一个解决方案。</p>
<h3 id="惰性静态变量"><a href="#惰性静态变量" class="headerlink" title="惰性静态变量"></a>惰性静态变量</h3><p>用非常函数一次性初始化静态变量是Rust中常见的问题。幸运的是，在一个名为<a target="_blank" rel="noopener" href="https://docs.rs/lazy_static/1.0.1/lazy_static/">lazy_static</a>的crate中已经存在一个很好的解决方案。这个crate提供了一个<code>lazy_static!</code>宏，定义了一个惰性初始化的<code>static</code>。<code>static</code>在编译时不计算其的值，而是在第一次被访问时进行惰性初始化。因此，初始化发生在运行时，这使得各种复杂初始化代码成为可能。</p>
<p>让我们在项目中添加<code>lazy_static</code>crate。</p>
<figure class="highlight toml"><figcaption><span>in Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies.lazy_static]</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"><span class="attr">features</span> = [<span class="string">&quot;spin_no_std&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>我们需要<code>spin_no_std</code>特性，因为我们并没有链接标准库。</p>
<p>有了<code>lazy_static</code>，我们便可以定义静态<code>WRITER</code>：</p>
<figure class="highlight rust"><figcaption><span>in src/vga_buffer.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> WRITER: Writer = Writer &#123;</span><br><span class="line">        column_position: <span class="number">0</span>,</span><br><span class="line">        color_code: ColorCode::new(Color::Yellow, Color::Black),</span><br><span class="line">        buffer: <span class="keyword">unsafe</span> &#123; &amp;<span class="keyword">mut</span> *(<span class="number">0xb8000</span> <span class="keyword">as</span> *<span class="keyword">mut</span> Buffer) &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，这个<code>WRITER</code>并没有什么用，因为它是不可变的，这意味着我们不能向它写任何东西（因为所有的写方法都需要获取<code>&amp;mut self</code>）。一个可能的解决方案是使用一个<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable">可变静态变量</a>。但是这样一来，对它的每一次读写都将是不安全的，因为这样很容易引入数据竞争和其他不好的东西。使用<code>static mut</code>是非常不推荐的，以至于有人提议<a target="_blank" rel="noopener" href="https://internals.rust-lang.org/t/pre-rfc-remove-static-mut/1437">移除</a>这一特性。那么，有没有什么替代方案呢？我们可以尝试使用一个不可变的静态变量加上诸如<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html#keeping-track-of-borrows-at-runtime-with-refcellt"><code>RefCell</code></a>甚至<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/cell/struct.UnsafeCell.html"><code>UnsafeCell</code></a>，以提供内部可突变性。但是这些类型不具有<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html"><code>Sync</code></a>特性（有充分的理由），所以我们不能在静态变量中使用它们。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>为了获得同步的（即具有<code>Sync</code>trait的）内部可变性，标准库的用户可以使用互斥锁<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/std/sync/struct.Mutex.html"><code>Mutex</code></a>。它在资源已经被锁定的情况下，通过阻塞线程来提供线程间互斥。但是我们的基本内核没有任何阻塞支持，甚至没有线程的概念，所以我们也无法使用它。然而在计算机科学中，有一种非常基础的互斥，它不需要操作系统的功能：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Spinlock">自旋锁</a>。线程不进行阻塞，而只是在一个循环中不停的尝试锁定它，从而消耗CPU时间，直到锁再次释放。</p>
<p>要使自旋锁，我们需要添加<a target="_blank" rel="noopener" href="https://crates.io/crates/spin">spin</a> crate作为依赖：</p>
<figure class="highlight toml"><figcaption><span>in Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">spin</span> = <span class="string">&quot;0.5.2&quot;</span></span><br></pre></td></tr></table></figure>

<p>于是，我们可以使用自旋锁来为我们的静态WRITER添加安全的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">内部可变性</a>。</p>
<figure class="highlight rust"><figcaption><span>in src/vga_buffer.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> spin::Mutex;</span><br><span class="line">...</span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> WRITER: Mutex&lt;Writer&gt; = Mutex::new(Writer &#123;</span><br><span class="line">        column_position: <span class="number">0</span>,</span><br><span class="line">        color_code: ColorCode::new(Color::Yellow, Color::Black),</span><br><span class="line">        buffer: <span class="keyword">unsafe</span> &#123; &amp;<span class="keyword">mut</span> *(<span class="number">0xb8000</span> <span class="keyword">as</span> *<span class="keyword">mut</span> Buffer) &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以删除临时函数<code>print_something</code>，直接从<code>_start</code>函数中打印：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>() -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">use</span> core::fmt::Write;</span><br><span class="line">    vga_buffer::WRITER.lock().write_str(<span class="string">&quot;Hello again&quot;</span>).unwrap();</span><br><span class="line">    <span class="built_in">write!</span>(vga_buffer::WRITER.lock(), <span class="string">&quot;, some numbers: &#123;&#125; &#123;&#125;&quot;</span>, <span class="number">42</span>, <span class="number">1.337</span>).unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要导入<code>fmt::Write</code>trait来使用它的功能。</p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>请注意，在我们的代码中，我们只有一个不安全的块，即需要创建一个指向<code>0xb8000</code>的裸指针作为<code>Buffer</code>并进行可变引用。之后，所有的操作都是安全的。Rust默认对数组访问使用边界检查，所以我们不能意外地写到缓冲区之外。因此，我们在类型系统中对所需的条件进行了编码，并且能够向外部提供一个安全的接口。</p>
<h3 id="println打印宏"><a href="#println打印宏" class="headerlink" title="println打印宏"></a><code>println</code>打印宏</h3><p>现在我们有了一个全局writer，可以再添加一个<code>println</code>宏，使其可以在代码库的任何地方使用。Rust的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/book/ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming">宏语法</a>有点奇怪，所以我们不会尝试从头开始写一个宏。让我们先看看标准库中<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/std/macro.println!.html"><code>println!</code>宏</a>的源码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    () =&gt; (<span class="built_in">print!</span>(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">    ($($arg:tt)*) =&gt; (<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;\n&quot;</span>, <span class="built_in">format_args!</span>($($arg)*)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>宏是通过一个或多个规则来定义的，这些规则类似于<code>match</code>的匹配分支。<code>println</code>宏有两个规则：第一条规则是没有参数的调用（例如<code>println!()</code>）, 它被扩展为<code>print!(&quot;\n&quot;)</code>, 因此只是换行。第二条规则是有参数的调用，例如<code>println!(&quot;Hello&quot;)</code>或<code>println!(&quot;Number: &#123;&#125;&quot;, 4)</code>。它也是扩展为调用<code>print!</code>宏，传递所有参数，并在结尾处附加一个换行符<code>\n</code>。</p>
<p><code>#[macro_export]</code>属性使宏可以被整个crate（而不仅仅是其定义所在的模块）和外部crate所使用。它还将宏置于crate根，这意味着我们必须通过使用<code>std::println</code>而不是<code>std::macros::println</code>来进行导入。</p>
<p>而<code>print!</code>宏的定义为：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> print &#123;</span><br><span class="line">    ($($arg:tt)*) =&gt; ($crate::io::_print(<span class="built_in">format_args!</span>($($arg)*)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该宏扩展为调用<code>io</code>模块中的<code>_print</code>函数。<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/1.30.0/book/first-edition/macros.html#the-variable-crate"><code>$crate</code>变量</a>保证了这个宏在其他模块中使用时，通过扩展到<code>std</code>的方式，也能在<code>std</code>模块之外工作。</p>
<p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/std/macro.format_args.html"><code>format_args</code></a>宏使用其中传递的参数中新建一个<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Arguments.html"><code>fmt::Arguments</code></a>类型，并传递给<code>_print</code>。libstd的<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/blob/29f5c699b11a6a148f097f82eaa05202f8799bbc/src/libstd/io/stdio.rs#L698"><code>_print</code>函数</a>调用<code>print_to</code>，这个函数相当复杂，因为它支持不同的<code>Stdout</code>设备。我们并不需要那么复杂，因为我们只是想打印到VGA缓冲区。</p>
<p>要打印到VGA缓冲区，我们只需复制<code>println!</code>和<code>print!</code>宏，并修改它们以使用我们自己的<code>_print</code>函数：</p>
<figure class="highlight rust"><figcaption><span>in src/vga_buffer.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> print &#123;</span><br><span class="line">    ($($arg:tt)*) =&gt; ($crate::vga_buffer::_print(<span class="built_in">format_args!</span>($($arg)*)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    () =&gt; ($crate::<span class="built_in">print!</span>(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">    ($($arg:tt)*) =&gt; ($crate::<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;\n&quot;</span>, <span class="built_in">format_args!</span>($($arg)*)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[doc(hidden)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">_print</span></span>(args: fmt::Arguments) &#123;</span><br><span class="line">    <span class="keyword">use</span> core::fmt::Write;</span><br><span class="line">    WRITER.lock().write_fmt(args).unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们对原来的<code>println</code>定义做了一个改动，就是在调用<code>print!</code>宏的时候也添加<code>$crate</code>前缀。这确保了如果我们只想使用<code>println</code>时，不需要再导入<code>print!</code>宏。</p>
<p>像标准库中的实现一样，我们为这两个宏都添加了<code>#[macro_export]</code>属性，使它们在我们的crate中随处可用。请注意，此举将宏放在crate的根命名空间中，所以通过使用<code>crate::vga_buffer::println</code>导入它们是行不通的。相反，我们必须使用<code>crate::println</code>。</p>
<p><code>_print</code>函数获得静态变量<code>WRITER</code>的锁，并对其调用<code>write_fmt</code>方法。这个方法来自<code>Write</code>trait，我们需要导入那个trait。如果打印不成功，结尾的<code>unwrap()</code>就会panic。但是由于我们总是在<code>write_str</code>中返回<code>Ok</code>，所以这种情况应该不会发生。</p>
<p>由于宏需要能够从模块外部调用<code>_print</code>，所以该函数必须是公共的。但是，由于我们认为这是一个私有的实现细节，所以我们添加了<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#dochidden">doc(hidden)属性</a>，以在生成的文档中因此该函数的说明。</p>
<h3 id="使用println打印Hello-World"><a href="#使用println打印Hello-World" class="headerlink" title="使用println打印Hello World"></a>使用<code>println</code>打印Hello World</h3><p>现在我们可以在<code>_start</code>函数中使用<code>println</code>：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello World&#123;&#125;&quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，我们不必在main函数中导入宏，因为它已经存在于根命名空间中。</p>
<p>正如预期的那样，我们现在看到屏幕上出现了 “Hello World!”：</p>
<p><img src="https://os.phil-opp.com/vga-text-mode/vga-hello-world.png" alt="QEMU打印 “Hello World!”"></p>
<h3 id="打印panic信息"><a href="#打印panic信息" class="headerlink" title="打印panic信息"></a>打印panic信息</h3><p>现在我们已经有了一个<code>println</code>宏，我们可以在我们的panic函数中使用它来打印panic信息和panic的位置：</p>
<figure class="highlight rust"><figcaption><span>in main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 函数在panic时被调用</span></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">panic</span></span>(info: &amp;PanicInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, info);</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们现在在<code>_start</code>函数中插入<code>panic!(&quot;Some panic message&quot;);</code>时，就会得到以下输出：</p>
<p><img src="https://os.phil-opp.com/vga-text-mode/vga-panic.png" alt="QEMU打印&quot;panicked at &#39;Some panic message&#39;, src/main.rs:28:5&quot;"></p>
<p>于是，我们不仅知道产生了panic，还知道panic信息以及它发生在代码的什么地方。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在这篇文章中，我们了解了VGA文本缓冲区的结构，以及如何通过地址<code>0xb8000</code>的内存映射进行写入。我们创建了一个Rust模块，封装了向这个内存映射缓冲区写入数据的非安全操作，并向外部提供了一个安全便捷的接口。</p>
<p>我们也看到了添加第三方库依赖关系是多么的简单，这要感谢cargo工具。我们添加的两个依赖，<code>lazy_static</code>和<code>spin</code>，这两个库在操作系统开发中非常有用，我们会在以后的文章中将有更多的地方用到它们。</p>
<h2 id="下期预告"><a href="#下期预告" class="headerlink" title="下期预告"></a>下期预告</h2><p>下一篇文章将解释如何设置Rust的内置单元测试框架，然后我们将为这篇文章中的VGA缓冲模块创建一些基本的单元测试。</p>
<h2 id="支持本项目"><a href="#支持本项目" class="headerlink" title="支持本项目"></a>支持本项目</h2><p>创建和<a target="_blank" rel="noopener" href="https://os.phil-opp.com/status-update/">维护</a>这个博客和相关库是一项繁重的工作，但我真的很喜欢。通过支持我，您可以让我在新内容、新功能和持续维护上投入更多时间。</p>
<p>支持我的最好方式是<a target="_blank" rel="noopener" href="https://github.com/sponsors/phil-opp">在GitHub上赞助我</a>，因为他们不收取任何中间费用。如果你喜欢其他平台，我也有<a target="_blank" rel="noopener" href="https://www.patreon.com/phil_opp">Patreon</a>和<a target="_blank" rel="noopener" href="https://donorbox.org/phil-opp">Donorbox</a>账户。后者是最灵活的，因为它支持多种货币和一次性捐款。</p>
<p>感谢您的支持！</p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Rust/">Rust</a><a class="link-muted mr-2" rel="tag" href="/tags/Operating-System/">Operating System</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatpay.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/03/06/writing-an-os-in-rust-1.4/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">使用Rust编写操作系统 - 1.4 - 测试</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/02/21/writing-an-os-in-rust-1.2/"><span class="level-item">使用Rust编写操作系统 - 1.2 - 最小化Rust内核</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><script src="https://utteranc.es/client.js" repo="zlotus/comment" issue-term="pathname" label="some-issue-label" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/opm_sq.png" alt="子实"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">子实</p><p class="is-size-6 is-block">程序员</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>陕西/西安</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">81</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">23</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zlotus" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com/qinzishi"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/Zealot_uS"><i class="fab fa-twitter"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.zhihu.com/people/zlotus" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Diary/"><span class="level-start"><span class="level-item">Diary</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">67</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Shell/"><span class="level-start"><span class="level-item">Shell</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Coroutines/"><span class="tag">Coroutines</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">33</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenCV/"><span class="tag">OpenCV</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Operating-System/"><span class="tag">Operating System</span><span class="tag">21</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Paper/"><span class="tag">Paper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Raspberry-Pi/"><span class="tag">Raspberry Pi</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag">29</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TensorFlow/"><span class="tag">TensorFlow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tokio/"><span class="tag">Tokio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZMQ/"><span class="tag">ZMQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ctpn/"><span class="tag">ctpn</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/llama/"><span class="tag">llama</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macOS/"><span class="tag">macOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/obsidion/"><span class="tag">obsidion</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%A5%E8%AE%B0/"><span class="tag">日记</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E8%B0%88/"><span class="tag">杂谈</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B/"><span class="tag">编程</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%84%9A%E6%9C%AC/"><span class="tag">脚本</span><span class="tag">4</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a><p class="is-size-7"><span>&copy; 2024 子实</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>