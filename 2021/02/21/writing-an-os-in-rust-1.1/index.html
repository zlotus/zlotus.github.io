<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>使用Rust编写操作系统 - 1.1 - Rust独立二进制程序 - 子实</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="子实"><meta name="msapplication-TileImage" content="/img/avatar-o.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="子实"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="使用Rust编写操作系统 - 1.1 - Rust独立二进制程序"><meta property="og:type" content="article"><meta property="og:title" content="使用Rust编写操作系统 - 1.1 - Rust独立二进制程序"><meta property="og:url" content="https://zlotus.github.io/2021/02/21/writing-an-os-in-rust-1.1/"><meta property="og:site_name" content="子实"><meta property="og:description" content="使用Rust编写操作系统 - 1.1 - Rust独立二进制程序"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zlotus.github.io/img/og_image.png"><meta property="article:published_time" content="2021-02-21T08:56:00.000Z"><meta property="article:modified_time" content="2021-02-21T08:56:00.000Z"><meta property="article:author" content="子实"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Operating System"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><meta property="twitter:creator" content="@Zealot_uS"><meta property="twitter:site" content="Zealot_uS"><link rel="publisher" href="+LotusQin"><meta property="fb:admins" content="qinzishi"><meta property="fb:app_id" content="qinzishi"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zlotus.github.io/2021/02/21/writing-an-os-in-rust-1.1/"},"headline":"使用Rust编写操作系统 - 1.1 - Rust独立二进制程序","image":["https://zlotus.github.io/img/og_image.png"],"datePublished":"2021-02-21T08:56:00.000Z","dateModified":"2021-02-21T08:56:00.000Z","author":{"@type":"Person","name":"子实"},"publisher":{"@type":"Organization","name":"子实","logo":{"@type":"ImageObject","url":"https://zlotus.github.io/img/opm_sq.png"}},"description":"使用Rust编写操作系统 - 1.1 - Rust独立二进制程序"}</script><link rel="icon" href="/img/avatar-o.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/2014/07/09/about-me/">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-21T08:56:00.000Z" title="2/21/2021, 4:56:00 PM">2021-02-21</time>发表</span><span class="level-item"><time dateTime="2021-02-21T08:56:00.000Z" title="2/21/2021, 4:56:00 PM">2021-02-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a></span><span class="level-item">1 小时读完 (大约6857个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">使用Rust编写操作系统 - 1.1 - Rust独立二进制程序</h1><div class="content"><article class="message message-immersive is-warning">
<div class="message-body">
<i class="fas fa-exclamation-triangle mr-2"></i>本文所有内容均为翻译，原文：<a target="_blank" rel="noopener" href="https://os.phil-opp.com/freestanding-rust-binary/">A Freestanding Rust Binary</a>；原项目：<a target="_blank" rel="noopener" href="https://os.phil-opp.com/">Writing an OS in Rust</a>
</div>
</article>

<p>创建我们自己的操作系统内核的第一步，是创建一个不链接标准库的Rust可执行程序。这样就可以在没有底层操作系统的情况下在<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bare_machine">裸机</a>上运行Rust代码。</p>
<span id="more"></span>

<p>这个博客是在<a target="_blank" rel="noopener" href="https://github.com/phil-opp/blog_os">GitHub</a>上公开开发的。如果你有任何问题或疑问，请在那里开一个issue。你也可以在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/freestanding-rust-binary/#comments">底部</a>留言。这篇文章的完整源代码可以在<a target="_blank" rel="noopener" href="https://github.com/phil-opp/blog_os/tree/post-01">post-01</a>分支中找到。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>要编写操作系统内核，我们需要写出的代码不能依赖任何操作系统提供的功能。这意味着我们不能使用线程、文件、堆内存、网络、随机数、标准输出或任何其他需要操作系统抽象或需要特定硬件的功能。这是有道理的，毕竟我们正在尝试编写自己的操作系统和自己的驱动程序。</p>
<p>这意味着我们不能使用大多数<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/">Rust标准库</a>，但是可以使用很多Rust功能。例如，我们可以使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch13-02-iterators.html">迭代器</a>、<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch13-01-closures.html">闭包</a>、<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch06-00-enums.html">模式匹配</a>、<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/option/">Option</a>、<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/result/index.html">Result</a>、<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/macro.write.html">格式化字符串</a>，当然还有<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">所有权系统</a>。这些功能使我们能够以一种非常有表现力的高级方式编写内核，而不必担心<a target="_blank" rel="noopener" href="https://www.nayuki.io/page/undefined-behavior-in-c-and-cplusplus-programs">未定义行为</a>或<a target="_blank" rel="noopener" href="https://tonyarcieri.com/it-s-time-for-a-memory-safety-intervention">内存安全</a>。</p>
<p>为了使用Rust创建OS内核，我们需要创建一个无需底层操作系统即可运行的可执行文件。这种可执行文件通常称为“独立式”或“裸机”可执行文件。</p>
<p>这篇文章描述了创建一个Rust独立二进制文件的必要步骤，并解释了为什么需要这些步骤。如果您仅对一个最小的示例感兴趣，则可以直接跳转至<a href="./#%E5%B0%8F%E7%BB%93"><strong>小结</strong></a>部分。</p>
<h2 id="禁用标准库"><a href="#禁用标准库" class="headerlink" title="禁用标准库"></a>禁用标准库</h2><p>默认情况下，所有Rust crate都链接<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/">标准库</a>，该库建立在操作系统的线程、文件或网络等功能之上。它还依赖于C标准库<code>libc</code>，该库与OS服务紧密交互。我们的计划是编写一个操作系统，因此不能使用任何依赖于OS的库。我们必须通过<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/1.30.0/book/first-edition/using-rust-without-the-standard-library.html"><code>no_std</code></a>属性禁用自动引用标准库。</p>
<p>首先创建一个新的cargo项目。最简单的方法是通过命令行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new blog_os --bin --edition 2018</span><br></pre></td></tr></table></figure>

<p>我将项目命名为<code>blog_os</code>，你当然可以选择自己喜欢的名称。<code>--bin</code>标志意为创建可执行二进制文件（与创建库的<code>--lib</code>不同），而<code>--edition 2018</code>参数指定crate需要使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/edition-guide/rust-2018/index.html">2018版的Rust</a>。 当我们运行命令时，cargo为我们创建以下目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">blog_os</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    └── main.rs</span><br></pre></td></tr></table></figure>

<p><code>Cargo.toml</code>包含crate配置，例如crate名称、作者、<a target="_blank" rel="noopener" href="https://semver.org/">语义版本号</a>和相关依赖。 <code>src/main.rs</code>文件包含crate的根模块和<code>main</code>函数。 您可以通过<code>cargo build</code>来编译crate，然后在<code>target/debug</code>子文件夹中运行已编译的<code>blog_os</code>二进制文件。</p>
<h3 id="no-std属性"><a href="#no-std属性" class="headerlink" title="no_std属性"></a><code>no_std</code>属性</h3><p>现在，我们的crate隐式链接了标准库。让我们尝试通过添加<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/1.30.0/book/first-edition/using-rust-without-the-standard-library.html"><code>no_std</code>属性</a>来禁用此功能：</p>
<figure class="highlight rust"><figcaption><span>main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们尝试立即构建（通过运行<code>cargo build</code>）时，会发生以下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error: cannot find macro `println!` <span class="keyword">in</span> this scope</span><br><span class="line"> --&gt; src/main.rs:4:5</span><br><span class="line">  |</span><br><span class="line">4 |     println!(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">  |     ^^^^^^^</span><br></pre></td></tr></table></figure>

<p>发生此错误是因为<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/macro.println.html"><code>println</code>宏</a>是标准库的一部分，我们不能再使用它，也就是说我们无法再打印东西。这是合理的，因为<code>println</code>写入标准输出，这也是由操作系统提供的特殊文件描述符。</p>
<p>那么让我们删除打印语句，然后使用空的main函数再试一次：</p>
<figure class="highlight rust"><figcaption><span>main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; cargo build</span><br><span class="line">error: `<span class="comment">#[panic_handler]` function required, but not found</span></span><br><span class="line">error: language item required, but not found: `eh_personality`</span><br></pre></td></tr></table></figure>

<p>现在，编译器指出缺少<code>#[panic_handler]</code>函数和一个语言项。</p>
<h2 id="实现Rust的panic"><a href="#实现Rust的panic" class="headerlink" title="实现Rust的panic"></a>实现Rust的panic</h2><p><code>panic_handler</code>属性定义的函数在发生<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/book/ch09-01-unrecoverable-errors-with-panic.html">panic</a>时会被编译器调用。标准库提供了自己的panic处理函数，但那是在<code>no_std</code>环境中，我们需要自己定义它：</p>
<figure class="highlight plaintext"><figcaption><span>main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use core::panic::PanicInfo;</span><br><span class="line"></span><br><span class="line">/// This function is called on panic.</span><br><span class="line">#[panic_handler]</span><br><span class="line">fn panic(_info: &amp;PanicInfo) -&gt; ! &#123;</span><br><span class="line">    loop &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/panic/struct.PanicInfo.html"><code>PanicInfo</code>类型的参数</a>包含产生panic时的文件和行以及可选的panic消息。该函数永不返回，因此使用<code>!</code>定义函数返回<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/std/primitive.never.html">“never”类型</a>，以将其标记为<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/1.30.0/book/first-edition/functions.html#diverging-functions">发散函数</a>。目前我们还不能在此函数中执行太多操作，因此在其中写一个无限循环。</p>
<h2 id="eh-personality语言项"><a href="#eh-personality语言项" class="headerlink" title="eh_personality语言项"></a><code>eh_personality</code>语言项</h2><p>语言项是编译器内部所需的特殊功能和类型。例如，<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html"><code>Copy</code></a> trait是一种语言项，它告诉编译器哪些类型具有<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html"><code>可复制语义</code></a>。在查看其<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src/libcore/marker.rs#L296-L299">实现</a>时，会看到特殊的<code>#[lang = &quot;copy&quot;]</code>属性，该属性将其定义为语言项。</p>
<p>虽然我们自己提供语言项的自定义实现是可能的，但仅应将其作为最后的手段。原因是语言项是非常不稳定的实现细节，甚至不会进行类型检查（编译器甚至不检查函数是否具有正确的参数类型）。幸运的是，有一种更稳定的方法可以解决上述的语言项错误。</p>
<p>被<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/blob/edb368491551a77d77a48446d4ee88b35490c565/src/libpanic_unwind/gcc.rs#L11-L45"><code>eh_personality</code>语言项</a>标记的函数用于实现<a target="_blank" rel="noopener" href="https://www.bogotobogo.com/cplusplus/stackunwinding.php">栈展开</a>功能。默认情况下，在出现<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/book/ch09-01-unrecoverable-errors-with-panic.html">panic</a>时，Rust使用栈展开为所有活动的栈变量执行析构函数。这样可以确保释放所有使用的内存，并允许父线程捕获panic并继续执行。但是，栈展开是一个复杂的过程，需要一些特定的OS库支持（例如，Linux上的<a target="_blank" rel="noopener" href="https://www.nongnu.org/libunwind/">libunwind</a>或Windows上的<a target="_blank" rel="noopener" href="https://docs.microsoft.com/de-de/windows/win32/debug/structured-exception-handling">结构化异常处理</a>），因此我们不希望将其用于我们的操作系统。</p>
<h3 id="禁用栈展开"><a href="#禁用栈展开" class="headerlink" title="禁用栈展开"></a>禁用栈展开</h3><p>在一些其他场景中同样不希望使用栈展开，因此Rust提供了一个选择，可以在发生<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/pull/32900">panic时中止</a>操作。这禁用了栈展开标志信息的生成，也会大大减小二进制程序的大小。禁用栈展开功能有多种方式，最简单的方法是将以下行添加到<code>Cargo.toml</code>中：</p>
<figure class="highlight rust"><figcaption><span>in Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[profile.dev]</span><br><span class="line">panic = <span class="string">&quot;abort&quot;</span></span><br><span class="line"></span><br><span class="line">[profile.release]</span><br><span class="line">panic = <span class="string">&quot;abort&quot;</span></span><br></pre></td></tr></table></figure>

<p>这将为<code>dev</code> profile（用于<code>cargo build</code>）和<code>release</code> profile（用于<code>cargo build --release</code>）设置中止panic策略。现在，编译器应该不提醒缺少<code>eh_personality</code>语言项了。</p>
<p>我们修复了以上两个错误。但是，如果现在尝试编译，则会发生另一个错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; cargo build</span><br><span class="line">error: requires `start` lang_item</span><br></pre></td></tr></table></figure>

<p>我们的程序缺少定义入口点的<code>start</code>语言项。</p>
<h2 id="start语言项"><a href="#start语言项" class="headerlink" title="start语言项"></a><code>start</code>语言项</h2><p>你可能会认为<code>main</code>函数是程序运行时调用的第一个函数。但是，大多数语言都有一个<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Runtime_system">运行时系统</a>，负责诸如垃圾回收（如Java）或软件线程（如Go中的goroutines）之类的事情。该运行时需要在<code>main</code>函数之前调用，因为它需要初始化自己。</p>
<p>在链接标准库的典型Rust二进制文件中，执行过程从名为<code>crt0</code>(“C runtime zero”)的C运行时库开始，该库为C应用程序设置了环境。其中包括创建堆栈并将参数放置在正确的寄存器中。然后，C运行时调用<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/blob/bb4d1491466d8239a7a5fd68bd605e3276e97afb/src/libstd/rt.rs#L32-L73">Rust运行时的入口点</a>，该入口点被<code>start</code>语言项标记。Rust的运行时非常短，它可以处理一些小事情，例如设置栈溢出防护，或是在panic时打印回​​溯信息。之后，运行时才会调用<code>main</code>函数。</p>
<p>我们的独立可执行文件无法访问Rust运行时和<code>crt0</code>，因此我们需要定义自己的入口点。自己实现<code>start</code>语言项并没有什么帮助，因为它仍然需要<code>crt0</code>。而我们要做的是直接覆盖<code>crt0</code>入口点。</p>
<h3 id="重写入口点"><a href="#重写入口点" class="headerlink" title="重写入口点"></a>重写入口点</h3><p>为了告诉Rust编译器我们不想使用普通的入口点链，需要添加了<code>#![no_main]</code>属性。</p>
<figure class="highlight rust"><figcaption><span>main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::panic::PanicInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// This function is called on panic.</span></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">panic</span></span>(_info: &amp;PanicInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能会注意到，我们删除了<code>main</code>函数，这是因为没有了底层的运行时调用，<code>main</code>就失去意义。而我们现在使用自己的<code>_start</code>函数覆盖操作系统入口点：</p>
<figure class="highlight rust"><figcaption><span>in main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>() -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用<code>#[no_mangle]</code>属性，我们禁用了<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Name_mangling">名称重整</a>，以确保Rust编译器确实输出名称为<code>_start</code>的函数。如果没有该属性，则编译器会生成一些神秘的诸如<code>_ZN3blog_os4_start7hb173fedf945531caE</code>的名称，用以为每个函数赋予唯一的名称。该属性是必需的，因为我们需要在下一步中将入口点函数的名称告知链接器。</p>
<p>我们还必须将函数标记为<code>extern &quot;C&quot;</code>，以告知编译器该函数应使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Calling_convention">C调用约定</a>（而不是默认的Rust调用约定）。将函数命名为<code>_start</code>的原因也是因为这是大多数系统的默认入口点名称。</p>
<p>这里的<code>!</code>返回类型表示这是一个发散函数，即永不返回。这是必需的，因为该入口点不会被任何函数调用，而是由操作系统或bootloader直接调用。因此该函数不会返回，而会调用操作系统的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Exit_(system_call)">退出系统调用</a>。在我们的项目中，关闭计算机可能是一个合理的操作，因为如果独立二进制程序返回后无需执行任何操作。目前，我们也通过无限循环来实现。</p>
<p>现在，当我们运行<code>cargo build</code>时，我们会看到一个难看的<strong>链接器</strong>错误。</p>
<p>我们使用<code>no_mangle</code>标记这个函数，来对它禁用<strong>名称重整</strong>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Name_mangling">name mangling</a>）——这确保Rust编译器输出一个名为<code>_start</code>的函数；否则，编译器可能最终生成名为<code>_ZN3blog_os4_start7hb173fedf945531caE</code>的函数，无法让链接器正确辨别。</p>
<p>我们还将函数标记为<code>extern &quot;C&quot;</code>，告诉编译器这个函数应当使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Calling_convention">C语言的调用约定</a>，而不是Rust语言的调用约定。函数名为<code>_start</code>，是因为大多数系统默认使用这个名字作为入口点名称。</p>
<p>与前文的<code>panic</code>函数类似，这个函数的返回值类型为<code>!</code>——它定义了一个发散函数，或者说一个不允许返回的函数。这一点是必要的，因为这个入口点不将被任何函数调用，但将直接被操作系统或<strong>引导程序</strong>（bootloader）调用。所以作为函数返回的替换，这个入口点应该调用，比如操作系统提供的<strong>exit系统调用</strong>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Exit_(system_call)">“exit” system call</a>）函数。在我们编写操作系统的情况下，关机应该是一个合适的选择，因为<strong>当一个独立式可执行程序返回时，不会留下任何需要做的事情</strong>（there is nothing to do if a freestanding binary returns）。暂时来看，我们可以添加一个无限循环，这样可以符合返回值的类型。</p>
<p>如果我们现在编译这段程序，会出来一大段不太好看的<strong>链接器错误</strong>（linker error）。</p>
<h2 id="链接器错误"><a href="#链接器错误" class="headerlink" title="链接器错误"></a>链接器错误</h2><p>链接器是一个将生成的代码组合成可执行文件的程序。由于Linux、Windows和macOS的可执行文件格式不同，因此每个系统都有自己的链接器，引发不同的错误。 而错误的本因是相同的：链接器的默认配置假定我们的程序依赖于C运行时，而实际上并非如此。</p>
<p>为了解决这个错误，我们需要告诉链接器它不应该引用C运行时。我们可以通过将一组特定的参数传递给链接器或通过构建裸机目标程序来实现。</p>
<h3 id="构建逻辑目标程序"><a href="#构建逻辑目标程序" class="headerlink" title="构建逻辑目标程序"></a>构建逻辑目标程序</h3><p>默认情况下，Rust将尝试构建一个能够在你当前的系统环境中运行的可执行文件。例如，如果你在<code>x86_64</code>硬件上使用Windows，Rust会尝试构建一个使用<code>x86_64</code>指令的<code>.exe</code> Windows可执行程序。该环境也称为您的“宿主机”系统。</p>
<p>Rust使用被称为<a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/CrossCompilation.html#target-triple">目标三元组</a>的字符串来描述不同的编译环境。你可以通过运行<code>rustc --version --verbose</code>来查看宿主机的目标三元组：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rustc 1.35.0-nightly (474e7a648 2019-04-07)</span><br><span class="line">binary: rustc</span><br><span class="line">commit-hash: 474e7a6486758ea6fc761893b1a49cd9076fb0ab</span><br><span class="line">commit-date: 2019-04-07</span><br><span class="line">host: x86_64-unknown-linux-gnu</span><br><span class="line">release: 1.35.0-nightly</span><br><span class="line">LLVM version: 8.0</span><br></pre></td></tr></table></figure>

<p>这些输出来自一个x86_64上的Linux系统。我们看到<code>host</code>三元组是<code>x86_64-unknown-linux-gnu</code>，这包括了CPU架构(<code>x86_64</code>)，供应商(<code>unknown</code>)，操作系统<code>linux</code>和<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a>(<code>gnu</code>)。</p>
<p>为了以我们的宿主机三元组为目标编译程序，Rust编译器和链接器会假定存在默认情况下使用C运行时的底层操作系统（例如Linux或Windows），而这会导致链接器错误。因此，为避免链接器错误，我们可以针对没有基础操作系统的其他环境进行编译。</p>
<p>这种裸机环境的一个例子是<code>thumbv7em-none-eabihf</code>目标三元组，它描述了<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Embedded_system">嵌入式</a><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a>系统。细节并不重要，重要的是这个目标中的<code>none</code>表明该目标三元组也没有底层操作系统。为了能够为此目标进行编译，我们需要使用rustup添加这个目标所需文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup target add thumbv7em-none-eabihf</span><br></pre></td></tr></table></figure>

<p>这将下载系统的标准（和核心）库的。如此，我们可以为该目标构建独立可执行程序了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build --target thumbv7em-none-eabihf</span><br></pre></td></tr></table></figure>

<p>通过指定<code>--target</code>参数，我们<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cross_compiler">交叉编译</a>了裸机目标系统的可执行程序。由于目标系统并没有操作系统，因此链接程序不会尝试链接C运行时，也因此构建将没有任何链接程序错误，提示构建成功。</p>
<p>这便是我们即将用于OS内核构建的方法。这一次，我们将使用描述<code>x86_64</code>裸机环境的自定义目标三元组来代替<code>thumbv7em-none-eabihf</code>。我们将在下一篇文章中做出详细介绍。</p>
<h3 id="链接器参数"><a href="#链接器参数" class="headerlink" title="链接器参数"></a>链接器参数</h3><p>除了以裸机为目标进行编译之外，我们还可以通过将一组特定的参数传递给链接器来解决链接器错误。这不并是我们将用于内核编译的方法，因此本节是可选的，仅出于完整性考虑而提供。</p>
<p>在本小节中，我们讨论在Linux，Windows和macOS上发生的链接器错误，并说明如何通过将其他参数传递给链接器来解决这些错误。请注意，操作系统之间的可执行程序格式和链接器有所不同，因此每个系统都需要不同的参数集。</p>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>在Linux上，发生以下链接程序错误（部分）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error: linking with `cc` failed: <span class="built_in">exit</span> code: 1</span><br><span class="line">  |</span><br><span class="line">  = note: <span class="string">&quot;cc&quot;</span> […]</span><br><span class="line">  = note: /usr/lib/gcc/../x86_64-linux-gnu/Scrt1.o: In <span class="keyword">function</span> `_start<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">          (.text+0x12): undefined reference to `__libc_csu_fini&#x27;</span></span><br><span class="line">          /usr/lib/gcc/../x86_64-linux-gnu/Scrt1.o: In <span class="keyword">function</span> `_start<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">          (.text+0x19): undefined reference to `__libc_csu_init&#x27;</span></span><br><span class="line">          /usr/lib/gcc/../x86_64-linux-gnu/Scrt1.o: In <span class="keyword">function</span> `_start<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">          (.text+0x25): undefined reference to `__libc_start_main&#x27;</span></span><br><span class="line">          collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br></pre></td></tr></table></figure>

<p>其问题在于，链接器默认情况下引用C运行时的启动例程，也称为<code>_start</code>。这需要已经被<code>no_std</code>属性禁用的C标准库<code>libc</code>中的一些符号，因此链接器无法解析这些引用。为了解决这个问题，我们可以通过传递<code>-nostartfiles</code>参数来告诉链接器它不应链接C启动例程。</p>
<p>其中一种使用cargo向传递链接器参数的方法是<code>cargo rustc</code>命令。该命令的行为与<code>cargo build</code>相同，同时允许将选项传递给底层的Rust编译器<code>rustc</code>。<code>rustc</code>具有<code>-C link-arg</code>标志，该标志将参数传递给链接程序。综上，我们的新构建命令应为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo rustc -- -C link-arg=-nostartfiles</span><br></pre></td></tr></table></figure>

<p>如此，我们的crate便构建为Linux上的独立可执行程序了！</p>
<p>我们并不需要显式指定入口点函数的名称，因为链接器默认情况下就会查找名称为<code>_start</code>的函数。</p>
<h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>在Windows上，发生了另一个链接器错误（部分）：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">error: <span class="title">linking</span> <span class="title">with</span> `<span class="title">link.exe</span>` <span class="title">failed</span>: <span class="title">exit</span> <span class="title">code</span>: 1561</span></span><br><span class="line"><span class="function">  |</span></span><br><span class="line"><span class="function">  = <span class="title">note</span>: &quot;<span class="title">C</span>:\\<span class="title">Program</span> <span class="title">Files</span> (<span class="title">x86</span>)\\…\\<span class="title">link.exe</span>&quot; […]</span></span><br><span class="line"><span class="function">  = <span class="title">note</span>: <span class="title">LINK</span> : <span class="title">fatal</span> <span class="title">error</span> <span class="title">LNK1561</span>: <span class="title">entry</span> <span class="title">point</span> <span class="title">must</span> <span class="title">be</span> <span class="title">defined</span></span></span><br></pre></td></tr></table></figure>

<p>“entry point must be defined”的错误意味着链接器找不到入口点。在Windows上，默认入口点名称<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/build/reference/entry-entry-point-symbol">取决于所使用的子系统</a>。对于<code>CONSOLE</code>子系统，链接器将寻找一个名为<code>mainCRTStartup</code>的函数，对于<code>WINDOWS</code>子系统，它将寻找一个名为<code>WinMainCRTStartup</code>的函数。要覆盖默认值以告诉链接器应查找名为<code>_start</code>的函数，可以将<code>/ENTRY</code>参数传递给链接器：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo rustc -- -C link-arg=/ENTRY:_start</span><br></pre></td></tr></table></figure>

<p>从不同的参数格式中，我们可以清楚地看到Windows链接器是与Linux链接器完全不同的程序。</p>
<p>现在出现另一个链接器错误：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">error: <span class="title">linking</span> <span class="title">with</span> `<span class="title">link.exe</span>` <span class="title">failed</span>: <span class="title">exit</span> <span class="title">code</span>: 1221</span></span><br><span class="line"><span class="function">  |</span></span><br><span class="line"><span class="function">  = <span class="title">note</span>: &quot;<span class="title">C</span>:\\<span class="title">Program</span> <span class="title">Files</span> (<span class="title">x86</span>)\\…\\<span class="title">link.exe</span>&quot; […]</span></span><br><span class="line"><span class="function">  = <span class="title">note</span>: <span class="title">LINK</span> : <span class="title">fatal</span> <span class="title">error</span> <span class="title">LNK1221</span>: <span class="title">a</span> <span class="title">subsystem</span> <span class="title">can</span>&#x27;<span class="title">t</span> <span class="title">be</span> <span class="title">inferred</span> <span class="title">and</span> <span class="title">must</span> <span class="title">be</span></span></span><br><span class="line"><span class="function">          <span class="title">defined</span></span></span><br></pre></td></tr></table></figure>

<p>发生该错误的原因是Windows可执行程序可以使用不同的<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/build/reference/entry-entry-point-symbol">子系统</a>。对于普通程序，根据入口点名称进行推断：如果入口点名为<code>main</code>，则使用<code>CONSOLE</code>子系统；如果入口点名为<code>WinMain</code>，则使用<code>WINDOWS</code>子系统。 由于<code>_start</code>函数是另一个名称，因此我们需要显式指定子系统：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo rustc -- -C link-args=&quot;/ENTRY:_start /SUBSYSTEM:console&quot;</span><br></pre></td></tr></table></figure>

<p>我们在这里使用<code>CONSOLE</code>子系统，指定<code>WINDOWS</code>子系统也可以工作。与其多次传递<code>-C link-arg</code>，不如使用<code>-C link-args</code>，它使用空格分隔的参数列表。</p>
<p>使用这个命令，我们成功的在Windows上构建了可执行程序。</p>
<h4 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h4><p>在macOS上，发生以下链接器错误（部分）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error: linking with `cc` failed: <span class="built_in">exit</span> code: 1</span><br><span class="line">  |</span><br><span class="line">  = note: <span class="string">&quot;cc&quot;</span> […]</span><br><span class="line">  = note: ld: entry point (_main) undefined. <span class="keyword">for</span> architecture x86_64</span><br><span class="line">          clang: error: linker <span class="built_in">command</span> failed with <span class="built_in">exit</span> code 1 […]</span><br></pre></td></tr></table></figure>

<p>该错误消息告诉我们，链接器无法找到默认名称为<code>main</code>的入口点函数（由于某些原因，在macOS上所有函数均带有<code>_</code>前缀）。要将入口点设置为·函数，我们需要传递链接器参数<code>-e</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo rustc -- -C link-args=<span class="string">&quot;-e __start&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>-e</code>标志指定入口点函数的名称。由于所有函数在macOS上都有一个附加的<code>_</code>前缀，因此我们需要将入口点设置为<code>__start</code>而不是<code>_start</code>。</p>
<p>这次又出现以下链接器错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">error: linking with `cc` failed: <span class="built_in">exit</span> code: 1</span><br><span class="line">  |</span><br><span class="line">  = note: <span class="string">&quot;cc&quot;</span> […]</span><br><span class="line">  = note: ld: dynamic main executables must link with libSystem.dylib</span><br><span class="line">          <span class="keyword">for</span> architecture x86_64</span><br><span class="line">          clang: error: linker <span class="built_in">command</span> failed with <span class="built_in">exit</span> code 1 […]</span><br></pre></td></tr></table></figure>

<p>macOS并不<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/qa/qa1118/_index.html">正式支持静态链接的二进制文件</a>，并且默认情况下要求程序链接<code>libSystem</code>库。要覆盖它并链接静态二进制文件，我们将<code>-static</code>标志传递给链接器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo rustc -- -C link-args=<span class="string">&quot;-e __start -static&quot;</span></span><br></pre></td></tr></table></figure>

<p>这仍然不够，出现了第三个链接器错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error: linking with `cc` failed: <span class="built_in">exit</span> code: 1</span><br><span class="line">  |</span><br><span class="line">  = note: <span class="string">&quot;cc&quot;</span> […]</span><br><span class="line">  = note: ld: library not found <span class="keyword">for</span> -lcrt0.o</span><br><span class="line">          clang: error: linker <span class="built_in">command</span> failed with <span class="built_in">exit</span> code 1 […]</span><br></pre></td></tr></table></figure>

<p>该错误出现的原因是在默认情况下macOS上的程序链接到<code>crt0</code>(“C runtime zero”)。这类似于我们在Linux上遇到的错误，也可以通过添加<code>-nostartfiles</code>链接器参数来解决：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo rustc -- -C link-args=<span class="string">&quot;-e __start -static -nostartfiles&quot;</span></span><br></pre></td></tr></table></figure>

<p>现在我们的程序应该可以在macOS上成功构建了。</p>
<h4 id="统一构建命令"><a href="#统一构建命令" class="headerlink" title="统一构建命令"></a>统一构建命令</h4><p>现在，根据主机平台，我们有不同的构建命令，这并不方便。我们可以创建一个名为<code>.cargo/config.toml</code>的文件，用以包含针对不同平台的特定编译参数：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">in .cargo/config.toml</span><br><span class="line"></span><br><span class="line"><span class="section">[target.&#x27;cfg(target_os = &quot;linux&quot;)&#x27;]</span></span><br><span class="line"><span class="attr">rustflags</span> = [<span class="string">&quot;-C&quot;</span>, <span class="string">&quot;link-arg=-nostartfiles&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">[target.&#x27;cfg(target_os = &quot;windows&quot;)&#x27;]</span></span><br><span class="line"><span class="attr">rustflags</span> = [<span class="string">&quot;-C&quot;</span>, <span class="string">&quot;link-args=/ENTRY:_start /SUBSYSTEM:console&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">[target.&#x27;cfg(target_os = &quot;macos&quot;)&#x27;]</span></span><br><span class="line"><span class="attr">rustflags</span> = [<span class="string">&quot;-C&quot;</span>, <span class="string">&quot;link-args=-e __start -static -nostartfiles&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><code>rustflags</code>键包含的参数会自动添加到<code>rustc</code>的每次调用中。有关<code>.cargo/config.toml</code>文件的更多信息，请查看<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/cargo/reference/config.html">官方文档</a>。</p>
<p>现在，我们的程序应该可以在这三个平台上以简单的<code>cargo build</code>方式构建了。</p>
<h4 id="应该这要做吗"><a href="#应该这要做吗" class="headerlink" title="应该这要做吗"></a>应该这要做吗</h4><p>虽然可以为Linux、Windows和macOS构建独立的可执行程序，但这可能不是一个好主意。原因是我们的可执行程序仍然需要各种各样的东西，例如，在调用<code>_start</code>函数时初始化堆栈。没有C运行时，可能无法满足其中一些要求，这可能导致我们的程序出错，例如 通过分段故障。</p>
<p>如果要创建在现有操作系统（包括<code>libc</code>）之上运行的最小二进制文件，并按<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/1.16.0/book/no-stdlib.html">此处</a>所述设置<code>#[start]</code>属性，可能是一个更好的主意。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>一个最小的独立Rust二进制程序如下所示：</p>
<figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span> <span class="comment">// 不链接Rust标准库</span></span><br><span class="line"><span class="meta">#![no_main]</span> <span class="comment">// 禁用Rust层入口点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::panic::PanicInfo;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span> <span class="comment">// 该函数不进行名称重整</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>() -&gt; ! &#123;</span><br><span class="line">    <span class="comment">// 此函数为入口点，因为连接器将会查找默认叫做`_start`的函数</span></span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// This function is called on panic.</span></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">panic</span></span>(_info: &amp;PanicInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight toml"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;crate_name&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;Author Name &lt;author@example.com&gt;&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># the profile used for `cargo build`</span></span><br><span class="line"><span class="section">[profile.dev]</span></span><br><span class="line"><span class="attr">panic</span> = <span class="string">&quot;abort&quot;</span> <span class="comment"># disable stack unwinding on panic</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the profile used for `cargo build --release`</span></span><br><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">panic</span> = <span class="string">&quot;abort&quot;</span> <span class="comment"># disable stack unwinding on panic</span></span><br></pre></td></tr></table></figure>

<p>要构建此二进制程序，我们需要针对裸机目标进行编译，例如<code>thumbv7em-none-eabihf</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build --target thumbv7em-none-eabihf</span><br></pre></td></tr></table></figure>

<p>此外，我们也可以通过向链接器传递其他参数来为宿主机系统编译它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Linux</span></span><br><span class="line">cargo rustc -- -C link-arg=-nostartfiles</span><br><span class="line"><span class="comment"># Windows</span></span><br><span class="line">cargo rustc -- -C link-args=<span class="string">&quot;/ENTRY:_start /SUBSYSTEM:console&quot;</span></span><br><span class="line"><span class="comment"># macOS</span></span><br><span class="line">cargo rustc -- -C link-args=<span class="string">&quot;-e __start -static -nostartfiles&quot;</span></span><br></pre></td></tr></table></figure>

<p>请注意，这只是Rust独立二进制程序的最小示例。该二进制程序还需要更多操作，例如，在调用<code>_start</code>函数时初始化堆栈。因此，对于此类二进制程序的任何在实际场景中的使用，都需要继续添加更多的内容。</p>
<h2 id="下期预告"><a href="#下期预告" class="headerlink" title="下期预告"></a>下期预告</h2><p><a target="_blank" rel="noopener" href="https://os.phil-opp.com/minimal-rust-kernel/">下一篇文章</a>将介绍将我们的独立二进制程序转换为最小操作系统内核所需的步骤。其中包括创建自定义编译目标，将我们的可执行文件与bootloader结合以及学习如何在屏幕上打印内容。</p>
<h2 id="支持本项目"><a href="#支持本项目" class="headerlink" title="支持本项目"></a>支持本项目</h2><p>创建和<a target="_blank" rel="noopener" href="https://os.phil-opp.com/status-update/">维护</a>这个博客和相关库是一项繁重的工作，但我真的很喜欢。通过支持我，您可以让我在新内容、新功能和持续维护上投入更多时间。</p>
<p>支持我的最好方式是<a target="_blank" rel="noopener" href="https://github.com/sponsors/phil-opp">在GitHub上赞助我</a>，因为他们不收取任何中间费用。如果你喜欢其他平台，我也有<a target="_blank" rel="noopener" href="https://www.patreon.com/phil_opp">Patreon</a>和<a target="_blank" rel="noopener" href="https://donorbox.org/phil-opp">Donorbox</a>账户。后者是最灵活的，因为它支持多种货币和一次性捐款。</p>
<p>感谢您的支持！</p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Rust/">Rust</a><a class="link-muted mr-2" rel="tag" href="/tags/Operating-System/">Operating System</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatpay.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/02/21/writing-an-os-in-rust-1.2/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">使用Rust编写操作系统 - 1.2 - 最小化Rust内核</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/12/02/first-rust-code/"><span class="level-item">Rust尝鲜</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><script src="https://utteranc.es/client.js" repo="zlotus/comment" issue-term="pathname" label="some-issue-label" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/opm_sq.png" alt="子实"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">子实</p><p class="is-size-6 is-block">程序员</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>陕西/西安</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">79</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">23</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zlotus" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com/qinzishi"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/Zealot_uS"><i class="fab fa-twitter"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.zhihu.com/people/zlotus" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Diary/"><span class="level-start"><span class="level-item">Diary</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">65</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Shell/"><span class="level-start"><span class="level-item">Shell</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Coroutines/"><span class="tag">Coroutines</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">31</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenCV/"><span class="tag">OpenCV</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Operating-System/"><span class="tag">Operating System</span><span class="tag">21</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Paper/"><span class="tag">Paper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Raspberry-Pi/"><span class="tag">Raspberry Pi</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag">29</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TensorFlow/"><span class="tag">TensorFlow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tokio/"><span class="tag">Tokio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZMQ/"><span class="tag">ZMQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ctpn/"><span class="tag">ctpn</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/llama/"><span class="tag">llama</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macOS/"><span class="tag">macOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/obsidion/"><span class="tag">obsidion</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%A5%E8%AE%B0/"><span class="tag">日记</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E8%B0%88/"><span class="tag">杂谈</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B/"><span class="tag">编程</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%84%9A%E6%9C%AC/"><span class="tag">脚本</span><span class="tag">4</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a><p class="is-size-7"><span>&copy; 2024 子实</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>