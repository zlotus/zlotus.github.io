<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>使用Rust编写操作系统 - 1.2 - 最小化Rust内核 - 子实</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="子实"><meta name="msapplication-TileImage" content="/img/avatar-o.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="子实"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="使用Rust编写操作系统 - 1.2 - 最小化Rust内核"><meta property="og:type" content="article"><meta property="og:title" content="使用Rust编写操作系统 - 1.2 - 最小化Rust内核"><meta property="og:url" content="https://zlotus.github.io/2021/02/21/writing-an-os-in-rust-1.2/"><meta property="og:site_name" content="子实"><meta property="og:description" content="使用Rust编写操作系统 - 1.2 - 最小化Rust内核"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/6/6d/Codepage-737.png"><meta property="og:image" content="https://os.phil-opp.com/minimal-rust-kernel/qemu.png"><meta property="article:published_time" content="2021-02-21T09:41:00.000Z"><meta property="article:modified_time" content="2021-02-21T09:41:00.000Z"><meta property="article:author" content="子实"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Operating System"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://upload.wikimedia.org/wikipedia/commons/6/6d/Codepage-737.png"><meta property="twitter:creator" content="@Zealot_uS"><meta property="twitter:site" content="Zealot_uS"><link rel="publisher" href="+LotusQin"><meta property="fb:admins" content="qinzishi"><meta property="fb:app_id" content="qinzishi"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zlotus.github.io/2021/02/21/writing-an-os-in-rust-1.2/"},"headline":"使用Rust编写操作系统 - 1.2 - 最小化Rust内核","image":["https://upload.wikimedia.org/wikipedia/commons/6/6d/Codepage-737.png","https://os.phil-opp.com/minimal-rust-kernel/qemu.png"],"datePublished":"2021-02-21T09:41:00.000Z","dateModified":"2021-02-21T09:41:00.000Z","author":{"@type":"Person","name":"子实"},"publisher":{"@type":"Organization","name":"子实","logo":{"@type":"ImageObject","url":"https://zlotus.github.io/img/opm_sq.png"}},"description":"使用Rust编写操作系统 - 1.2 - 最小化Rust内核"}</script><link rel="icon" href="/img/avatar-o.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/2014/07/09/about-me/">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-21T09:41:00.000Z" title="2/21/2021, 5:41:00 PM">2021-02-21</time>发表</span><span class="level-item"><time dateTime="2021-02-21T09:41:00.000Z" title="2/21/2021, 5:41:00 PM">2021-02-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a></span><span class="level-item">1 小时读完 (大约8158个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">使用Rust编写操作系统 - 1.2 - 最小化Rust内核</h1><div class="content"><article class="message message-immersive is-warning">
<div class="message-body">
<i class="fas fa-exclamation-triangle mr-2"></i>本文所有内容均为翻译，原文：<a target="_blank" rel="noopener" href="https://os.phil-opp.com/minimal-rust-kernel/">A Minimal Rust Kernel</a>；原项目：<a target="_blank" rel="noopener" href="https://os.phil-opp.com/">Writing an OS in Rust</a>
</div>
</article>

<p>在这篇文章中，我们将为x86架构创建一个最小化的64位Rust内核。我们将在上一篇文章的<a target="_blank" rel="noopener" href="https://os.phil-opp.com/freestanding-rust-binary/">独立Rust二进制程序</a>基础上，创建一个可启动的磁盘映像，并在屏幕上打印一些东西。</p>
<span id="more"></span>

<p>这个博客是在<a target="_blank" rel="noopener" href="https://github.com/phil-opp/blog_os">GitHub</a>上公开开发的。如果你有任何问题或疑问，请在那里开一个issue。你也可以在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/minimal-rust-kernel/#comments">底部</a>留言。这篇文章的完整源代码可以在<a target="_blank" rel="noopener" href="https://github.com/phil-opp/blog_os/tree/post-02">post-02</a>分支中找到。</p>
<h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><p>当您打开计算机时，它开始执行存储在主板<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Read-only_memory">ROM</a>中的固件代码。这段代码会执行<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Power-on_self-test">开机自检</a>，检测可用的RAM，并对CPU和硬件进行预初始化。之后，它寻找一个可启动的磁盘，并开始启动操作系统内核。</p>
<p>在x86上，有两种固件标准：”基本输入/输出系统”（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/BIOS">BIOS</a>）和较新的 “统一可扩展固件接口”（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface">UEFI</a>）。BIOS标准虽然老旧过时，却较为简单，而且自20世纪80年代以来在任何x86机器上都得到了良好的支持。相比之下，UEFI更现代，功能更多，但设置起来更复杂（至少在我看来）。</p>
<p>目前，我们只提供BIOS支持，但对UEFI的支持也在计划之中。如果你愿意帮助我们，请查看<a target="_blank" rel="noopener" href="https://github.com/phil-opp/blog_os/issues/349">Github issue</a>。</p>
<h3 id="BIOS启动"><a href="#BIOS启动" class="headerlink" title="BIOS启动"></a>BIOS启动</h3><p>几乎所有的x86系统都支持BIOS启动，包括使用模拟BIOS的较新的基于UEFI的机器。这是很好的，因为你可以在上世纪的所有机器上使用相同的启动逻辑。但这种广泛的兼容性同时也是BIOS启动的最大缺点，因为这意味着CPU在启动前会被放入一个叫做<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Real_mode">实模式</a>的16位兼容模式，这样上世纪80年代的老式引导程序仍然可以使用。</p>
<p>让我们从头说起。</p>
<p>当你打开电脑时，它会从位于主板上的一些特殊闪存中加载BIOS。BIOS会运行硬件的自我测试和初始化例程，然后寻找可启动磁盘。如果它找到了一个，控制权就会转移到它的bootloader，这是存储在磁盘开头的512字节的可执行代码部分。大多数的引导加载器都大于512字节，所以引导加载器通常被分成一个小的第一阶段引导程序——刚好512字节——和一个第二阶段引导程序——在第一阶段引导程序之后加载。</p>
<p>引导程序必须确定内核映像在磁盘上的位置，并将其加载到内存中。它还需要先将CPU从16位的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Real_mode">实模式</a>切换到32位的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Protected_mode">保护模式</a>，然后再切换到64位的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Long_mode">长模式</a>，在长模式下可以使用64位寄存器和完整的主内存。它的j第三项工作是从BIOS中查询某些信息（如内存映射），并将其传递给操作系统内核。</p>
<p>编写一个bootloader是有点麻烦的，因为它需要汇编语言和很多非深入的步骤，比如 “把这个魔数值写入这个处理器寄存器”。因此，我们在这篇文章中不涉及bootloader的创建，而是提供了一个名为<a target="_blank" rel="noopener" href="https://github.com/rust-osdev/bootimage">bootimage</a>的工具，它可以自动将bootloader预置到你的内核中。</p>
<p>如果你对构建自己的bootloader感兴趣。请持续关注，一系列关于这个主题的文章已经在计划中了！</p>
<h3 id="Multiboot标准"><a href="#Multiboot标准" class="headerlink" title="Multiboot标准"></a>Multiboot标准</h3><p>为了避免每个操作系统都实现自己的bootloader，而bootloader只能与单一操作系统兼容，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Free_Software_Foundation">自由软件基金会</a>在1995年创建了一个名为<a target="_blank" rel="noopener" href="https://wiki.osdev.org/Multiboot">Multiboot</a>的开放bootloader标准。该标准定义了引导加载器和操作系统之间的接口，因此任何符合Multiboot标准的引导加载器都可以加载任何符合Multiboot标准的操作系统。参考实现是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/GNU_GRUB">GNU GRUB</a>，它是Linux系统中最流行的引导加载器。</p>
<p>要使内核符合Multiboot的要求，只需要在内核文件的开头插入一个所谓的<a target="_blank" rel="noopener" href="https://www.gnu.org/software/grub/manual/multiboot/multiboot.html#OS-image-format">Multiboot头</a>。这使得在GRUB中启动一个操作系统变得非常容易。然而，GRUB和Multiboot标准也有一些问题：</p>
<ul>
<li>只支持32位保护模式。这意味着你仍然必须进行CPU配置才能切换到64位长模式。</li>
<li>其设计是为了简化bootloader，而不是简化内核。例如，内核需要链接一个调整后的<a target="_blank" rel="noopener" href="https://wiki.osdev.org/Multiboot#Multiboot_2">默认页长度</a>，否则GRUB会找不到Multiboot头。另一个例子是，传递给内核的<a target="_blank" rel="noopener" href="https://www.gnu.org/software/grub/manual/multiboot/multiboot.html#Boot-information-format">引导信息</a>，包含了很多依赖于架构的结构，而不是提供清晰的抽象。</li>
<li>GRUB和Multiboot标准的文档支持较少。</li>
<li>GRUB需要安装在主机系统上才能从内核文件中创建一个可启动的磁盘镜像。这使得在Windows或Mac上的开发更加困难。</li>
</ul>
<p>鉴于此，我们决定不使用GRUB或Multiboot标准。然而，我们计划在我们的<a target="_blank" rel="noopener" href="https://github.com/rust-osdev/bootimage">bootimage</a>工具中加入对Multiboot的支持，这样就可以在GRUB系统上加载你的内核。如果你对编写一个符合Multiboot标准的内核感兴趣，请查看本系列博客的<a target="_blank" rel="noopener" href="https://os.phil-opp.com/edition-1/">第一版</a>。</p>
<h3 id="UEFI"><a href="#UEFI" class="headerlink" title="UEFI"></a>UEFI</h3><p>(我们目前不提供UEFI支持，但我们很乐意! 如果你愿意帮忙，请在<a target="_blank" rel="noopener" href="https://github.com/phil-opp/blog_os/issues/349">Github issue</a>中告诉我们。)</p>
<h2 id="最小化内核"><a href="#最小化内核" class="headerlink" title="最小化内核"></a>最小化内核</h2><p>现在我们已经大致知道了计算机是如何启动的，现在是时候创建我们自己的最小内核了。我们的目标是创建一个磁盘映像，在启动时向屏幕打印 “Hello World!”。为此，我们在上一篇文章中的<a target="_blank" rel="noopener" href="https://os.phil-opp.com/freestanding-rust-binary/">独立Rust二进制程序</a>基础上进行开发。</p>
<p>你可能还记得，我们通过<code>cargo</code>构建了独立的二进制文件，但根据不同的操作系统，我们需要不同的入口点名称和编译标识。这是因为<code>cargo</code>默认是为主机系统编译，也就是你正在运行的系统。这并不是我们想要的内核，因为一个运行在Windows之上的内核并没有什么意义。相反，我们希望为一个明确定义的目标系统编译。</p>
<h2 id="安装Rust-Nightly"><a href="#安装Rust-Nightly" class="headerlink" title="安装Rust Nightly"></a>安装Rust Nightly</h2><p>Rust有三个发布频道：稳定版、测试版和nightly版。Rust Book很好地解释了这些<a href="(https://doc.rust-lang.org/book/appendix-07-nightly-rust.html#choo-choo-release-channels-and-riding-the-trains)">频道之间的区别</a>，所以花点时间看看吧。为了构建一个操作系统，我们需要一些实验性的功能，而这些功能只有在nightly频道上才有，所以我们需要安装一个nightly版本的Rust。</p>
<p>要管理Rust的安装，我强烈推荐<a target="_blank" rel="noopener" href="https://www.rustup.rs/">rustup</a>。它允许你并排安装nightly、测试版和稳定版编译器，并使其易于更新。使用rustup，你可以通过运行<code>rustup override set nightly</code>为当前目录使用夜间编译器。或者，你也可以在项目的根目录下添加一个名为<code>rust-toolchain</code>的文件，其内容为<code>nightly</code>。你可以通过运行<code>rustc --version</code>来检查你是否安装了nightly版本。版本号的末尾应该包含<code>-nightly</code>。</p>
<p>nightly编译器允许我们通过在文件顶部使用所谓的特征标识来选择加入各种实验性特征。例如，我们可以通过在<code>main.rs</code>的顶部添加<code>#！[feature(asm)]</code>来启用内联汇编的实验性<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/unstable-book/library-features/asm.html">asm!宏</a>。请注意，这种实验性的特性是完全不稳定的，这意味着未来的Rust版本可能会在没有事先警告的情况下更改或删除它们。因此，我们只有在绝对必要的情况下才会使用它们。</p>
<h3 id="目标配置清单"><a href="#目标配置清单" class="headerlink" title="目标配置清单"></a>目标配置清单</h3><p><code>cargo</code>通过<code>--target</code>参数支持不同的目标系统。目标由所谓的<a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/CrossCompilation.html#target-triple">目标系统三元组</a>描述，它描述了CPU架构、厂商、操作系统和<a target="_blank" rel="noopener" href="https://stackoverflow.com/a/2456882">ABI</a>。例如，<code>x86_64-unknown-linux-gnu</code>目标三元组描述了一个具有<code>x86_64</code> CPU、没有明确的供应商、且具有GNU ABI的Linux操作系统的目标系统。Rust支持许多不同的<a target="_blank" rel="noopener" href="https://forge.rust-lang.org/release/platform-support.html">目标三元组</a>，包括Android的<code>arm-linux-androideabi</code>或<a target="_blank" rel="noopener" href="https://www.hellorust.com/setup/wasm-target/">WebAssembly的wasm32-unknown-unknown</a>。</p>
<p>然而，对于我们的目标系统，我们需要一些特殊的配置参数（比如没有底层操作系统），所以<a target="_blank" rel="noopener" href="https://forge.rust-lang.org/release/platform-support.html">现有的目标三元组</a>都不适合。幸运的是，Rust允许我们通过JSON文件来<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/rustc/targets/custom.html">定义自己的目标三元组</a>。例如，一个描述<code>x86_64-unknown-linux-gnu</code>目标的JSON文件是大概这样的：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;llvm-target&quot;</span>: <span class="string">&quot;x86_64-unknown-linux-gnu&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;data-layout&quot;</span>: <span class="string">&quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;arch&quot;</span>: <span class="string">&quot;x86_64&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;target-endian&quot;</span>: <span class="string">&quot;little&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;target-pointer-width&quot;</span>: <span class="string">&quot;64&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;target-c-int-width&quot;</span>: <span class="string">&quot;32&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;os&quot;</span>: <span class="string">&quot;linux&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;executables&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;linker-flavor&quot;</span>: <span class="string">&quot;gcc&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;pre-link-args&quot;</span>: [<span class="string">&quot;-m64&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;morestack&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大多数字段是LLVM为该平台生成代码所需要的。例如，<a target="_blank" rel="noopener" href="https://llvm.org/docs/LangRef.html#data-layout">data-layout</a>字段定义了各种整数、浮点和指针类型的大小。还有一些Rust用于条件编译的字段，比如<code>target-pointer-width</code>。第三种字段定义了应该如何构建crate。例如，<code>pre-link-args</code>字段指定了传递给<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Linker_(computing)">链接器</a>的参数。</p>
<p>我们的内核也是以<code>x86_64</code>系统为目标的，所以我们的目标描述文件看起来会和上面的很相似。让我们先创建一个<code>x86_64-blog_os.json</code>文件(选择任何你喜欢的名字)，里面有通用的内容有：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;llvm-target&quot;</span>: <span class="string">&quot;x86_64-unknown-none&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;data-layout&quot;</span>: <span class="string">&quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;arch&quot;</span>: <span class="string">&quot;x86_64&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;target-endian&quot;</span>: <span class="string">&quot;little&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;target-pointer-width&quot;</span>: <span class="string">&quot;64&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;target-c-int-width&quot;</span>: <span class="string">&quot;32&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;os&quot;</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;executables&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，我们将<code>llvm-target</code>中的系统以及<code>os</code>字段中的系统均改为<code>none</code>，因为我们将在裸机上运行。</p>
<p>我们增加以下与build有关的配置项：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;linker-flavor&quot;</span>: <span class="string">&quot;ld.lld&quot;</span>,</span><br><span class="line"><span class="string">&quot;linker&quot;</span>: <span class="string">&quot;rust-lld&quot;</span>,</span><br></pre></td></tr></table></figure>

<p>我们不使用平台的默认链接器（可能不支持Linux目标系统），而是使用Rust自带的跨平台<a target="_blank" rel="noopener" href="https://lld.llvm.org/">LLD</a>链接器来链接我们的内核。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;panic-strategy&quot;</span>: <span class="string">&quot;abort&quot;</span>,</span><br></pre></td></tr></table></figure>

<p>这个设置指定了目标不支持在panic时进行<a target="_blank" rel="noopener" href="https://www.bogotobogo.com/cplusplus/stackunwinding.php">栈展开</a>，因此程序遇到问题时将直接终止。这和我们Cargo.toml中的<code>panic = &quot;abort&quot;</code>选项一样，所以我们可以从那里删除它。(请注意，与Cargo.toml选项不同的是，这个目标选项在我们后面重新编译<code>core</code>库时通用需要。因此，即使你喜欢保留Cargo.toml里的选项，也一定要添加这个选项。)</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;disable-redzone&quot;</span>: <span class="literal">true</span>,</span><br></pre></td></tr></table></figure>

<p>我们正在编写一个内核，所以我们需要在某些时候处理中断。为了安全起见，我们必须禁用一个叫做“红区”的堆栈指针优化，因为如果不这样做，可能会导致堆栈数据被破坏。更多的信息，请看我们单独的关于<a target="_blank" rel="noopener" href="https://os.phil-opp.com/red-zone/">禁用红区</a>的文章。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;features&quot;</span>: <span class="string">&quot;-mmx,-sse,+soft-float&quot;</span>,</span><br></pre></td></tr></table></figure>

<p><code>fatures</code>字段启用/禁用目标的CPU指令特性。我们在<code>mmx</code>和<code>sse</code>特性前使用减号来禁用它们，在<code>soft-float</code>特性前加加号来启用它。注意不同标志之间不能有空格，否则LLVM无法解释特性字符串。</p>
<p><code>mmx</code>和<code>sse</code>特性决定了对<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SIMD">单指令多数据(SIMD)</a>指令的支持，这通常可以大大提升程序的速度。然而，在操作系统内核中使用大型SIMD寄存器会导致性能问题。原因是内核需要在继续中断的程序之前将所有寄存器恢复到原来的状态。这意味着内核必须在每次系统调用或硬件中断时将完整的SIMD状态保存到主存中。由于SIMD状态非常大（512-1600字节），而且中断可能会非常频繁地发生，这些额外的保存/恢复操作会大大降低性能。为了避免这种情况，我们禁用了内核的SIMD（并不是禁用运行在其上的应用程序的SIMD特性！）。</p>
<p>禁用SIMD的一个问题是，<code>x86_64</code>上的浮点运算默认需要SIMD寄存器。为了解决这个问题，我们增加了<code>soft-float</code>特性，通过基于普通整数的软件函数来模拟所有的浮点运算。</p>
<p>我们撰写了一篇关于<a target="_blank" rel="noopener" href="https://os.phil-opp.com/disable-simd/">禁用SIMD</a>的短文，以供读者深入了解相关信息。</p>
<h4 id="放在一起"><a href="#放在一起" class="headerlink" title="放在一起"></a>放在一起</h4><p>现在，我们的目标系统描述文件现在看起来是这样的：</p>
<figure class="highlight json"><figcaption><span>x86_64-blog_os.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;llvm-target&quot;</span>: <span class="string">&quot;x86_64-unknown-none&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;data-layout&quot;</span>: <span class="string">&quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;arch&quot;</span>: <span class="string">&quot;x86_64&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;target-endian&quot;</span>: <span class="string">&quot;little&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;target-pointer-width&quot;</span>: <span class="string">&quot;64&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;target-c-int-width&quot;</span>: <span class="string">&quot;32&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;os&quot;</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;executables&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;linker-flavor&quot;</span>: <span class="string">&quot;ld.lld&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;linker&quot;</span>: <span class="string">&quot;rust-lld&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;panic-strategy&quot;</span>: <span class="string">&quot;abort&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;disable-redzone&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;features&quot;</span>: <span class="string">&quot;-mmx,-sse,+soft-float&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h3><p>编译我们的新目标系统将使用Linux惯例（我不太确定为什么，我猜这只是LLVM默认如此）。这意味着我们需要一个名为<code>_start</code>的入口点，就像<a target="_blank" rel="noopener" href="https://os.phil-opp.com/freestanding-rust-binary/">上一篇</a>文章中描述的那样。</p>
<figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span> <span class="comment">// 不链接Rust标准库</span></span><br><span class="line"><span class="meta">#![no_main]</span> <span class="comment">// 禁用所有Rust层级的入口点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::panic::PanicInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 这个函数将在panic时被调用</span></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">panic</span></span>(_info: &amp;PanicInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span> <span class="comment">// 不重整函数名</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>() -&gt; ! &#123;</span><br><span class="line">    <span class="comment">// 因为编译器会寻找一个名为`_start`的函数，所以这个函数就是入口点</span></span><br><span class="line">    <span class="comment">// 默认命名为`_start`</span></span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，无论你的主机操作系统如何，这个入口点都需应命名为<code>_start</code>。</p>
<p>现在，我们可以给<code>--target</code>参数传入JSON描述文件来为我们的新目标系统构建内核。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; cargo build --target x86_64-blog_os.json</span><br><span class="line"></span><br><span class="line">error[E0463]: can&#x27;t find crate for `core`</span><br></pre></td></tr></table></figure>

<p>编译失败了! 这个错误告诉我们，Rust编译器已经找不到<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/core/index.html"><code>core</code>库</a>了。这个库包含Rust基本类型，如<code>Result</code>、<code>Option</code>、迭代器等，并且隐式地链接到所有<code>no_std</code>crates。</p>
<p>这个问题在于，core库是作为预编译库与Rust编译器一起发布的。因此，它只支持预定义的几个目标系统三元组(如<code>x86_64-unknown-linux-gnu</code>)，而不支持我们自定义的目标三元组。如果我们想为其他目标编译代码，我们需要先为这些目标重新编译<code>core</code>库。</p>
<h3 id="build-std选项"><a href="#build-std选项" class="headerlink" title="build-std选项"></a><code>build-std</code>选项</h3><p>这就是cargo的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-std"><code>build-std</code></a>选项的作用：它允许按需重新编译<code>core</code>和其他标准库crate，而不是使用Rust安装时附带的预编译版本。这个功能是非常新的，还没有完成，所以它被标记为”unstable”，只在nightly的Rust编译器上可用。</p>
<p>为了使用该特性，我们需要在项目跟目录下新建<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/cargo/reference/config.html">cargo配置文件</a><code>.cargo/config.toml</code>，加入内容如下：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[unstable]</span></span><br><span class="line"><span class="attr">build-std</span> = [<span class="string">&quot;core&quot;</span>, <span class="string">&quot;compiler_builtins&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>该配置项告诉cargo需要重新编译<code>core</code>和<code>compiler_builtins</code>库，其中<code>compiler_builtins</code>库是编译<code>core</code>库的一个依赖。为了编译这些库，cargo需要读取rust源码，可以通过<code>rustup component add rust-src</code>安装源码组件。</p>
<article class="message is-success"><div class="message-header">
<p>注意</p>
</div><div class="message-body">
<p><code>unstable.build-std</code>配置项仅在2020-07-15之后的Rust nightly中提供</p>
</div></article>

<p>设置好<code>unstable.build-std</code>配置项并安装<code>rust-src</code>源码组件后，就可以重新运行我们的编译命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; cargo build --target x86_64-blog_os.json</span><br><span class="line">   Compiling core v0.0.0 (/…/rust/src/libcore)</span><br><span class="line">   Compiling rustc-std-workspace-core v1.99.0 (/…/rust/src/tools/rustc-std-workspace-core)</span><br><span class="line">   Compiling compiler_builtins v0.1.32</span><br><span class="line">   Compiling blog_os v0.1.0 (/…/blog_os)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.29 secs</span><br></pre></td></tr></table></figure>

<p>我们看到<code>cargo build</code>现在为我们的自定义目标重新编译了<code>core</code>、<code>rustc-std-workspace-core</code>(此为<code>compiler_builtins</code>的依赖)和<code>compiler_builtins</code>库。</p>
<h3 id="内存相关的内联函数"><a href="#内存相关的内联函数" class="headerlink" title="内存相关的内联函数"></a>内存相关的内联函数</h3><p>Rust编译器假设，在所有的操作系统中，均提供一组内置函数。其中的大多数函数由我们刚才编译的<code>compiler_builtins</code>crate提供。不过，该crate中有一些内存相关的函数，通常由操作系统的C语言库提供，所以默认为不启用。这些函数包括用以将一个内存块中的所有字节设置为一个给定值的<code>memset</code>，用以将一个内存块复制到另一个内存块的<code>memcpy</code>，以及用来比较两个内存块的<code>memcmp</code>。虽然现在编译我们的内核的时候并不需要这些函数，但是当我们添加更多的代码时（例如在复制结构体的时候），就会用到这些函数。</p>
<p>由于我们无法链接到操作系统的C语言库，所以我们需要另一种方式来向编译器提供这些函数。一个可能的方法是实现我们自己的<code>memset</code>等一系列函数，并为它们添加#[no_mangle]标识（用以避免编译过程中的自动重命名）。不过这相当危险，因为在实现这些函数的过程中稍有差错就会导致程序不可预料的行为。例如，当你使用<code>for</code>循环实现<code>memcpy</code>时，你可能会得到一个无限递归，因为<code>for</code>循环隐式地调用<code>IntoIterator::into_iter</code>trait方法，这可能会再次调用<code>memcpy</code>。所以，重用现有的经过良好测试的实现是个好主意。</p>
<p>幸运的是，<code>compiler_builtins</code>crate已经包含了所有需要的函数的实现，只是为了不与C语言库中的实现相冲突，它们被默认为禁用了。我们可以通过设置 cargo的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-std-features"><code>build-std-features</code></a>标识为<code>[&quot;compiler-builtins-mem&quot;]</code>来启用它们。与<code>build-std</code>标识一样，这个标识可以在命令行中以<code>-Z</code>标志的形式传递，也可以在<code>.cargo/config.toml</code>文件中的”unstable”域中配置。由于我们总是希望用这个标识来构建，所以配置文件选项对我们来说会更方便：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[unstable]</span></span><br><span class="line"><span class="attr">build-std-features</span> = [<span class="string">&quot;compiler-builtins-mem&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>（<code>compiler-builtins-mem</code>特性是<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/pull/77284">最近</a>才添加的，因此需要<code>2020-09-30</code>后的Rust nightly版本。）</p>
<p>在幕后，这个标志启用了<code>compiler_builtins</code>crate的<a target="_blank" rel="noopener" href="https://github.com/rust-lang/compiler-builtins/blob/eff506cd49b637f1ab5931625a33cef7e91fbbf6/Cargo.toml#L54-L55"><code>mem</code>功能</a>。这样做的效果是，<code>#[no_mangle]</code>属性被应用到crate的<a target="_blank" rel="noopener" href="https://github.com/rust-lang/compiler-builtins/blob/eff506cd49b637f1ab5931625a33cef7e91fbbf6/src/mem.rs#L12-L69"><code>memcpy</code>等实现</a>中，使得它们可以被链接器使用。</p>
<p>如此，对编译器要求的所有函数，我们的内核都有了有效的实现，之后即使我们的代码变得更复杂，它也能够通过编译。</p>
<h3 id="设置默认目标"><a href="#设置默认目标" class="headerlink" title="设置默认目标"></a>设置默认目标</h3><p>为了避免每次使用<code>cargo xbuild</code>时传递<code>--target</code>参数，我们可以覆写默认的编译目标。继续向<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/cargo/reference/config.html">cargo配置文件</a><code>.cargo/config.toml</code>添加以下内容：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[build]</span></span><br><span class="line"><span class="attr">target</span> = <span class="string">&quot;x86_64-blog_os.json&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里的配置告诉<code>cargo</code>在没有显式声明目标的情况下，使用我们提供的<code>x86_64-blog_os.json</code>作为目标配置。这意味着我们可以直接使用<code>cargo build</code>进行构建。更多关于cargo配置选项的信息，请查看<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/cargo/reference/config.html">官方文档</a>。</p>
<p>现在我们可以用一个简单的<code>cargo build</code>构建裸金属上的内核了。然而，我们的<code>_start</code>入口点仍然是空的，它将被bootloader调用。是时候输出一些东西到屏幕上了。</p>
<h3 id="在屏幕上打印字符"><a href="#在屏幕上打印字符" class="headerlink" title="在屏幕上打印字符"></a>在屏幕上打印字符</h3><p>现阶段将文字打印到屏幕上最简单的方法是使用<a href="(https://en.wikipedia.org/wiki/VGA-compatible_text_mode)">VGA文字缓冲区</a>。它是一个包含屏幕上显示的内容的特殊的内存区域，直接映射到VGA硬件。它通常由25行组成，每行包含80个字符单元。每个字符单元显示一个ASCII字符，并带有一些前景和背景颜色。屏幕输出的内容是这样的。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/6/6d/Codepage-737.png" alt="字符"></p>
<p>我们将在下一篇文章中讨论VGA缓冲区的详情，届时将为它编写第一个小型驱动程序。我们目前仅仅是打印”Hello World!”，只需要知道缓冲区位于地址<code>0xb8000</code>，每个字符单元由一个ASCII字节和一个颜色字节组成。</p>
<p>我们的实现就像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> HELLO: &amp;[<span class="built_in">u8</span>] = <span class="string">b&quot;Hello World!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>() -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">let</span> vga_buffer = <span class="number">0xb8000</span> <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;byte) <span class="keyword">in</span> HELLO.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            *vga_buffer.offset(i <span class="keyword">as</span> <span class="built_in">isize</span> * <span class="number">2</span>) = byte;</span><br><span class="line">            *vga_buffer.offset(i <span class="keyword">as</span> <span class="built_in">isize</span> * <span class="number">2</span> + <span class="number">1</span>) = <span class="number">0xb</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们将整数<code>0xb8000</code>转成一个<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer">裸指针</a>。然后，我们对<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#the-static-lifetime">静态</a>HELLO<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/reference/tokens.html#byte-string-literals">字节字符串</a>的字节进行<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/book/ch13-02-iterators.html">迭代</a>。我们使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.enumerate"><code>enumerate</code></a>方法额外获得迭代索引<code>i</code>，在<code>for</code>循环中，我们使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.pointer.html#method.offset"><code>offset</code></a>方法写入字符串字节和相应的颜色字节（<code>0xb</code>为淡青色）。</p>
<p>请注意，所有的内存写入操作均放置于<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/book/ch19-01-unsafe-rust.html"><code>unsafe</code></a>块中。原因是Rust编译器无法推断出我们创建的裸指针是有效的。它们可能指向任何地方并导致数据损坏。通过将它们放入<code>unsafe</code>块，我们基本上是在告诉编译器，我们绝对确信这些操作是有效的。请注意，<code>unsafe</code>块并不会关闭Rust的安全检查。它只允许您做<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/book/ch19-01-unsafe-rust.html#unsafe-superpowers">五件额外的事情</a>。</p>
<p>我想强调的是，这不是我们想在Rust中做的事情！在不安全的块内处理裸指针时，很容易出乱子，例如，如果我们不小心，很容易写到缓冲区的末端。</p>
<p>所以我们要尽可能的减少<code>unsafe</code>块的使用。Rust通过创建安全抽象给我们提供了这样的能力。例如，我们可以创建一个VGA缓冲类型，封装所有的不安全操作，并确保不可能从外部进行任何错误调用。这样一来，我们就只需要最少的<code>unsafe</code>块，并且可以确保不违反<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memory_safety">内存安全</a>。我们将在下一篇文章中创建这样一个安全的VGA缓冲区抽象。</p>
<h2 id="启动内核"><a href="#启动内核" class="headerlink" title="启动内核"></a>启动内核</h2><p>现在我们已经有了一个可执行文件，并且可以进行一些可见的操作，是时候运行它了。首先，我们需要将我们编译好的内核通过与bootloader连接，变成一个可引导的磁盘镜像。然后，我们可以在<a target="_blank" rel="noopener" href="https://www.qemu.org/">QEMU</a>虚拟机中运行磁盘镜像，或者用U盘在真实的硬件上引导它。</p>
<h3 id="创建引导镜像"><a href="#创建引导镜像" class="headerlink" title="创建引导镜像"></a>创建引导镜像</h3><p>为了把编译后的内核变成一个可启动的磁盘镜像，我们需要把它和引导程序连接起来。正如我们在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/minimal-rust-kernel/#the-boot-process">启动过程</a>一节中所学到的，引导程序负责初始化CPU和加载内核。</p>
<p>我们不需要编写自己的bootloader，这是一个独立的项目，我们使用<a target="_blank" rel="noopener" href="https://crates.io/crates/bootloader">bootloader</a> crate。这个crate实现了一个基本的BIOS引导加载器，没有任何C语言的依赖，只有Rust和内联汇编。为了使用它来启动我们的内核，我们需要添加一个依赖。</p>
<figure class="highlight toml"><figcaption><span>in Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">bootloader</span> = <span class="string">&quot;0.9.8&quot;</span></span><br></pre></td></tr></table></figure>

<p>添加bootloader作为依赖，并不足以真正创建一个可启动的磁盘镜像。其中的问题是，我们需要在编译后将内核与bootloader链接起来，但cargo不支持<a target="_blank" rel="noopener" href="https://github.com/rust-lang/cargo/issues/545">post-build脚本</a>。</p>
<p>为了解决这个问题，我们创建了一个名为<code>bootimage</code>的工具，它首先编译内核和bootloader，然后将它们连接在一起，创建一个可启动的磁盘镜像。要安装这个工具，请在你的终端上执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo install bootimage</span><br></pre></td></tr></table></figure>

<p>为了运行<code>bootimage</code>和构建bootloader，你需要安装<code>llvm-tools-preview</code> rustup组件。你可以通过执行<code>rustup component add llvm-tools-preview</code>来安装。</p>
<p>安装<code>bootimage</code>并添加<code>llvm-tools-preview</code>组件后，我们可以创建可启动磁盘镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; cargo bootimage</span><br></pre></td></tr></table></figure>

<p>我们看到该工具使用<code>cargo build</code>重新编译我们的内核，所以它会自动获取你所做的任何更改。之后，它会编译bootloader，这可能需要一段时间。像所有的crate依赖一样，它只编译一次，然后进行缓存，所以后续的编译速度会快很多。最后，bootimage将bootloader和你的内核结合成一个可启动的磁盘镜像。</p>
<p>执行该命令后，你应该会在<code>target/x86_64-blog_os/debug</code>目录下看到一个名为<code>bootimage-blog_os.bin</code>的可启动磁盘镜像。你可以在虚拟机中启动它，或者将它复制到USB驱动器中，在真正的硬件上启动它。(注意，这不是CD镜像，因为CD镜像有不同的格式，所以刻录到CD上是不行的)。</p>
<h3 id="它是如何工作的？"><a href="#它是如何工作的？" class="headerlink" title="它是如何工作的？"></a>它是如何工作的？</h3><p><code>bootimage</code>工具在后台执行以下步骤：</p>
<ul>
<li>它将我们的内核编译成<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF</a>文件。</li>
<li>它将bootloader的依赖性编译成一个独立的可执行文件。</li>
<li>它将内核ELF文件按字节链接到bootloader末尾。</li>
</ul>
<p>当启动时，bootloader读取并解析附加的ELF文件。然后，它将程序段映射到页表中的虚拟地址，将<code>.bss</code>部分归零，并建立一个堆栈。最后，它读取入口点地址（我们的<code>_start</code>函数）并跳转到它。</p>
<h3 id="在QEMU中启动内核"><a href="#在QEMU中启动内核" class="headerlink" title="在QEMU中启动内核"></a>在QEMU中启动内核</h3><p>现在我们可以在虚拟机中启动内核了。为了在<a target="_blank" rel="noopener" href="https://www.qemu.org/">QEMU</a>中启动内核，我们使用下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; qemu-system-x86_64 -drive format=raw,file=target/x86_64-blog_os/debug/bootimage-blog_os.bin</span><br><span class="line">warning: TCG doesn<span class="string">&#x27;t support requested feature: CPUID.01H:ECX.vmx [bit 5]</span></span><br></pre></td></tr></table></figure>

<p>这将打开一个单独的窗口与，看起来像这样：</p>
<p><img src="https://os.phil-opp.com/minimal-rust-kernel/qemu.png" alt="qemu的显示内容"></p>
<p>我们看到屏幕上可以看到的”Hello World!”。</p>
<h3 id="在物理机器上运行内核"><a href="#在物理机器上运行内核" class="headerlink" title="在物理机器上运行内核"></a>在物理机器上运行内核</h3><p>也可以将其写入U盘，在物理机器上启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; dd <span class="keyword">if</span>=target/x86_64-blog_os/debug/bootimage-blog_os.bin of=/dev/sdX &amp;&amp; sync</span><br></pre></td></tr></table></figure>

<p>其中<code>sdX</code>是你的U盘的设备名。<strong>请注意</strong>选择正确的设备名称，因为该设备上的所有内容都会被覆盖。</p>
<p>将镜像写入U盘后，就可以通过从U盘启动，并在物理硬件上运行它。你可能需要指定启动项或改变BIOS配置中的启动顺序来从U盘启动。需要注意的是，目前它还不能用于UEFI机器，因为bootloader crate还不支持UEFI。</p>
<h3 id="使用cargo-run"><a href="#使用cargo-run" class="headerlink" title="使用cargo run"></a>使用<code>cargo run</code></h3><p>为了方便在QEMU中运行我们的内核，可以设置cargo的<code>runner</code>配置键。</p>
<p>要让在QEMU中运行内核更轻松，我们可以设置在cargo配置文件中设置<code>runner</code>配置项：</p>
<figure class="highlight toml"><figcaption><span>in .cargo/config.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[target.&#x27;cfg(target_os = &quot;none&quot;)&#x27;]</span></span><br><span class="line"><span class="attr">runner</span> = <span class="string">&quot;bootimage runner&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>target.&#39;cfg(target_os = &quot;none&quot;)&#39;</code>域适用于所有将目标系统配置文件的<code>&quot;os&quot;</code>字段设置为<code>&quot;none&quot;</code>的目标系统。这将包括我们的<code>x86_64-blog_os.json</code>目标。<code>runner</code>键指定了<code>cargo run</code>应该调用的命令。该命令是在成功编译后运行的，可执行文件的路径将作为第一个参数传递。更多细节请参见<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/cargo/reference/config.html">cargo文档</a>。</p>
<p><code>bootimage runner</code>命令是专门设计用作<code>runner</code>配置项的可执行程序使用的，它将链接给定的可执行程序和项目的bootloader依赖关系，然后启动QEMU。更多细节和可能的配置选项请参见<a target="_blank" rel="noopener" href="https://github.com/rust-osdev/bootimage"><code>bootimage</code>的Readme</a>。</p>
<p>现在我们可以使用<code>cargo run</code>来编译我们的内核，并在QEMU中启动它。</p>
<h2 id="下期预告"><a href="#下期预告" class="headerlink" title="下期预告"></a>下期预告</h2><p>在下一篇文章中，我们将更详细地探讨VGA文本缓冲区，并为它编写一个安全的接口。我们还将添加对<code>println</code>宏的支持。</p>
<h2 id="支持本项目"><a href="#支持本项目" class="headerlink" title="支持本项目"></a>支持本项目</h2><p>创建和<a target="_blank" rel="noopener" href="https://os.phil-opp.com/status-update/">维护</a>这个博客和相关库是一项繁重的工作，但我真的很喜欢。通过支持我，您可以让我在新内容、新功能和持续维护上投入更多时间。</p>
<p>支持我的最好方式是<a target="_blank" rel="noopener" href="https://github.com/sponsors/phil-opp">在GitHub上赞助我</a>，因为他们不收取任何中间费用。如果你喜欢其他平台，我也有<a target="_blank" rel="noopener" href="https://www.patreon.com/phil_opp">Patreon</a>和<a target="_blank" rel="noopener" href="https://donorbox.org/phil-opp">Donorbox</a>账户。后者是最灵活的，因为它支持多种货币和一次性捐款。</p>
<p>感谢您的支持！</p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Rust/">Rust</a><a class="link-muted mr-2" rel="tag" href="/tags/Operating-System/">Operating System</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatpay.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/02/28/writing-an-os-in-rust-1.3/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">使用Rust编写操作系统 - 1.3 - VGA文本模式</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/02/21/writing-an-os-in-rust-1.1/"><span class="level-item">使用Rust编写操作系统 - 1.1 - Rust独立二进制程序</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><script src="https://utteranc.es/client.js" repo="zlotus/comment" issue-term="pathname" label="some-issue-label" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/opm_sq.png" alt="子实"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">子实</p><p class="is-size-6 is-block">程序员</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>陕西/西安</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">79</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">23</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zlotus" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com/qinzishi"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/Zealot_uS"><i class="fab fa-twitter"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.zhihu.com/people/zlotus" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Diary/"><span class="level-start"><span class="level-item">Diary</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">65</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Shell/"><span class="level-start"><span class="level-item">Shell</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Coroutines/"><span class="tag">Coroutines</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">31</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenCV/"><span class="tag">OpenCV</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Operating-System/"><span class="tag">Operating System</span><span class="tag">21</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Paper/"><span class="tag">Paper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Raspberry-Pi/"><span class="tag">Raspberry Pi</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag">29</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TensorFlow/"><span class="tag">TensorFlow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tokio/"><span class="tag">Tokio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZMQ/"><span class="tag">ZMQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ctpn/"><span class="tag">ctpn</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/llama/"><span class="tag">llama</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macOS/"><span class="tag">macOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/obsidion/"><span class="tag">obsidion</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%A5%E8%AE%B0/"><span class="tag">日记</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E8%B0%88/"><span class="tag">杂谈</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B/"><span class="tag">编程</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%84%9A%E6%9C%AC/"><span class="tag">脚本</span><span class="tag">4</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a><p class="is-size-7"><span>&copy; 2024 子实</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>