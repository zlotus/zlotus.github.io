<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>使用Rust编写操作系统 - 2.3 - 硬件中断 - 子实</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="子实"><meta name="msapplication-TileImage" content="/img/avatar-o.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="子实"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="使用Rust编写操作系统 - 2.3 - 硬件中断"><meta property="og:type" content="article"><meta property="og:title" content="使用Rust编写操作系统 - 2.3 - 硬件中断"><meta property="og:url" content="https://zlotus.github.io/2021/03/18/writing-an-os-in-rust-2.3/"><meta property="og:site_name" content="子实"><meta property="og:description" content="使用Rust编写操作系统 - 2.3 - 硬件中断"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://os.phil-opp.com/hardware-interrupts/qemu-hardware-timer-double-fault.png"><meta property="og:image" content="https://os.phil-opp.com/hardware-interrupts/qemu-single-dot-printed.png"><meta property="og:image" content="https://os.phil-opp.com/hardware-interrupts/qemu-hardware-timer-dots.gif"><meta property="og:image" content="https://os.phil-opp.com/hardware-interrupts/qemu-deadlock.png"><meta property="og:image" content="https://os.phil-opp.com/hardware-interrupts/qemu-printing-scancodes.gif"><meta property="og:image" content="https://os.phil-opp.com/hardware-interrupts/qemu-printing-numbers.gif"><meta property="og:image" content="https://os.phil-opp.com/hardware-interrupts/qemu-typing.gif"><meta property="article:published_time" content="2021-03-18T14:51:00.000Z"><meta property="article:modified_time" content="2021-03-18T14:51:00.000Z"><meta property="article:author" content="子实"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Operating System"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://os.phil-opp.com/hardware-interrupts/qemu-hardware-timer-double-fault.png"><meta property="twitter:creator" content="@Zealot_uS"><meta property="twitter:site" content="Zealot_uS"><link rel="publisher" href="+LotusQin"><meta property="fb:admins" content="qinzishi"><meta property="fb:app_id" content="qinzishi"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zlotus.github.io/2021/03/18/writing-an-os-in-rust-2.3/"},"headline":"使用Rust编写操作系统 - 2.3 - 硬件中断","image":["https://os.phil-opp.com/hardware-interrupts/qemu-hardware-timer-double-fault.png","https://os.phil-opp.com/hardware-interrupts/qemu-single-dot-printed.png","https://os.phil-opp.com/hardware-interrupts/qemu-hardware-timer-dots.gif","https://os.phil-opp.com/hardware-interrupts/qemu-deadlock.png","https://os.phil-opp.com/hardware-interrupts/qemu-printing-scancodes.gif","https://os.phil-opp.com/hardware-interrupts/qemu-printing-numbers.gif","https://os.phil-opp.com/hardware-interrupts/qemu-typing.gif"],"datePublished":"2021-03-18T14:51:00.000Z","dateModified":"2021-03-18T14:51:00.000Z","author":{"@type":"Person","name":"子实"},"publisher":{"@type":"Organization","name":"子实","logo":{"@type":"ImageObject","url":"https://zlotus.github.io/img/opm_sq.png"}},"description":"使用Rust编写操作系统 - 2.3 - 硬件中断"}</script><link rel="icon" href="/img/avatar-o.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/2014/07/09/about-me/">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-18T14:51:00.000Z" title="3/18/2021, 10:51:00 PM">2021-03-18</time>发表</span><span class="level-item"><time dateTime="2021-03-18T14:51:00.000Z" title="3/18/2021, 10:51:00 PM">2021-03-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a></span><span class="level-item">1 小时读完 (大约7535个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">使用Rust编写操作系统 - 2.3 - 硬件中断</h1><div class="content"><article class="message message-immersive is-warning">
<div class="message-body">
<i class="fas fa-exclamation-triangle mr-2"></i>本文所有内容均为翻译，原文：<a target="_blank" rel="noopener" href="https://os.phil-opp.com/hardware-interrupts/">Hardware Interrupts</a>；原项目：<a target="_blank" rel="noopener" href="https://os.phil-opp.com/">Writing an OS in Rust</a>
</div>
</article>

<p>在这篇文章中，我们将设置可编程中断控制器，以便将硬件中断正确的转发到CPU。为了处理这些中断，我们将新条目添加到中断描述符表中，就像我们对异常处理程序所做的一样。我们将学习如何获取定期的定时器中断以及如何从键盘获取输入。</p>
<span id="more"></span>

<p>这个博客是在<a target="_blank" rel="noopener" href="https://github.com/phil-opp/blog_os">GitHub</a>上公开开发的。如果你有任何问题或疑问，请在那里开一个issue。你也可以在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/hardware-interrupts/#comments">底部</a>留言。这篇文章的完整源代码可以在<a target="_blank" rel="noopener" href="https://github.com/phil-opp/blog_os/tree/post-07">post-07</a>分支中找到。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>中断为连接在CPU上的硬件设备提供了一种通知CPU的方法。因此，键盘不必告诉内核要定期检查是否有新的字符输入（一种称为<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Polling_(computer_science)">轮询</a>的过程），而是将每次按键事件通知内核。如此，内核仅在发生某些事件时才做出反应，因此效率更高。这样做还可以缩短响应时间，因为内核不需要等待下一次轮询，它将会立即做出反应。</p>
<p>我们无法将所有硬件设备都直连到CPU，而是采用一个独立的<em>中断控制器</em>汇总所有外设的中断，再通知CPU：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                     ____________             _____</span><br><span class="line">Timer ------------&gt; |            |           |     |</span><br><span class="line">Keyboard ---------&gt; | Interrupt  |---------&gt; | CPU |</span><br><span class="line">Other Hardware ---&gt; | Controller |           |_____|</span><br><span class="line">Etc. -------------&gt; |____________|</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>大多数中断控制器是可编程的，这意味着它们支持不同的中断优先级。例如，这可以让计时器中断的优先级比键盘中断更高，以便确保计时的准确性。</p>
<p>与异常不同，硬件中断的发送是<em>异步</em>的。这意味着中断与正在执行的代码无关，中断是随时都会发生的。因此，内核中突然出现了一种并发，同时也包含了各种潜在的与并发相关的bug。Rust严格的所有权模型在这里帮上了大忙，因为它禁止了可变全局状态。但是，仍然可能出现死锁，正如我们将在本文后面看到的那样。</p>
<h2 id="8259-PIC"><a href="#8259-PIC" class="headerlink" title="8259 PIC"></a>8259 PIC</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Intel_8259">英特尔 8259</a>是1976年推出的可编程中断控制器(PIC)。虽然它早已被较新的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Intel_APIC_Architecture">APIC</a>取代，但由于向后兼容的原因，如今的系统仍支持其接口。8259 PIC的配置比APIC要容易得多，因此在后续文章中切换到APIC之前，我们仍将使用8529 PIC来引入中断。</p>
<p>8259有8条中断线和几条用于与CPU通讯的线。当年的典型系统会配备两个8259 PIC实例，一个主控制器和一个通过中短线连接在主控上的从控制器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                     ____________                          ____________</span><br><span class="line">Real Time Clock --&gt; |            |   Timer -------------&gt; |            |</span><br><span class="line">ACPI -------------&gt; |            |   Keyboard-----------&gt; |            |      _____</span><br><span class="line">Available --------&gt; | Secondary  |----------------------&gt; | Primary    |     |     |</span><br><span class="line">Available --------&gt; | Interrupt  |   Serial Port 2 -----&gt; | Interrupt  |---&gt; | CPU |</span><br><span class="line">Mouse ------------&gt; | Controller |   Serial Port 1 -----&gt; | Controller |     |_____|</span><br><span class="line">Co-Processor -----&gt; |            |   Parallel Port 2/3 -&gt; |            |</span><br><span class="line">Primary ATA ------&gt; |            |   Floppy disk -------&gt; |            |</span><br><span class="line">Secondary ATA ----&gt; |____________|   Parallel Port 1----&gt; |____________|</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上图显示了一个典型的中断线分配布局。可以看到15条线中的大多数都有固定的映射，例如 次PIC的4号线分配给了鼠标。</p>
<p>每个控制器可以通过两个<code>[I/O端口](https://os.phil-opp.com/testing/#i-o-ports)</code>——一个“命令”端口和一个“数据”端口——进行配置。对于主控制器，这些端口是<code>0x20</code>（命令）和<code>0x21</code>（数据）。对于从控制器，它们是<code>0xa0</code>（命令）和<code>0xa1</code>（数据）。有关如何配置PIC的更多信息，请参见<a target="_blank" rel="noopener" href="https://wiki.osdev.org/8259_PIC"><code>osdev.org</code>上的文章</a>。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>PIC的默认配置不可用，因为它会将范围为0到15的中断向量编号发送到CPU。而这些编号已被CPU异常占用，例如，编号8对应双重故障。为了解决这个占用问题，我们需要将PIC中断重新映射到不同的编号。实际范围并不重要，只要它不与例外重叠即可，但是我们通常会选择编号32到47，因为这些是32个异常占用后的第一个段空闲数字。</p>
<p>我们可以通过向PIC的命令和数据端口写入特殊值来使配置生效。幸运的是，已经有一个名为<code>pic8259_simple</code>的crate，因此我们不需要自己编写初始化过程。如果你对它的工作方式感兴趣，请查看<a target="_blank" rel="noopener" href="https://docs.rs/crate/pic8259_simple/0.2.0/source/src/lib.rs">它的源代码</a>，该crate很小并且文档齐全。</p>
<p>要将crate添加为依赖，我们需要将以下内容添加到项目中：</p>
<figure class="highlight toml"><figcaption><span>in Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">pic8259_simple</span> = <span class="string">&quot;0.2.0&quot;</span></span><br></pre></td></tr></table></figure>

<p>该crate提供的主要抽象为结构体<code>ChainedPics</code>。该结构体代表了我们在上面介绍的主/次PIC布局。它的用法如下：</p>
<figure class="highlight rust"><figcaption><span>in src/interrupts.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> pic8259_simple::ChainedPics;</span><br><span class="line"><span class="keyword">use</span> spin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> PIC_1_OFFSET: <span class="built_in">u8</span> = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> PIC_2_OFFSET: <span class="built_in">u8</span> = PIC_1_OFFSET + <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">static</span> PICS: spin::Mutex&lt;ChainedPics&gt; =</span><br><span class="line">    spin::Mutex::new(<span class="keyword">unsafe</span> &#123; ChainedPics::new(PIC_1_OFFSET, PIC_2_OFFSET) &#125;);</span><br></pre></td></tr></table></figure>

<p>像上面这样将PIC的偏移量设置为32-47。通过将<code>ChainedPics</code>结构体放置于<code>Mutex</code>中，我们就能够（通过<code>lock</code>方法）获得安全的写访问权限，这是下一步所必需的。<code>ChainedPics::new</code>函数被标记为非安全的，因为提供错误的偏移量将可能导致未定义的行为。</p>
<p>现在，我们可以在<code>init</code>函数中初始化8259 PIC了：</p>
<figure class="highlight rust"><figcaption><span>in src/lib.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">init</span></span>() &#123;</span><br><span class="line">    gdt::init();</span><br><span class="line">    interrupts::init_idt();</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; interrupts::PICS.lock().initialize() &#125;; <span class="comment">// new</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>[initialize](https://docs.rs/pic8259_simple/0.2.0/pic8259_simple/struct.ChainedPics.html#method.initialize)</code>函数来执行PIC初始化。与<code>ChainedPics::new</code>函数一样，该函数也是非安全的，因为如果PIC配置错误，使用它也将可能导致未定义的行为。</p>
<p>如果一切顺利，执行<code>cargo run</code>时，我们应该继续看到“It not not crash”消息。</p>
<h2 id="启用中断"><a href="#启用中断" class="headerlink" title="启用中断"></a>启用中断</h2><p>到目前为止，什么都没发生，因为在CPU配置中依然禁用着中断。这意味着CPU根本不侦听中断控制器，也就没有中断可以到达CPU。让我们更改一下配置：</p>
<figure class="highlight rust"><figcaption><span>in src/lib.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">init</span></span>() &#123;</span><br><span class="line">    gdt::init();</span><br><span class="line">    interrupts::init_idt();</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; interrupts::PICS.lock().initialize() &#125;;</span><br><span class="line">    x86_64::instructions::interrupts::enable();     <span class="comment">// new</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>x86_64</code>crate的<code>interrupts::enable</code>将函数执行特殊的<code>sti</code>指令（即“设置中断”）以启用外部中断。当我们现在尝试<code>cargo run</code>时，将看到发生双重故障：</p>
<p><img src="https://os.phil-opp.com/hardware-interrupts/qemu-hardware-timer-double-fault.png" alt="QEMU硬件计时器诱发的双重故障"></p>
<p>发生此双重故障是因为硬件计时器在默认情况下为启用状态（确切地说是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Intel_8253">Intel 8253</a>），因此一旦启用中断，我们便开始接收计时器中断。由于尚未为计时器定义处理函数，因此双重故障处理程序将会被调用。</p>
<h3 id="处理定时器中断"><a href="#处理定时器中断" class="headerlink" title="处理定时器中断"></a>处理定时器中断</h3><p>从<a target="_blank" rel="noopener" href="https://os.phil-opp.com/hardware-interrupts/#the-8259-pic">上图</a>可以看出，定时器使用主PIC的0号线。这意味着它将作为中断<code>32</code>（0+偏移量32）到达CPU。我们不对索引32进行硬编码，而是将其存放在<code>InterruptIndex</code>枚举中：</p>
<figure class="highlight rust"><figcaption><span>in src/interrupts.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Clone, Copy)]</span></span><br><span class="line"><span class="meta">#[repr(u8)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">InterruptIndex</span></span> &#123;</span><br><span class="line">    Timer = PIC_1_OFFSET,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> InterruptIndex &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">as_u8</span></span>(<span class="keyword">self</span>) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="keyword">as</span> <span class="built_in">u8</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">as_usize</span></span>(<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">        <span class="built_in">usize</span>::from(<span class="keyword">self</span>.as_u8())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该枚举是一个<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/reference/items/enumerations.html#custom-discriminant-values-for-fieldless-enumerations">C风格</a>枚举，因此我们可以直接为每个变体指定索引。<code>repr(u8)</code>属性指定每个变体都表 示为<code>u8</code>。将来我们还会添加更多中断变量。</p>
<p>现在我们可以为计时器中断添加一个处理函数：</p>
<figure class="highlight rust"><figcaption><span>in src/interrupts.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::print;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> IDT: InterruptDescriptorTable = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> idt = InterruptDescriptorTable::new();</span><br><span class="line">        idt.breakpoint.set_handler_fn(breakpoint_handler);</span><br><span class="line">        […]</span><br><span class="line">        idt[InterruptIndex::Timer.as_usize()]</span><br><span class="line">            .set_handler_fn(timer_interrupt_handler); <span class="comment">// new</span></span><br><span class="line"></span><br><span class="line">        idt</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;x86-interrupt&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">timer_interrupt_handler</span></span>(</span><br><span class="line">    _stack_frame: &amp;<span class="keyword">mut</span> InterruptStackFrame)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>timer_interrupt_handler</code>的函数签名与之前的异常处理函数相同，因为CPU对异常和外部中断的反应相同（唯一的区别是某些异常会推送错误码）。<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/idt/struct.InterruptDescriptorTable.html"><code>InterruptDescriptorTable</code></a>结构体实现了<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/ops/trait.IndexMut.html"><code>IndexMut</code></a> trait，因此我们可以使用数组索引语法访问各个条目。</p>
<p>在计时器中断处理程序中，我们在屏幕上打印了一个点。由于定时器中断是周期性发生的，因此我们希望每个定时器定期出现一个点。但是，当我们运行它时，我们看到只打印了一个点：</p>
<p><img src="https://os.phil-opp.com/hardware-interrupts/qemu-single-dot-printed.png" alt="QEMU仅打印了一个点"></p>
<h3 id="当中断结束时"><a href="#当中断结束时" class="headerlink" title="当中断结束时"></a>当中断结束时</h3><p>原因是PIC希望中断处理程序显示发出“中断结束”(EOI)信号。该信号告诉控制器该中断已被处理，同时系统已经准备好接收下一个中断。因此，PIC认为我们仍在忙于处理第一个计时器中断，并在耐心等待EOI信号，然后才发送下一个中断。</p>
<p>要发送EOI，我们需要再次使用静态<code>PICS</code>结构体：</p>
<figure class="highlight rust"><figcaption><span>in src/interrupts.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;x86-interrupt&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">timer_interrupt_handler</span></span>(</span><br><span class="line">    _stack_frame: &amp;<span class="keyword">mut</span> InterruptStackFrame)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        PICS.lock()</span><br><span class="line">            .notify_end_of_interrupt(InterruptIndex::Timer.as_u8());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>notify_end_of_interrupt</code>会推断出是主PIC还是从PIC发送了中断，然后使用<code>command</code>和<code>data</code>端口将EOI信号发送到各控制器。如果是从PIC发送了中断，则需要通知两个PIC，因为从PIC通过输入线连接在主PIC上。</p>
<p>我们需要小心的使用正确的中断向量编号，否则可能会意外删除重要的未发送中断或导致系统挂起。这也是为什么该函数别标记为了非安全。</p>
<p>现在，当我们执行<code>cargo run</code>时，我们会看到点定期出现在屏幕上：</p>
<p><img src="https://os.phil-opp.com/hardware-interrupts/qemu-hardware-timer-dots.gif" alt="QEMU硬件计时器打点"></p>
<h3 id="配置计时器"><a href="#配置计时器" class="headerlink" title="配置计时器"></a>配置计时器</h3><p>我们使用的硬件计时器叫做<em>可编程间隔计时器</em>，也简称为PIT。顾名思义，我们可以配置两个中断之间的间隔。这里不做详细介绍，因为后文将很快切换到<a target="_blank" rel="noopener" href="https://wiki.osdev.org/APIC_timer">APIC计时器</a>，但是OSDev Wiki上有大量有关<a target="_blank" rel="noopener" href="https://wiki.osdev.org/Programmable_Interval_Timer">配置PIT</a>的文章。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>现在，我们的内核中具有了一种并发形式：定时器中断会异步的发生，因此它们可以随时中断我们的<code>_start</code>函数。幸运的是，Rust的所有权系统可以在编译时就能够防止很多与并发相关的bug。不过，死锁是一个值得注意的例外。如果线程试图获取永远不会释放的锁，则会发生死锁。此时，线程会无限期地挂起。</p>
<p>我们现在就可以在内核中诱发死锁。记住，我们的<code>println</code>宏调用<code>vga_buffer::__print</code>函数，而该函数会用自旋锁<a target="_blank" rel="noopener" href="https://os.phil-opp.com/vga-text-mode/#spinlocks">锁定全局变量<code>WRITER</code></a>：</p>
<figure class="highlight rust"><figcaption><span>in src/vga_buffer.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[…]</span><br><span class="line"></span><br><span class="line"><span class="meta">#[doc(hidden)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">_print</span></span>(args: fmt::Arguments) &#123;</span><br><span class="line">    <span class="keyword">use</span> core::fmt::Write;</span><br><span class="line">    WRITER.lock().write_fmt(args).unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数先锁定<code>WRITER</code>再调用其<code>write_fmt</code>，并会在函数末尾隐式将<code>WRITER</code>解锁。现在想象一下，在WRITER锁定时发生了中断，并且中断处理程序也尝试打印一些内容：</p>
<table>
<thead>
<tr>
<th>时序</th>
<th><code>_start</code></th>
<th><code>interrupt_handler</code></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>调用<code>println!</code></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td><code>print</code>锁定<code>WRITER</code></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td><strong>中断发生</strong>，调用中断处理程序</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>调用 <code>println!</code></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td><code>print</code>尝试锁定<code>WRITER</code>（已被锁定）</td>
</tr>
<tr>
<td>5</td>
<td></td>
<td><code>print</code>尝试锁定<code>WRITER</code>（已被锁定）</td>
</tr>
<tr>
<td>…</td>
<td></td>
<td>…</td>
</tr>
<tr>
<td><em>永不</em></td>
<td><em>解锁 <code>WRITER</code></em></td>
<td></td>
</tr>
</tbody></table>
<p><code>WRITER</code>被锁定，因此中断处理程序会等待锁释放。但这永远不会发生，因为<code>_start</code>函数仅在中断处理程序返回后才继续运行。因此，整个系统挂起。</p>
<h3 id="诱发死锁"><a href="#诱发死锁" class="headerlink" title="诱发死锁"></a>诱发死锁</h3><p>通过在<code>_start</code>函数末尾的<code>loop</code>循环中打印一些内容，我们就可以轻松地在内核中引发这种死锁：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>() -&gt; ! &#123;</span><br><span class="line">    […]</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">use</span> blog_os::print;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;-&quot;</span>);        <span class="comment">// new</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://os.phil-opp.com/hardware-interrupts/qemu-deadlock.png" alt="QEMU死锁"></p>
<p>我们看到只有有限的连字符被打印，当第一次定时器中断发生时便停止打印。之后系统挂起，因为计时器中断处理程序在尝试打印点时会死锁。这就是我们在上面的输出中看不到任何点的原因。</p>
<p>每次运行打印的连字符数量会有所不同，因为计时器中断是异步发生的。正是这种不确定性使得与并发相关的bug难以调试。</p>
<h3 id="修复死锁"><a href="#修复死锁" class="headerlink" title="修复死锁"></a>修复死锁</h3><p>为了避免发生这种死锁，只要<code>Mutex</code>处于锁定状态，我们就禁用中断：</p>
<figure class="highlight rust"><figcaption><span>in src/vga_buffer.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Prints the given formatted string to the VGA text buffer</span></span><br><span class="line"><span class="comment">/// through the global `WRITER` instance.</span></span><br><span class="line"><span class="meta">#[doc(hidden)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">_print</span></span>(args: fmt::Arguments) &#123;</span><br><span class="line">    <span class="keyword">use</span> core::fmt::Write;</span><br><span class="line">    <span class="keyword">use</span> x86_64::instructions::interrupts;   <span class="comment">// new</span></span><br><span class="line"></span><br><span class="line">    interrupts::without_interrupts(|| &#123;     <span class="comment">// new</span></span><br><span class="line">        WRITER.lock().write_fmt(args).unwrap();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/instructions/interrupts/fn.without_interrupts.html"><code>without_interrupts</code></a>函数将获取一个闭包并在无中断的环境中执行该闭包。我们使用它来确保只要互斥锁被锁定，就不会发生中断。现在，当我们运行内核时，我们看到它一直在运行而不会挂起。（我们仍然没有注意到任何点，这是因为打印滚动的速度太快。请尝试减慢打印速度，例如，将<code>for _ in 0..10000 &#123;&#125;</code>放置在<code>loop</code>中。）</p>
<p>我们可以对串行打印功能应用相同的更改，以确保不会发生死锁：</p>
<figure class="highlight rust"><figcaption><span>in src/serial.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[doc(hidden)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">_print</span></span>(args: ::core::fmt::Arguments) &#123;</span><br><span class="line">    <span class="keyword">use</span> core::fmt::Write;</span><br><span class="line">    <span class="keyword">use</span> x86_64::instructions::interrupts;       <span class="comment">// new</span></span><br><span class="line"></span><br><span class="line">    interrupts::without_interrupts(|| &#123;         <span class="comment">// new</span></span><br><span class="line">        SERIAL1</span><br><span class="line">            .lock()</span><br><span class="line">            .write_fmt(args)</span><br><span class="line">            .expect(<span class="string">&quot;Printing to serial failed&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，禁用中断并不应该作为通用的解决方案。因为这样做会增加最坏情况下的中断响应时间，即直到系统被允许对中断做出反应之前的时间。因此，只应该在很短的时间内禁用中断。</p>
<h2 id="修复竞争条件"><a href="#修复竞争条件" class="headerlink" title="修复竞争条件"></a>修复竞争条件</h2><p>现在如果执行<code>cargo test</code>，可能会看到<code>test_println_output</code>测试失败：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; cargo <span class="built_in">test</span> --lib</span><br><span class="line">[…]</span><br><span class="line">Running 4 tests</span><br><span class="line">test_breakpoint_exception...[ok]</span><br><span class="line">test_println... [ok]</span><br><span class="line">test_println_many... [ok]</span><br><span class="line">test_println_output... [failed]</span><br><span class="line"></span><br><span class="line">Error: panicked at <span class="string">&#x27;assertion failed: `(left == right)`</span></span><br><span class="line"><span class="string">  left: `&#x27;</span>.<span class="string">&#x27;`,</span></span><br><span class="line"><span class="string"> right: `&#x27;</span>S<span class="string">&#x27;`&#x27;</span>, src/vga_buffer.rs:205:9</span><br></pre></td></tr></table></figure>

<p>原因是测试与我们的计时器处理程序之间存在竞争条件。回忆一下测试看起来像这样：</p>
<figure class="highlight rust"><figcaption><span>in src/vga_buffer.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test_case]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_println_output</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">&quot;Some test string that fits on a single line&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">    <span class="keyword">for</span> (i, c) <span class="keyword">in</span> s.chars().enumerate() &#123;</span><br><span class="line">        <span class="keyword">let</span> screen_char = WRITER.lock().buffer.chars[BUFFER_HEIGHT - <span class="number">2</span>][i].read();</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="built_in">char</span>::from(screen_char.ascii_character), c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该测试将一个字符串打印到VGA缓冲区，然后通过手动迭代<code>buffer_chars</code>数组来检查输出。由于计时器中断处理程序可能在<code>println</code>之后，读取屏幕字符之前运行（中断处理函数会输出一个<code>.</code>），因此发生竞争状态。请注意，这不是危险的<em>数据竞争</em>，Rust在编译时完全避免了这种竞争。有关详细信息，请参见<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nomicon/races.html">Rustonomicon</a>。</p>
<p>要解决此问题，我们需要在测试的整个过程中保持<code>WRITER</code>处于锁定状态，以使计时器处理程序无法将<code>.</code>打印到“打印行为”和“读取行为”之间的屏幕上。修复的测试如下所示：</p>
<figure class="highlight rust"><figcaption><span>in src/vga_buffer.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test_case]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_println_output</span></span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> core::fmt::Write;</span><br><span class="line">    <span class="keyword">use</span> x86_64::instructions::interrupts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">&quot;Some test string that fits on a single line&quot;</span>;</span><br><span class="line">    interrupts::without_interrupts(|| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> writer = WRITER.lock();</span><br><span class="line">        <span class="built_in">writeln!</span>(writer, <span class="string">&quot;\n&#123;&#125;&quot;</span>, s).expect(<span class="string">&quot;writeln failed&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (i, c) <span class="keyword">in</span> s.chars().enumerate() &#123;</span><br><span class="line">            <span class="keyword">let</span> screen_char = writer.buffer.chars[BUFFER_HEIGHT - <span class="number">2</span>][i].read();</span><br><span class="line">            <span class="built_in">assert_eq!</span>(<span class="built_in">char</span>::from(screen_char.ascii_character), c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们进行了以下改进：</p>
<ul>
<li>显式调用<code>lock()</code>方法，使<code>WRITER</code>在整个测试过程中保持锁定状态。代替<code>println</code>，我们使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/macro.writeln.html"><code>writeln</code></a>宏，该宏允许打印到已经锁定的写入器。</li>
<li>为了避免再次出现死锁，我们在测试期间禁用中断。否则，在<code>WRITER</code>仍处于锁定状态时，测试可能会中断。</li>
<li>由于计时器中断处理程序仍旧可能在测试之前运行，因此在打印字符串<code>s</code>之前，我们还要打印一个换行符<code>\n</code>。这样，即使计时器中断处理程序已经打印出<code>.</code>，我们仍然可以避免测试失败。</li>
</ul>
<p>通过上述更改，现在可以确定地再次运行<code>cargo test</code>。</p>
<p>这是一个无害的竞争条件，仅可能会导致测试失败。你可以想象，其他竞争条件会由于其不确定性而更加难以调试。幸运的是，Rust帮我们阻止了最严重的竞争条件——数据竞争，该竞争条件会导致各种不确定的行为，包括系统崩溃和静默的内存数据损坏。</p>
<h2 id="hlt指令"><a href="#hlt指令" class="headerlink" title="hlt指令"></a><code>hlt</code>指令</h2><p>到目前为止，我们在<code>_start</code>和<code>panic</code>函数的末尾使用了一个简单的空循环语句。这将使得CPU一直在工作，虽然这是代码预期的效果，但这也是非常低效的，因为即使没有任何工作，CPU仍将继续满负荷运行。运行内核时，您可以在任务管理器中观察到此现象：QEMU进程始终需要近100％的CPU使用率。</p>
<p>我们真正想做的是停止CPU，直到下一个中断发生。这期间应允许CPU进入睡眠状态，在该状态下CPU消耗的能量要少得多。<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/HLT_(x86_instruction)"><code>hlt</code>指令</a>正是这样做的。让我们使用该指令创建一个节能的无限循环：</p>
<figure class="highlight rust"><figcaption><span>in src/lib.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">hlt_loop</span></span>() -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        x86_64::instructions::hlt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>instructions::hlt</code>函数只是<a target="_blank" rel="noopener" href="https://github.com/rust-osdev/x86_64/blob/5e8e218381c5205f5777cb50da3ecac5d7e3b1ab/src/instructions/mod.rs#L16-L22">简单封装</a>了汇编指令。不过这是安全的，因为这个操作并不会损害内存安全。</p>
<p>现在，我们可以使用此<code>hlt_loop</code>代替<code>_start</code>和<code>panic</code>函数中的无限循环：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>() -&gt; ! &#123;</span><br><span class="line">    […]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;It did not crash!&quot;</span>);</span><br><span class="line">    blog_os::hlt_loop();            <span class="comment">// new</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(not(test))]</span></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">panic</span></span>(info: &amp;PanicInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, info);</span><br><span class="line">    blog_os::hlt_loop();            <span class="comment">// new</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把<code>lib.rs</code>也一更新一下：</p>
<figure class="highlight rust"><figcaption><span>in src/lib.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Entry point for `cargo test`</span></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>() -&gt; ! &#123;</span><br><span class="line">    init();</span><br><span class="line">    test_main();</span><br><span class="line">    hlt_loop();         <span class="comment">// new</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">test_panic_handler</span></span>(info: &amp;PanicInfo) -&gt; ! &#123;</span><br><span class="line">    serial_println!(<span class="string">&quot;[failed]\n&quot;</span>);</span><br><span class="line">    serial_println!(<span class="string">&quot;Error: &#123;&#125;\n&quot;</span>, info);</span><br><span class="line">    exit_qemu(QemuExitCode::Failed);</span><br><span class="line">    hlt_loop();         <span class="comment">// new</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在在QEMU中运行内核时，我们发现CPU使用率要低得多。</p>
<h2 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h2><p>现在我们已经能够处理来自外部设备的中断了，也终于可以添加对键盘输入的支持了。这是将是我们与内核的首次交互。</p>
<blockquote>
<p>请注意，此处我们仅描述如何处理<code>PS/2</code>键盘，而不是USB键盘。但是，主板会将USB键盘模拟为<code>PS/2</code>设备以支持较旧的软件，因此我们可以安心地忽略USB键盘，直到内核中能够提供对USB的支持。</p>
</blockquote>
<p>与硬件计时器一样，键盘控制器在默认情况下就是启用状态。因此，当您按下一个键时，键盘控制器会向PIC发送一个中断，然后将其转发给CPU。CPU在IDT中查找处理程序功能，但相应的条目为空。于是会发生双重故障。</p>
<p>因此，让我们为键盘中断添加一个处理函数。这与我们为计时器中断定义处理程序的方式非常相似，只是使用了一个不同的中断编号而已：</p>
<figure class="highlight rust"><figcaption><span>in src/interrupts.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Clone, Copy)]</span></span><br><span class="line"><span class="meta">#[repr(u8)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">InterruptIndex</span></span> &#123;</span><br><span class="line">    Timer = PIC_1_OFFSET,</span><br><span class="line">    Keyboard, <span class="comment">// new</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> IDT: InterruptDescriptorTable = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> idt = InterruptDescriptorTable::new();</span><br><span class="line">        idt.breakpoint.set_handler_fn(breakpoint_handler);</span><br><span class="line">        […]</span><br><span class="line">        <span class="comment">// new</span></span><br><span class="line">        idt[InterruptIndex::Keyboard.as_usize()]</span><br><span class="line">            .set_handler_fn(keyboard_interrupt_handler);</span><br><span class="line"></span><br><span class="line">        idt</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;x86-interrupt&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">keyboard_interrupt_handler</span></span>(</span><br><span class="line">    _stack_frame: &amp;<span class="keyword">mut</span> InterruptStackFrame)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;k&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        PICS.lock()</span><br><span class="line">            .notify_end_of_interrupt(InterruptIndex::Keyboard.as_u8());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从前面的图可以看出，键盘使用了主PIC的第1行。这意味着它作为中断33（1+偏移量32）到达CPU。将此索引作为<code>InterruptIndex</code>枚举的新变量<code>Keyboard</code>添加。我们并不需要显式指定该值，因为它默认为前一个值加一，也就是33。在中断处理程序中，我们打印一个<code>k</code>并将中断结束信号发送到中断控制器。</p>
<p>现在按下键盘时屏幕上会打印一个<code>k</code>。但是，这仅对我们按的第一个键起作用，此后即使我们继续按键盘也不会在屏幕上打印更多<code>k</code>了。这是因为键盘控制器在我们读取该键所对应的<em>扫描码</em>之前不会再发送下一个中断。</p>
<h3 id="读取扫描码"><a href="#读取扫描码" class="headerlink" title="读取扫描码"></a>读取扫描码</h3><p>为了找出按下了<em>哪个</em>键，我们需要查询键盘控制器。通过读取<code>PS/2</code>控制器的数据端口（即<code>I/O</code>端口<code>0x60</code>）来执行此操作：</p>
<figure class="highlight rust"><figcaption><span>in src/interrupts.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;x86-interrupt&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">keyboard_interrupt_handler</span></span>(</span><br><span class="line">    _stack_frame: &amp;<span class="keyword">mut</span> InterruptStackFrame)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">use</span> x86_64::instructions::port::Port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> port = Port::new(<span class="number">0x60</span>);</span><br><span class="line">    <span class="keyword">let</span> scancode: <span class="built_in">u8</span> = <span class="keyword">unsafe</span> &#123; port.read() &#125;;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, scancode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        PICS.lock()</span><br><span class="line">            .notify_end_of_interrupt(InterruptIndex::Keyboard.as_u8());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>x86_64</code>crate提供的<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/instructions/port/struct.Port.html"><code>Port</code></a>类型从键盘的数据端口读取一个字节。该字节称为<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Scancode"><em>扫描码</em></a>，是一个代表按下/释放的键所对应的数字。我们还没有用扫描码做任何事情，只是将其打印在屏幕上：</p>
<p><img src="https://os.phil-opp.com/hardware-interrupts/qemu-printing-scancodes.gif" alt="QEMU打印扫描码"></p>
<p>上图显示了我缓慢键入“123”时的情况。我们看到相邻的键具有相邻的扫描码，并且“按下键”和“释放键”所触发的扫描码并不相同。那么，我们如何将扫描码准确地转换为实际的按键动作呢？</p>
<h3 id="翻译扫描码"><a href="#翻译扫描码" class="headerlink" title="翻译扫描码"></a>翻译扫描码</h3><p>扫描码和按键之间有三种不同的映射标准，即所谓的<em>扫描码集</em>。这三个码集都可以追溯到早期IBM计算机的键盘：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IBM_Personal_Computer_XT">IBM XT</a>、<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IBM_3270_PC">IBM 3270 PC</a>和<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IBM_Personal_Computer/AT">IBM AT</a>。值得庆幸的是后来的计算机没有延续这种定义新扫描码集的趋势，而是模拟了现有的扫描码集并进行扩展。如今，大多数键盘都可以配置为模拟这三组中的任意一组。</p>
<p>默认情况下，<code>PS/2</code>键盘模拟扫描代码集1(“XT”)。在此集中，扫描码字节的低7位定义键，而最高位定义是按下(“0”)还是释放(“1”)。那些<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IBM_Personal_Computer_XT">IBM XT</a>键盘上不存在的键，如Enter键，会连续生成两个扫描代码：一个<code>0xe0</code>转义字节，后接一个代表触发键的字节。有关集合1中所有扫描码及其对应键的表，参见<a target="_blank" rel="noopener" href="https://wiki.osdev.org/Keyboard#Scan_Code_Set_1">OSDev Wiki</a>。</p>
<p>要将扫描码转换为键，我们可以使用match语句：</p>
<figure class="highlight rust"><figcaption><span>in src/interrupts.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;x86-interrupt&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">keyboard_interrupt_handler</span></span>(</span><br><span class="line">    _stack_frame: &amp;<span class="keyword">mut</span> InterruptStackFrame)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">use</span> x86_64::instructions::port::Port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> port = Port::new(<span class="number">0x60</span>);</span><br><span class="line">    <span class="keyword">let</span> scancode: <span class="built_in">u8</span> = <span class="keyword">unsafe</span> &#123; port.read() &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new</span></span><br><span class="line">    <span class="keyword">let</span> key = <span class="keyword">match</span> scancode &#123;</span><br><span class="line">        <span class="number">0x02</span> =&gt; <span class="literal">Some</span>(<span class="string">&#x27;1&#x27;</span>),</span><br><span class="line">        <span class="number">0x03</span> =&gt; <span class="literal">Some</span>(<span class="string">&#x27;2&#x27;</span>),</span><br><span class="line">        <span class="number">0x04</span> =&gt; <span class="literal">Some</span>(<span class="string">&#x27;3&#x27;</span>),</span><br><span class="line">        <span class="number">0x05</span> =&gt; <span class="literal">Some</span>(<span class="string">&#x27;4&#x27;</span>),</span><br><span class="line">        <span class="number">0x06</span> =&gt; <span class="literal">Some</span>(<span class="string">&#x27;5&#x27;</span>),</span><br><span class="line">        <span class="number">0x07</span> =&gt; <span class="literal">Some</span>(<span class="string">&#x27;6&#x27;</span>),</span><br><span class="line">        <span class="number">0x08</span> =&gt; <span class="literal">Some</span>(<span class="string">&#x27;7&#x27;</span>),</span><br><span class="line">        <span class="number">0x09</span> =&gt; <span class="literal">Some</span>(<span class="string">&#x27;8&#x27;</span>),</span><br><span class="line">        <span class="number">0x0a</span> =&gt; <span class="literal">Some</span>(<span class="string">&#x27;9&#x27;</span>),</span><br><span class="line">        <span class="number">0x0b</span> =&gt; <span class="literal">Some</span>(<span class="string">&#x27;0&#x27;</span>),</span><br><span class="line">        _ =&gt; <span class="literal">None</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(key) = key &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        PICS.lock()</span><br><span class="line">            .notify_end_of_interrupt(InterruptIndex::Keyboard.as_u8());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码将翻译数字键0-9，并忽略其他键。它使用<code>match</code>语句为每个扫描码分配一个字符或一个<code>None</code>。然后使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch18-01-all-the-places-for-patterns.html#conditional-if-let-expressions"><code>if let</code></a>语句解构变量<code>key</code>中的字符。通过在模式中使用相同变量名<code>key</code>，我们可以<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#shadowing">遮蔽</a>先前的声明，这是Rust中解构<code>Option</code>类型的常见写法。</p>
<p>现在我们可以打印数字了：</p>
<p><img src="https://os.phil-opp.com/hardware-interrupts/qemu-printing-numbers.gif" alt="QEMU打印数字"></p>
<p>翻译其他键的方法相同。 幸运的是，有一个名为<a target="_blank" rel="noopener" href="https://docs.rs/pc-keyboard/0.5.0/pc_keyboard/"><code>pc-keyboard</code></a>的crate可用于翻译集1和集2的扫描码，因此我们不必自己实现此功能。要使用crate，请将其添加到<code>Cargo.toml</code>中，然后将其导入<code>lib.rs</code>中：</p>
<figure class="highlight rust"><figcaption><span>in Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">pc-keyboard = <span class="string">&quot;0.5.0&quot;</span></span><br></pre></td></tr></table></figure>

<p>现在，我们可以使用此crate重写我们的<code>keyboard_interrupt_handler</code>：</p>
<figure class="highlight rust"><figcaption><span>in/src/interrupts.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;x86-interrupt&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">keyboard_interrupt_handler</span></span>(</span><br><span class="line">    _stack_frame: &amp;<span class="keyword">mut</span> InterruptStackFrame)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">use</span> pc_keyboard::&#123;layouts, DecodedKey, HandleControl, Keyboard, ScancodeSet1&#125;;</span><br><span class="line">    <span class="keyword">use</span> spin::Mutex;</span><br><span class="line">    <span class="keyword">use</span> x86_64::instructions::port::Port;</span><br><span class="line"></span><br><span class="line">    lazy_static! &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">ref</span> KEYBOARD: Mutex&lt;Keyboard&lt;layouts::Us104Key, ScancodeSet1&gt;&gt; =</span><br><span class="line">            Mutex::new(Keyboard::new(layouts::Us104Key, ScancodeSet1,</span><br><span class="line">                HandleControl::Ignore)</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> keyboard = KEYBOARD.lock();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> port = Port::new(<span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> scancode: <span class="built_in">u8</span> = <span class="keyword">unsafe</span> &#123; port.read() &#125;;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Ok</span>(<span class="literal">Some</span>(key_event)) = keyboard.add_byte(scancode) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(key) = keyboard.process_keyevent(key_event) &#123;</span><br><span class="line">            <span class="keyword">match</span> key &#123;</span><br><span class="line">                DecodedKey::Unicode(character) =&gt; <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, character),</span><br><span class="line">                DecodedKey::RawKey(key) =&gt; <span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, key),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        PICS.lock()</span><br><span class="line">            .notify_end_of_interrupt(InterruptIndex::Keyboard.as_u8());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>lazy_static</code>宏创建一个由<code>Mutex</code>保护的静态<a target="_blank" rel="noopener" href="https://docs.rs/pc-keyboard/0.5.0/pc_keyboard/struct.Keyboard.html"><code>Keyboard</code></a>对象。使用美式键盘布局和扫描码集1初始化<code>Keyboard</code>。<a target="_blank" rel="noopener" href="https://docs.rs/pc-keyboard/0.5.0/pc_keyboard/enum.HandleControl.html"><code>HandleControl</code></a>参数允许将<code>ctrl+[a-z]</code>映射到<code>U+0001</code>至<code>U+001A</code>的Unicode字符上。我们并不想这样做，因此使用<code>Ignore</code>选项来像处理普通键一样处理ctrl。</p>
<p>对于每个中断，我们锁定Mutex，从键盘控制器读取扫描码，并将其传递给<a target="_blank" rel="noopener" href="https://docs.rs/pc-keyboard/0.5.0/pc_keyboard/struct.Keyboard.html#method.add_byte"><code>add_byte</code></a>方法，该方法将扫描代码转换为<code>Option&lt;KeyEvent&gt;</code>。<a target="_blank" rel="noopener" href="https://docs.rs/pc-keyboard/0.5.0/pc_keyboard/struct.KeyEvent.html"><code>KeyEvent</code></a>包含该键触发的事件，以及究竟是按下事件还是释放事件。</p>
<p>为了翻译此按键事件，我们将其传递给<a target="_blank" rel="noopener" href="https://docs.rs/pc-keyboard/0.5.0/pc_keyboard/struct.Keyboard.html#method.process_keyevent"><code>process_keyevent</code></a>方法，如果可能的话，该方法会将按键事件转换为字符。例如，根据是否按下了Shift键，将<code>A</code>键的按下事件转换为小写字符<code>a</code>或大写<code>A</code>字符。</p>
<p>使用修改后的中断处理程序，我们已经能够输入文本了：</p>
<p><img src="https://os.phil-opp.com/hardware-interrupts/qemu-typing.gif" alt="在QEMU中打字"></p>
<h3 id="配置键盘"><a href="#配置键盘" class="headerlink" title="配置键盘"></a>配置键盘</h3><p>我们可以配置<code>PS/2</code>键盘的某些功能，例如应使用哪个扫描码集。我们不会在这里介绍它，因为这篇文章已经足够长了，但是OSDev Wiki概述了可能的<a target="_blank" rel="noopener" href="https://wiki.osdev.org/PS/2_Keyboard#Commands">配置命令</a>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文解释了如何启用和处理外部设备中断。我们了解了8259 PIC及其主/从布局、中断号的重新映射以及发送“中断结束”信号。我们为硬件计时器和键盘中断实现了处理程序，并了解了<code>hlt</code>指令，该指令能够将CPU暂停，直到下一个中断。</p>
<p>现在，我们可以与内核进行交互，并且初步编写出了一些基础模块，可用于创建小型shell或简单游戏。</p>
<h2 id="下期预告"><a href="#下期预告" class="headerlink" title="下期预告"></a>下期预告</h2><p>计时器中断对于操作系统来说至关重要，因为它们提供了一种定期中断运行中的进程并使得内核重新获得控制权的方法。之后，内核就可以切换到另一个进程，并让人们产生多个进程并行执行的错觉。</p>
<p>但是在创建进程或线程之前，我们需要一种为它们分配内存的方法。下一篇文章将探讨内存管理以提供此类基础模块。</p>
<h2 id="支持本项目"><a href="#支持本项目" class="headerlink" title="支持本项目"></a>支持本项目</h2><p>创建和<a target="_blank" rel="noopener" href="https://os.phil-opp.com/status-update/">维护</a>这个博客和相关库是一项繁重的工作，但我真的很喜欢。通过支持我，您可以让我在新内容、新功能和持续维护上投入更多时间。</p>
<p>支持我的最好方式是<a target="_blank" rel="noopener" href="https://github.com/sponsors/phil-opp">在GitHub上赞助我</a>，因为他们不收取任何中间费用。如果你喜欢其他平台，我也有<a target="_blank" rel="noopener" href="https://www.patreon.com/phil_opp">Patreon</a>和<a target="_blank" rel="noopener" href="https://donorbox.org/phil-opp">Donorbox</a>账户。后者是最灵活的，因为它支持多种货币和一次性捐款。</p>
<p>感谢您的支持！</p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Rust/">Rust</a><a class="link-muted mr-2" rel="tag" href="/tags/Operating-System/">Operating System</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatpay.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/03/21/writing-an-os-in-rust-3.1/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">使用Rust编写操作系统 - 3.1 - 内存分页简介</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/03/15/writing-an-os-in-rust-2.2/"><span class="level-item">使用Rust编写操作系统 - 2.2 - 双重故障</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><script src="https://utteranc.es/client.js" repo="zlotus/comment" issue-term="pathname" label="some-issue-label" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/opm_sq.png" alt="子实"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">子实</p><p class="is-size-6 is-block">程序员</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>陕西/西安</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">79</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">23</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zlotus" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com/qinzishi"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/Zealot_uS"><i class="fab fa-twitter"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.zhihu.com/people/zlotus" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Diary/"><span class="level-start"><span class="level-item">Diary</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">65</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Shell/"><span class="level-start"><span class="level-item">Shell</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Coroutines/"><span class="tag">Coroutines</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">31</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenCV/"><span class="tag">OpenCV</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Operating-System/"><span class="tag">Operating System</span><span class="tag">21</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Paper/"><span class="tag">Paper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Raspberry-Pi/"><span class="tag">Raspberry Pi</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag">29</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TensorFlow/"><span class="tag">TensorFlow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tokio/"><span class="tag">Tokio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZMQ/"><span class="tag">ZMQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ctpn/"><span class="tag">ctpn</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/llama/"><span class="tag">llama</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macOS/"><span class="tag">macOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/obsidion/"><span class="tag">obsidion</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%A5%E8%AE%B0/"><span class="tag">日记</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E8%B0%88/"><span class="tag">杂谈</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B/"><span class="tag">编程</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%84%9A%E6%9C%AC/"><span class="tag">脚本</span><span class="tag">4</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a><p class="is-size-7"><span>&copy; 2024 子实</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>