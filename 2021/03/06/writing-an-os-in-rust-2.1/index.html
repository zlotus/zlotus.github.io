<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>使用Rust编写操作系统 - 2.1 - CPU异常 - 子实</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="子实"><meta name="msapplication-TileImage" content="/img/avatar-o.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="子实"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="使用Rust编写操作系统 - 2.1 - CPU异常"><meta property="og:type" content="article"><meta property="og:title" content="使用Rust编写操作系统 - 2.1 - CPU异常"><meta property="og:url" content="https://zlotus.github.io/2021/03/06/writing-an-os-in-rust-2.1/"><meta property="og:site_name" content="子实"><meta property="og:description" content="使用Rust编写操作系统 - 2.1 - CPU异常"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://os.phil-opp.com/cpu-exceptions/function-stack-frame.svg"><meta property="og:image" content="https://os.phil-opp.com/cpu-exceptions/exception-stack-frame.svg"><meta property="og:image" content="https://os.phil-opp.com/cpu-exceptions/qemu-breakpoint-exception.png"><meta property="article:published_time" content="2021-03-06T13:15:00.000Z"><meta property="article:modified_time" content="2021-03-06T13:15:00.000Z"><meta property="article:author" content="子实"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Operating System"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://os.phil-opp.com/cpu-exceptions/function-stack-frame.svg"><meta property="twitter:creator" content="@Zealot_uS"><meta property="twitter:site" content="Zealot_uS"><link rel="publisher" href="+LotusQin"><meta property="fb:admins" content="qinzishi"><meta property="fb:app_id" content="qinzishi"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zlotus.github.io/2021/03/06/writing-an-os-in-rust-2.1/"},"headline":"使用Rust编写操作系统 - 2.1 - CPU异常","image":["https://os.phil-opp.com/cpu-exceptions/qemu-breakpoint-exception.png"],"datePublished":"2021-03-06T13:15:00.000Z","dateModified":"2021-03-06T13:15:00.000Z","author":{"@type":"Person","name":"子实"},"publisher":{"@type":"Organization","name":"子实","logo":{"@type":"ImageObject","url":"https://zlotus.github.io/img/opm_sq.png"}},"description":"使用Rust编写操作系统 - 2.1 - CPU异常"}</script><link rel="icon" href="/img/avatar-o.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/2014/07/09/about-me/">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-06T13:15:00.000Z" title="3/6/2021, 9:15:00 PM">2021-03-06</time>发表</span><span class="level-item"><time dateTime="2021-03-06T13:15:00.000Z" title="3/6/2021, 9:15:00 PM">2021-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a></span><span class="level-item">44 分钟读完 (大约6647个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">使用Rust编写操作系统 - 2.1 - CPU异常</h1><div class="content"><article class="message message-immersive is-warning">
<div class="message-body">
<i class="fas fa-exclamation-triangle mr-2"></i>本文所有内容均为翻译，原文：<a target="_blank" rel="noopener" href="https://os.phil-opp.com/cpu-exceptions/">CPU Exceptions</a>；原项目：<a target="_blank" rel="noopener" href="https://os.phil-opp.com/">Writing an OS in Rust</a>
</div>
</article>

<p>CPU异常发生在多种错误场景中，如在访问无效的内存地址时或是在除零运算时。为了对错误作出反应，我们需要建立一个提供处理函数的中断描述符表。在本文的结尾，我们的内核将能够捕获断点异常并在处理后恢复正常运行。</p>
<span id="more"></span>

<p>这个博客是在<a target="_blank" rel="noopener" href="https://github.com/phil-opp/blog_os">GitHub</a>上公开开发的。如果你有任何问题或疑问，请在那里开一个issue。你也可以在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/cpu-exceptions/#comments">底部</a>留言。这篇文章的完整源代码可以在<a target="_blank" rel="noopener" href="https://github.com/phil-opp/blog_os/tree/post-05">post-05</a>分支中找到。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>异常，意味着当前执行的指令有问题。例如，如果当前指令试图除以0，则CPU会发出异常。发生异常时，CPU会中断其当前工作，并根据具体异常的类型，立即调用相应的异常处理函数。</p>
<p>在x86平台上，大概有20种不同的CPU异常类型。其中最重要的是：</p>
<ul>
<li><strong>页面错误</strong>：在执行非法的内存访问时将发生页面错误。例如，若当前指令试图从未映射的页面读取或试图向只读页面写入时。</li>
<li><strong>无效操作码</strong>：在当前指令无效时（例如，当我们尝试在不支持的旧CPU上使用较新的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE指令</a>时）将发生此异常。</li>
<li><strong>常规保护故障</strong>：这是异常最常见的诱因。它发生在各种访问冲突中，例如试图在用户级代码中执行特权指令或是向配置寄存器中保留字段进行写入。</li>
<li><strong>双重故障</strong>：发生异常时，CPU尝试调用相应的处理函数。如果<em>在调用异常处理函数时</em>又发生另一个异常，则CPU会引发双重故障异常。此外，当没有为某异常注册相应的处理函数时，也会引发这个异常。</li>
<li><strong>三重故障</strong>：如果在CPU尝试调用双重故障异常处理函数时又发生异常，则将引发致命的三重故障。我们无法捕捉或处理三重​​故障。大多数处理器通过复位并重新引导操作系统来对此故障作出反应。</li>
</ul>
<p>有关异常的完整列表，请查看<a target="_blank" rel="noopener" href="https://wiki.osdev.org/Exceptions">OSDev Wiki</a>。</p>
<h3 id="中断描述符表"><a href="#中断描述符表" class="headerlink" title="中断描述符表"></a>中断描述符表</h3><p>为了捕获和处理异常，我们必须建立一个所谓的<em>中断描述符表</em>(IDT)。在此表中，我们可以为每个CPU异常指定一个处理函数。硬件会直接使用此表，所以我们需要遵循预定义的格式。每个条目必须具有以下的16字节结构：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>u16</td>
<td>函数指针 [0:15]</td>
<td>处理函数指针的低(16)位。</td>
</tr>
<tr>
<td>u16</td>
<td>GDT 选择子</td>
<td><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Global_Descriptor_Table">全局描述符表</a>中的代码段的选择器</td>
</tr>
<tr>
<td>u16</td>
<td>选项字段</td>
<td>参见下表</td>
</tr>
<tr>
<td>u16</td>
<td>函数指针 [16:31]</td>
<td>处理函数（handler function)指针的中(16)位。</td>
</tr>
<tr>
<td>u32</td>
<td>函数指针 [32:63]</td>
<td>处理函数（handler function)指针的高(32)位。</td>
</tr>
<tr>
<td>u32</td>
<td>保留位</td>
<td></td>
</tr>
</tbody></table>
<p>选项字段具有以下格式：</p>
<table>
<thead>
<tr>
<th>位</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0-2</td>
<td>中断栈表索引</td>
<td>0：不换栈，1-7：当处理函数被调用时，切换到中断栈表的第n个栈。</td>
</tr>
<tr>
<td>3-7</td>
<td>保留位</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>0：中断门，1：陷阱门</td>
<td>若此位设置为0，则处理函数被调用的时，中断会被禁用。</td>
</tr>
<tr>
<td>9-11</td>
<td>必须为1</td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>必须为0</td>
<td></td>
</tr>
<tr>
<td>13‑14</td>
<td>特权等级描述符(DPL)</td>
<td>允许调用该处理函数的最小特权等级。</td>
</tr>
<tr>
<td>15</td>
<td>条目是否存在</td>
<td></td>
</tr>
</tbody></table>
<p>每个异常都有一个预定义的IDT索引。例如，无效操作码异常的表索引为6，而页面错误异常的表索引为14。因此，硬件可以为每个异常自动加载相应的IDT条目。 OSDev wiki中的<a target="_blank" rel="noopener" href="https://wiki.osdev.org/Exceptions">异常表</a>在”Vector nr.”列展示了所有异常的IDT索引。</p>
<p>发生异常时，CPU大致将执行以下操作：</p>
<ol>
<li>将某些寄存器压栈，包括指令指针和<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/FLAGS_register">RFLAGS</a>寄存器。（本文接下来将会用到这些值。）</li>
<li>从中断描述符表（IDT）中读取相应的条目。例如，发生页面错误时，CPU读取第14个条目。</li>
<li>检查是否存在该条目。若没有则引发双重故障。</li>
<li>如果该条目是中断门（第40位未置为1），则禁用硬件中断。</li>
<li>将指定的GDT选择器加载到CS段中。</li>
<li>跳转到指定的处理函数。</li>
</ol>
<p>现在不必担心第4步和第5步，我们将在以后的文章中了解全局描述符表和硬件中断。</p>
<h2 id="IDT类"><a href="#IDT类" class="headerlink" title="IDT类"></a>IDT类</h2><p>我们无需自己创建IDT类，可以直接使用<code>x86_64</code>crate的<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/idt/struct.InterruptDescriptorTable.html"><code>InterruptDescriptorTable</code>结构体</a>，看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">InterruptDescriptorTable</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> divide_by_zero: Entry&lt;HandlerFunc&gt;,</span><br><span class="line">    <span class="keyword">pub</span> debug: Entry&lt;HandlerFunc&gt;,</span><br><span class="line">    <span class="keyword">pub</span> non_maskable_interrupt: Entry&lt;HandlerFunc&gt;,</span><br><span class="line">    <span class="keyword">pub</span> breakpoint: Entry&lt;HandlerFunc&gt;,</span><br><span class="line">    <span class="keyword">pub</span> overflow: Entry&lt;HandlerFunc&gt;,</span><br><span class="line">    <span class="keyword">pub</span> bound_range_exceeded: Entry&lt;HandlerFunc&gt;,</span><br><span class="line">    <span class="keyword">pub</span> invalid_opcode: Entry&lt;HandlerFunc&gt;,</span><br><span class="line">    <span class="keyword">pub</span> device_not_available: Entry&lt;HandlerFunc&gt;,</span><br><span class="line">    <span class="keyword">pub</span> double_fault: Entry&lt;HandlerFuncWithErrCode&gt;,</span><br><span class="line">    <span class="keyword">pub</span> invalid_tss: Entry&lt;HandlerFuncWithErrCode&gt;,</span><br><span class="line">    <span class="keyword">pub</span> segment_not_present: Entry&lt;HandlerFuncWithErrCode&gt;,</span><br><span class="line">    <span class="keyword">pub</span> stack_segment_fault: Entry&lt;HandlerFuncWithErrCode&gt;,</span><br><span class="line">    <span class="keyword">pub</span> general_protection_fault: Entry&lt;HandlerFuncWithErrCode&gt;,</span><br><span class="line">    <span class="keyword">pub</span> page_fault: Entry&lt;PageFaultHandlerFunc&gt;,</span><br><span class="line">    <span class="keyword">pub</span> x87_floating_point: Entry&lt;HandlerFunc&gt;,</span><br><span class="line">    <span class="keyword">pub</span> alignment_check: Entry&lt;HandlerFuncWithErrCode&gt;,</span><br><span class="line">    <span class="keyword">pub</span> machine_check: Entry&lt;HandlerFunc&gt;,</span><br><span class="line">    <span class="keyword">pub</span> simd_floating_point: Entry&lt;HandlerFunc&gt;,</span><br><span class="line">    <span class="keyword">pub</span> virtualization: Entry&lt;HandlerFunc&gt;,</span><br><span class="line">    <span class="keyword">pub</span> security_exception: Entry&lt;HandlerFuncWithErrCode&gt;,</span><br><span class="line">    <span class="comment">// some fields omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些字段的类型为<code>idt::Entry&lt;F&gt;</code>，这是一个用于表示IDT条目字段的结构体（请参见上面的表格）。泛型参数F定义了预期的处理函数的类型。我们看到有的条目需要<code>HandlerFunc</code>，有的则需要<code>HandlerFuncWithErrCode</code>。而页面错误甚至有其自己的特殊类型：<code>PageFaultHandlerFunc</code>。</p>
<p>首先让我们看一下<code>HandlerFunc</code>类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">HandlerFunc</span></span> = <span class="keyword">extern</span> <span class="string">&quot;x86-interrupt&quot;</span> <span class="function"><span class="keyword">fn</span></span>(_: &amp;<span class="keyword">mut</span> InterruptStackFrame);</span><br></pre></td></tr></table></figure>

<p>这是<code>extern &quot;x86-interrupt&quot; fn</code>类型的别名。<code>extern</code>关键字定义了一个具有<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nomicon/ffi.html#foreign-calling-conventions">外部调用约定</a>的函数，最常见的是与C代码进行通信(<code>extern &quot;C&quot; fn</code>)的调用约定。不过，此处的<code>x86-interrupt</code>调用约定又是什么？</p>
<h2 id="中断调用约定"><a href="#中断调用约定" class="headerlink" title="中断调用约定"></a>中断调用约定</h2><p>异常与函数调用非常相似，都是CPU跳转到被调用函数的第一条指令并执行它。之后，CPU跳转到返回地址并继续执行父函数。</p>
<p>但是，异常和函数调用之间存在主要区别在于，函数调用是被编译器插入的<code>call</code>指令会主动调用的，而异常可能发生在任何指令中。为了了解这种差异的后果，我们需要更详细地研究函数调用。</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Calling_convention">调用约定</a>明确了函数调用的细节。例如，调用约定指定了函数参数的放置位置（例如，在寄存器中还是在栈中）以及如何返回结果。在x86_64的Linux上，以下规则适用于C函数（在<a target="_blank" rel="noopener" href="https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf">System V ABI</a>中指定）：</p>
<ul>
<li>前六个整型参数放在在寄存器<code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>rcx</code>、<code>r8</code>、<code>r9</code>中传递</li>
<li>其他参数放在栈上传递</li>
<li>结果放在<code>rax</code>和<code>rdx</code>上返回</li>
</ul>
<p>请注意，Rust不遵循C ABI（实际上<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rfcs/issues/600">甚至还没有Rust ABI</a>），因此这些规则仅适用于<code>extern &quot;C&quot; fn</code>声明的函数。</p>
<h3 id="Preserved寄存器与Scratch寄存器"><a href="#Preserved寄存器与Scratch寄存器" class="headerlink" title="Preserved寄存器与Scratch寄存器"></a>Preserved寄存器与Scratch寄存器</h3><p>调用约定将寄存器分为两种：<em>preserved</em>寄存器和<em>scratch</em>寄存器。</p>
<p>在函数调用过程中，preserved寄存器的值必须保持不变。因此，仅当<em>被调用函数</em>(“callee”)确定能够在返回前恢复寄存器原始值时，才可以写这些寄存器。因此，preserved寄存器称为<em>“被调用者保存寄存器”</em>(“callee-saved”)。一个常见用法是在函数开始时将这些寄存器保存在栈中，并在返回之前将其还原。</p>
<p>相比之下，被调用函数可以无限制地写<em>scratch</em> 寄存器。如果调用者想在函数调用期间保留scratch寄存器的值，则需要在函数调用之前进行备份和还原（如将其压入栈中）。因此，scratch寄存器是<em>“调用者保存寄存器”</em>(“caller-saved”)。</p>
<p>在x86_64上，C调用约定指定以下preserved和scratch寄存器：</p>
<table>
<thead>
<tr>
<th>preserved寄存器</th>
<th>scratch寄存器</th>
</tr>
</thead>
<tbody><tr>
<td><code>rbp</code>, <code>rbx</code>, <code>rsp</code>, <code>r12</code>, <code>r13</code>, <code>r14</code>, <code>r15</code></td>
<td><code>rax</code>, <code>rcx</code>, <code>rdx</code>, <code>rsi</code>, <code>rdi</code>, <code>r8</code>, <code>r9</code>, <code>r10</code>, <code>r11</code></td>
</tr>
<tr>
<td><em>被调用者保存</em></td>
<td><em>调用者保存</em></td>
</tr>
</tbody></table>
<p>编译器知道这些规则，因此会生成合适的代码。例如，大多数函数都以<code>push rbp</code>开始，即将<code>rbp</code>备份在栈上（因为它是被调用者保存的寄存器）。</p>
<h3 id="保存所有寄存器"><a href="#保存所有寄存器" class="headerlink" title="保存所有寄存器"></a>保存所有寄存器</h3><p>与函数调用不同，<em>任何</em>指令都可能发生异常。在大多数情况下，我们甚至在编译时都不知道生成的代码是否会导致异常。例如，编译器无法知道指令是否会导致栈溢出或页面错误。</p>
<p>由于我们不知道何时发生异常，我们也就无法提前备份任何寄存器。也就是说，调用约定不能以依赖于调用者保存的寄存器的行为作为异常处理程序，而是应该以保存<em>所有</em>寄存器的行为作为异常处理程序。<code>x86-interrupt</code>调用约定就是如此，因此它可以保证在函数返回时所有寄存器值都恢复到原始值。</p>
<p>注意，这并不意味着函数开始时会将所有寄存器都保存到栈中，实际上编译出的代码仅备份会被函数覆盖的寄存器。这样，可以为仅使用几个寄存器的短函数生成非常高效的代码。</p>
<h3 id="中断栈帧"><a href="#中断栈帧" class="headerlink" title="中断栈帧"></a>中断栈帧</h3><p>在正常的函数调用中（使用<code>call</code>指令），CPU在跳转到目标函数之前先将返回地址压栈。函数返回时（使用<code>ret</code>指令），CPU将返回地址弹栈并跳转到该地址。因此，普通函数调用的栈帧如下所示：</p>
<p><img src="https://os.phil-opp.com/cpu-exceptions/function-stack-frame.svg" alt="函数栈帧"></p>
<p>但是，对于异常和中断处理程序，仅将返回地址压栈是不够的，因为中断处理程序通常在不同的上下文中运行（如栈指针、CPU标志等）。在发生中断时，CPU执行以下步骤：</p>
<ol>
<li><strong>对齐栈指针</strong>：任何指令都可能发生中断，因此栈指针也可以是任何值。但是，某些CPU指令（例如某些SSE指令）要求栈指针在16字节边界上对齐，因此CPU在中断后立即执行此类对齐。</li>
<li><strong>切换栈</strong>（在某些情况下）：当CPU特权级别改变时（例如，在用户模式程序中发生CPU异常时），将发生切换栈动作。还可以使用所谓的<em>中断栈表</em>（将在下一篇文章中介绍）为特定的中断配置切换栈。</li>
<li><strong>压入旧栈指针</strong>：在发生中断时（对齐之前），CPU压入栈指针(<code>rsp</code>)和栈段(<code>ss</code>)寄存器的值。因此，从中断处理程序返回时，这可以恢复栈指针的原始值。</li>
<li><strong>压入和更新<code>RFLAGS</code>寄存器</strong>：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/FLAGS_register">RFLAGS</a>寄存器包含各种控制位和状态位。进入中断时，CPU修改一些位并将旧值压栈。</li>
<li><strong>压入指令指针</strong>：在跳转到中断处理程序功能之前，CPU先压入指令指针(<code>rip</code>)和代码段(<code>cs</code>)。这相当于普通函数调用时的返回地址压栈。</li>
<li><strong>压入错误码</strong>（对于某些异常）：对于某些特定的异常（例如页面错误），CPU压入一个错误码，用于描述异常原因。</li>
<li><strong>调用中断处理函数</strong>：CPU从IDT的相应字段读取中断处理函数的地址和段描述符。之后，通过将这些值加载到<code>rip</code>和<code>cs</code>寄存器中来调用中断处理函数。</li>
</ol>
<p>因此，<em>中断栈帧</em>如下所示：</p>
<p><img src="https://os.phil-opp.com/cpu-exceptions/exception-stack-frame.svg" alt="异常栈帧"></p>
<p>在<code>x86_64</code>crate中，中断栈帧由<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/idt/struct.InterruptStackFrame.html"><code>InterruptStackFrame</code></a>结构体表示。结构体被以<code>＆mut</code>的形式传递给中断处理函数，可用于获取异常原因相关信息。该结构体不包含错误码字段，因为只有少数异常会推送错误码。这些少数异常使用单独的<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/idt/type.HandlerFuncWithErrCode.html"><code>HandlerFuncWithErrCode</code></a>函数类型，该函数类型具有附加的<code>error_code</code>参数。</p>
<h3 id="后台细节"><a href="#后台细节" class="headerlink" title="后台细节"></a>后台细节</h3><p><code>x86-interrupt</code>调用约定是一个强大的抽象，它几乎隐藏了异常处理过程的所有杂乱细节。但是，有时了解幕后的执行细节会很有用。这是<code>x86-interrupt</code>调用约定要处理的事情的简短概述：</p>
<ul>
<li><strong>取回参数</strong>：大多数调用约定都希望参数在寄存器中传递。这对于异常处理程序是不可能的，因为在将参数备份到栈上之前，我们绝不能覆盖任何寄存器。而<code>x86-interrupt</code>调用约定知道这些参数已经以特定的偏移量存放在栈上了。</li>
<li><strong>使用<code>iretq</code>返回</strong>：中断栈帧与常规函数调用的栈帧完全不同，这使得我们无法通过常规的<code>ret</code>指令从中断处理函数中返回。相应的我们必须使用<code>iretq</code>指令。</li>
<li><strong>处理错误码</strong>：为某些异常而将错误码压栈会使事情变得更加复杂。这会更改栈的对齐方式（请参阅下一点），并且在需要返回前弹栈。<code>x86-interrupt</code>中断调用约定封装了这些复杂过程。但是，它并不知道哪个处理程序函数该用于哪个异常，因此它需要从函数参数的数量中推断出该信息。这意味着程序员仍然有责任为每个异常选择正确的处理函数类型。幸运的是，由<code>x86_64</code>crate定义的<code>InterruptDescriptorTable</code>类型可确保使用正确的函数类型。</li>
<li><strong>栈对齐</strong>：有些指令（尤其是SSE指令）需要16字节的栈对齐。CPU会在发生异常时确保这种对齐，但是某些异常会在将错误码压栈后再次破坏对齐。此情况发生时，<code>x86-interrupt</code>调用约定会通过重新对齐栈来解决此问题。</li>
</ul>
<p>如果你对更多细节感兴趣：我们还有一系列文章，这些文章解释了如何使用<a target="_blank" rel="noopener" href="https://os.phil-opp.com/cpu-exceptions/#too-much-magic">文末</a>的<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rfcs/blob/master/text/1201-naked-fns.md">裸函数</a>进行异常处理。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>现在，我们了解了中断的原理，是时候在内核中处理CPU异常了。我们将从在<code>src/interrupts.rs</code>中创建一个新的中断模块开始，该模块首先新建一个<code>init_idt</code>函数，用于创建一个新的<code>InterruptDescriptorTable</code>实例：</p>
<figure class="highlight rust"><figcaption><span>in src/lib.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> interrupts;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><figcaption><span>in src/interrupts.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> x86_64::structures::idt::InterruptDescriptorTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">init_idt</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> idt = InterruptDescriptorTable::new();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以添加异常处理函数了，首先为<a target="_blank" rel="noopener" href="https://wiki.osdev.org/Exceptions#Breakpoint">断点异常</a>添加处理程序。断点异常是测试异常处理函数的极佳案例。它的唯一用途是在执行断点指令<code>int3</code>时临时暂停程序。</p>
<p>断点异常通常在调试器（debugger）中使用：当用户设置断点时，调试器用<code>int3</code>指令覆盖断点行的原指令，以便在CPU执行到该行时抛出断点异常。当用户想要继续执行程序时，调试器将<code>int3</code>指令再次替换为原指令，然后继续执行程序。有关更多详细信息，请参见<a target="_blank" rel="noopener" href="https://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints"><em>“调试器的工作方式”</em></a>系列。</p>
<p>在我们的例子中，并不需要覆盖任何指令，只需要在执行断点指令时打印一条消息，然后继续执行该程序。因此，让我们创建一个简单的<code>breakpoint_handler</code>函数并将其添加到IDT中：</p>
<figure class="highlight rust"><figcaption><span>in src/interrupts.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> x86_64::structures::idt::&#123;InterruptDescriptorTable, InterruptStackFrame&#125;;</span><br><span class="line"><span class="keyword">use</span> crate::println;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">init_idt</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> idt = InterruptDescriptorTable::new();</span><br><span class="line">    idt.breakpoint.set_handler_fn(breakpoint_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;x86-interrupt&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">breakpoint_handler</span></span>(</span><br><span class="line">    stack_frame: &amp;<span class="keyword">mut</span> InterruptStackFrame)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;EXCEPTION: BREAKPOINT\n&#123;:#?&#125;&quot;</span>, stack_frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的处理程序仅输出一条消息，并使用pretty-prints样式打印中断栈帧以提升可读性。</p>
<p>尝试对其进行编译会发生以下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error[E0658]: x86-interrupt ABI is experimental and subject to change (see issue <span class="comment">#40180)</span></span><br><span class="line">  --&gt; src/main.rs:53:1</span><br><span class="line">   |</span><br><span class="line">53 | / extern <span class="string">&quot;x86-interrupt&quot;</span> fn breakpoint_handler(stack_frame: &amp;mut InterruptStackFrame) &#123;</span><br><span class="line">54 | |     println!(<span class="string">&quot;EXCEPTION: BREAKPOINT\n&#123;:#?&#125;&quot;</span>, stack_frame);</span><br><span class="line">55 | | &#125;</span><br><span class="line">   | |_^</span><br><span class="line">   |</span><br><span class="line">   = <span class="built_in">help</span>: add <span class="comment">#![feature(abi_x86_interrupt)] to the crate attributes to enable</span></span><br></pre></td></tr></table></figure>

<p>发生此错误的原因是<code>x86-interrupt</code>调用约定这一特性仍然处于开发状态，还不稳定。如果一定要使用该特性，则必须通过在<code>lib.rs</code>顶部显示的添加<code>#![feature(abi_x86_interrupt)]</code>。</p>
<h3 id="加载IDT"><a href="#加载IDT" class="headerlink" title="加载IDT"></a>加载IDT</h3><p>我们需要使用<a target="_blank" rel="noopener" href="https://www.felixcloutier.com/x86/lgdt:lidt"><code>lidt</code></a>指令让CPU加载新建的中断描述符表。<code>x86_64</code>crate的<code>InterruptDescriptorTable</code>结构体将该指令封装为<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/idt/struct.InterruptDescriptorTable.html#method.load"><code>load</code></a>方法。让我们尝试使用它：</p>
<figure class="highlight rust"><figcaption><span>in src/interrupts.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">init_idt</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> idt = InterruptDescriptorTable::new();</span><br><span class="line">    idt.breakpoint.set_handler_fn(breakpoint_handler);</span><br><span class="line">    idt.load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时编译将出现以下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error: `idt` does not live long enough</span><br><span class="line">  --&gt; src/interrupts/mod.rs:43:5</span><br><span class="line">   |</span><br><span class="line">43 |     idt.load();</span><br><span class="line">   |     ^^^ does not live long enough</span><br><span class="line">44 | &#125;</span><br><span class="line">   | - borrowed value only lives until here</span><br><span class="line">   |</span><br><span class="line">   = note: borrowed value must be valid <span class="keyword">for</span> the static lifetime...</span><br></pre></td></tr></table></figure>

<p>查看<code>load</code>方法的文档可知，调用该方法的对象应为<code>＆&#39;static self</code>，即该引用变量需要在程序运行时的整个生命周期中保持有效。这是因为CPU在每次中断时都会访问该表，直到我们加载了不同的IDT。因此，使用任何比<code>&#39;static</code>短的生命周期都可能导致“析构后使用”的错误。</p>
<p>而这正是此编译错误的原因。我们的<code>idt</code>创建在栈上，仅在<code>init</code>函数内部有效。该函数结束后，栈空间将重新分配给其他函数，因此CPU可能会将栈空间中的随机内容当做IDT。幸运的是，<code>InterruptDescriptorTable::load</code>方法在其函数定义中声明了生命周期要求，于是Rust编译器能够在编译时防止这种可能的错误。</p>
<p>要解决这个编译错误，我们需要将<code>idt</code>存储在具有<code>&#39;static</code>生命周期的地方。为此，我们通常可以使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a>为IDT在堆上分配空间，再将其转换为<code>&#39;static</code>引用，但是由于我们正在编写OS内核，因此目前并没有堆可用。</p>
<p>作为替代方案，我们可以尝试将IDT存储为<code>static</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> IDT: InterruptDescriptorTable = InterruptDescriptorTable::new();</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">init_idt</span></span>() &#123;</span><br><span class="line">    IDT.breakpoint.set_handler_fn(breakpoint_handler);</span><br><span class="line">    IDT.load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这里有一个问题：静态变量是不可变的，因此我们并不能在<code>init</code>函数中修改断点条目。通常可以通过使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/1.30.0/book/second-edition/ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable"><code>static mut</code></a>解决此问题：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> IDT: InterruptDescriptorTable = InterruptDescriptorTable::new();</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">init_idt</span></span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        IDT.breakpoint.set_handler_fn(breakpoint_handler);</span><br><span class="line">        IDT.load();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然该方法可以通过编译，但这一用法极为罕见。因为<code>static mut</code>变量非常容易发生数据竞争，导致我们只能在<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/1.30.0/book/second-edition/ch19-01-unsafe-rust.html#unsafe-superpowers"><code>unsafe</code>块</a>中进行对该变量的访问。</p>
<h3 id="使用惰性static救场"><a href="#使用惰性static救场" class="headerlink" title="使用惰性static救场"></a>使用惰性static救场</h3><p>幸运的是我们有<code>lazy_static</code>宏。相较于普通静态变量在编译时求值，该宏可以让静态变量在第一次使用时才执行初始化。因此，我们几乎可以在该宏的初始化块中执行任何操作，甚至可以读取运行时的值。</p>
<p>在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/vga-text-mode/#lazy-statics">为VGA文本缓冲区创建抽象</a>时，我们就导入<code>lazy_static</code>crate了，这里可以直接使用<code>lazy_static!</code>宏来创建惰性静态IDT：</p>
<figure class="highlight rust"><figcaption><span>in src/interrupts.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> IDT: InterruptDescriptorTable = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> idt = InterruptDescriptorTable::new();</span><br><span class="line">        idt.breakpoint.set_handler_fn(breakpoint_handler);</span><br><span class="line">        idt</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">init_idt</span></span>() &#123;</span><br><span class="line">    IDT.load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>留意此处是如何解决使用<code>unsafe</code>块问题的。<code>lazy_static!</code>宏实际上在后台也使用了<code>unsafe</code>块，只是将其封装抽象成了安全接口对外提供。</p>
<h3 id="运行起来"><a href="#运行起来" class="headerlink" title="运行起来"></a>运行起来</h3><p>让异常处理在内核中起作用的最后一步是在<code>main.rs</code>中调用<code>init_idt</code>函数。这里我们不选择直接调用该函数，而选择在<code>lib.rs</code>中引入了一个通用的总初始化函数<code>init</code>：</p>
<figure class="highlight rust"><figcaption><span>in src/lib.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">init</span></span>() &#123;</span><br><span class="line">    interrupts::init_idt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这个函数，我们便可以将初始化例程中各种操作放置于此，这样就能够在<code>main.rs</code>、<code>lib.rs</code>和集成测试中的不同<code>_start</code>函数之间共享这些例程。</p>
<p>现在，我们可以更新<code>main.rs</code>的<code>_start</code>函数以调用<code>init</code>，然后触发断点异常：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>() -&gt; ! &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello World&#123;&#125;&quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    blog_os::init(); <span class="comment">// new</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// invoke a breakpoint exception</span></span><br><span class="line">    x86_64::instructions::interrupts::int3(); <span class="comment">// new</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">    <span class="meta">#[cfg(test)]</span></span><br><span class="line">    test_main();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;It did not crash!&quot;</span>);</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们在QEMU中运行它（使用<code>cargo run</code>）时，将看到以下内容：</p>
<p><img src="https://os.phil-opp.com/cpu-exceptions/qemu-breakpoint-exception.png" alt="QEMU断点异常"></p>
<p>成功了！CPU成功调用了我们的断点处理程序，该断点处理程序将打印消息，然后返回到<code>_start</code>函数，继续打印出<code>It did not crash!</code>。</p>
<p>我们看到，发生异常时，中断栈帧会告诉我们指令指针和栈指针。在调试未预期的异常时，此信息将非常有用。</p>
<h3 id="添加测试"><a href="#添加测试" class="headerlink" title="添加测试"></a>添加测试</h3><p>让我们创建一个测试，以确保上述操作持续有效。首先，我们更新<code>_start</code>函数以也调用<code>init</code>：</p>
<figure class="highlight rust"><figcaption><span>in src/lib.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Entry point for `cargo test`</span></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>() -&gt; ! &#123;</span><br><span class="line">    init();      <span class="comment">// new</span></span><br><span class="line">    test_main();</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请记住，运行<code>cargo test --lib</code>时才会使用此<code>_start</code>函数，因为Rust的<code>lib.rs</code>测试完全独立于<code>main.rs</code>。在运行测试之前，我们需要在此处调用<code>init</code>来设置IDT。</p>
<p>现在我们可以创建一个<code>test_breakpoint_exception</code>测试：</p>
<figure class="highlight rust"><figcaption><span>in src/interrupts.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test_case]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_breakpoint_exception</span></span>() &#123;</span><br><span class="line">    <span class="comment">// invoke a breakpoint exception</span></span><br><span class="line">    x86_64::instructions::interrupts::int3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该测试调用<code>int3</code>函数来触发断点异常。通过检查之后执行是否继续，我们可以验证断点处理程序是否正常运行。</p>
<p>你可以通过运行<code>cargo test</code>（执行所有测试）或<code>cargo test --lib</code>（仅执行<code>lib.rs</code>及其模块测试）来尝试此新测试。在输出中应该看到以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blog_os::interrupts::test_breakpoint_exception...	[ok]</span><br></pre></td></tr></table></figure>

<h2 id="使用太多奇妙魔法了吗？"><a href="#使用太多奇妙魔法了吗？" class="headerlink" title="使用太多奇妙魔法了吗？"></a>使用太多奇妙魔法了吗？</h2><p><code>x86-interrupt</code>调用约定和<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/idt/struct.InterruptDescriptorTable.html"><code>InterruptDescriptorTable</code></a>类型使异常处理过程相对简单明了。如果这对你来说太神奇了，而你又希望了解异常处理的所有细节，可以继续阅读我们的<a target="_blank" rel="noopener" href="https://os.phil-opp.com/edition-1/extra/naked-exceptions/">“使用裸函数处理异常”</a>系列文章，这些文章展示了如何在不使用<code>x86-interrupt</code>调用约定的情况下处理异常，文章还创建了自己的IDT类型。从现在看来，这些旧文章介绍了<code>x86-interrupt</code>调用约定和<code>x86_64</code>crate出现之前的主要异常处理方法。请注意，这些帖子基于此博客的<a target="_blank" rel="noopener" href="https://os.phil-opp.com/edition-1/">第一版</a>，可能已过时。</p>
<h2 id="下期预告"><a href="#下期预告" class="headerlink" title="下期预告"></a>下期预告</h2><p>我们已经成功捕获了第一个异常并从中返回了！下一步是确保你能跟捕获所有异常，因为未捕获的异常会导致致命的<a target="_blank" rel="noopener" href="https://wiki.osdev.org/Triple_Fault">三重故障</a>，从而导致系统重置。下一篇文章将要解释如何通过正确捕获<a target="_blank" rel="noopener" href="https://wiki.osdev.org/Double_Fault#Double_Fault">双重故障</a>来避免这种情况的发生。</p>
<h2 id="支持本项目"><a href="#支持本项目" class="headerlink" title="支持本项目"></a>支持本项目</h2><p>创建和<a target="_blank" rel="noopener" href="https://os.phil-opp.com/status-update/">维护</a>这个博客和相关库是一项繁重的工作，但我真的很喜欢。通过支持我，您可以让我在新内容、新功能和持续维护上投入更多时间。</p>
<p>支持我的最好方式是<a target="_blank" rel="noopener" href="https://github.com/sponsors/phil-opp">在GitHub上赞助我</a>，因为他们不收取任何中间费用。如果你喜欢其他平台，我也有<a target="_blank" rel="noopener" href="https://www.patreon.com/phil_opp">Patreon</a>和<a target="_blank" rel="noopener" href="https://donorbox.org/phil-opp">Donorbox</a>账户。后者是最灵活的，因为它支持多种货币和一次性捐款。</p>
<p>感谢您的支持！</p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Rust/">Rust</a><a class="link-muted mr-2" rel="tag" href="/tags/Operating-System/">Operating System</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatpay.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/03/15/writing-an-os-in-rust-2.2/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">使用Rust编写操作系统 - 2.2 - 双重故障</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/03/06/writing-an-os-in-rust-1.4/"><span class="level-item">使用Rust编写操作系统 - 1.4 - 测试</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><script src="https://utteranc.es/client.js" repo="zlotus/comment" issue-term="pathname" label="some-issue-label" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/opm_sq.png" alt="子实"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">子实</p><p class="is-size-6 is-block">程序员</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>陕西/西安</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">80</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">23</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zlotus" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com/qinzishi"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/Zealot_uS"><i class="fab fa-twitter"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.zhihu.com/people/zlotus" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Diary/"><span class="level-start"><span class="level-item">Diary</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">66</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Shell/"><span class="level-start"><span class="level-item">Shell</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Coroutines/"><span class="tag">Coroutines</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">32</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenCV/"><span class="tag">OpenCV</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Operating-System/"><span class="tag">Operating System</span><span class="tag">21</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Paper/"><span class="tag">Paper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Raspberry-Pi/"><span class="tag">Raspberry Pi</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag">29</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TensorFlow/"><span class="tag">TensorFlow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tokio/"><span class="tag">Tokio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZMQ/"><span class="tag">ZMQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ctpn/"><span class="tag">ctpn</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/llama/"><span class="tag">llama</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macOS/"><span class="tag">macOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/obsidion/"><span class="tag">obsidion</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%A5%E8%AE%B0/"><span class="tag">日记</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E8%B0%88/"><span class="tag">杂谈</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B/"><span class="tag">编程</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%84%9A%E6%9C%AC/"><span class="tag">脚本</span><span class="tag">4</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a><p class="is-size-7"><span>&copy; 2024 子实</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>