<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>使用Rust编写操作系统 - 1.4 - 测试 - 子实</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="子实"><meta name="msapplication-TileImage" content="/img/avatar-o.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="子实"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="使用Rust编写操作系统 - 1.4 - 测试"><meta property="og:type" content="article"><meta property="og:title" content="使用Rust编写操作系统 - 1.4 - 测试"><meta property="og:url" content="https://zlotus.github.io/2021/03/06/writing-an-os-in-rust-1.4/"><meta property="og:site_name" content="子实"><meta property="og:description" content="使用Rust编写操作系统 - 1.4 - 测试"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://os.phil-opp.com/testing/qemu-test-runner-output.png"><meta property="og:image" content="https://os.phil-opp.com/testing/qemu-failed-test.png"><meta property="article:published_time" content="2021-03-06T13:15:00.000Z"><meta property="article:modified_time" content="2021-03-06T13:15:00.000Z"><meta property="article:author" content="子实"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Operating System"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://os.phil-opp.com/testing/qemu-test-runner-output.png"><meta property="twitter:creator" content="@Zealot_uS"><meta property="twitter:site" content="Zealot_uS"><link rel="publisher" href="+LotusQin"><meta property="fb:admins" content="qinzishi"><meta property="fb:app_id" content="qinzishi"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zlotus.github.io/2021/03/06/writing-an-os-in-rust-1.4/"},"headline":"使用Rust编写操作系统 - 1.4 - 测试","image":["https://os.phil-opp.com/testing/qemu-test-runner-output.png","https://os.phil-opp.com/testing/qemu-failed-test.png"],"datePublished":"2021-03-06T13:15:00.000Z","dateModified":"2021-03-06T13:15:00.000Z","author":{"@type":"Person","name":"子实"},"publisher":{"@type":"Organization","name":"子实","logo":{"@type":"ImageObject","url":"https://zlotus.github.io/img/opm_sq.png"}},"description":"使用Rust编写操作系统 - 1.4 - 测试"}</script><link rel="icon" href="/img/avatar-o.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/2014/07/09/about-me/">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-06T13:15:00.000Z" title="3/6/2021, 9:15:00 PM">2021-03-06</time>发表</span><span class="level-item"><time dateTime="2021-03-06T13:15:00.000Z" title="3/6/2021, 9:15:00 PM">2021-03-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a></span><span class="level-item">1 小时读完 (大约11212个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">使用Rust编写操作系统 - 1.4 - 测试</h1><div class="content"><article class="message message-immersive is-warning">
<div class="message-body">
<i class="fas fa-exclamation-triangle mr-2"></i>本文所有内容均为翻译，原文：<a target="_blank" rel="noopener" href="https://os.phil-opp.com/testing/">Testing</a>；原项目：<a target="_blank" rel="noopener" href="https://os.phil-opp.com/">Writing an OS in Rust</a>
</div>
</article>

<p>本篇文章将探讨在<code>no_std</code>环境中，可执行文件的单元和集成测试。我们将利用Rust对自定义测试框架的支持来在内核中执行测试函数。为了输出QEMU的结果，我们将使用QEMU和<code>bootimage</code>工具的其他功能。</p>
<span id="more"></span>

<p>这个博客是在<a target="_blank" rel="noopener" href="https://github.com/phil-opp/blog_os">GitHub</a>上公开开发的。如果你有任何问题或疑问，请在那里开一个issue。你也可以在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/testing/#comments">底部</a>留言。这篇文章的完整源代码可以在<a target="_blank" rel="noopener" href="https://github.com/phil-opp/blog_os/tree/post-04">post-04</a>分支中找到。</p>
<h2 id="需要了解的内容"><a href="#需要了解的内容" class="headerlink" title="需要了解的内容"></a>需要了解的内容</h2><p>本文取代了（现已废弃的）<a target="_blank" rel="noopener" href="https://os.phil-opp.com/unit-testing/">单元测试</a>和<a target="_blank" rel="noopener" href="https://os.phil-opp.com/integration-tests/">集成测试</a>这两篇文章。本文将假设你在2019-04-27之后阅读量了<a target="_blank" rel="noopener" href="https://os.phil-opp.com/minimal-rust-kernel/">A Minimal Rust Kernel</a>一文。目的主要是为了添加<code>.cargo/config.toml</code>文件，<a target="_blank" rel="noopener" href="https://os.phil-opp.com/minimal-rust-kernel/#set-a-default-target">设置了默认的编译目标</a>，并<a target="_blank" rel="noopener" href="https://os.phil-opp.com/minimal-rust-kernel/#using-cargo-run">设置了<code>cargo run</code>的<code>runner</code>参数</a>。</p>
<h3 id="Rust中的测试"><a href="#Rust中的测试" class="headerlink" title="Rust中的测试"></a>Rust中的测试</h3><p>Rust有一个<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch11-00-testing.html">内置的测试框架</a>，它能够在不设置任何东西的情况下执行单元测试。只要创建一个通过断言检查一些结果的函数，并在函数前添加<code>#[test]</code>属性，<code>cargo test</code>就会自动发现并执行该crate中的所有测试函数。</p>
<p>不幸的是，对于像我们的内核这样<code>no_std</code>程序来说，就比较复杂了。问题在于Rust的测试框架隐式地使用了内置的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/test/index.html"><code>test</code></a>库，而测试库依赖于标准库。这意味着我们不能为<code>#[no_std]</code>的内核使用默认的测试框架。</p>
<p>当我们尝试在项目中运行<code>cargo test</code>时，可以看到以下报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; cargo <span class="built_in">test</span></span><br><span class="line">   Compiling blog_os v0.1.0 (/…/blog_os)</span><br><span class="line">error[E0463]: can<span class="string">&#x27;t find crate for `test`</span></span><br></pre></td></tr></table></figure>

<p>由于<code>test</code>crate依赖于标准库，所以它不能用于我们的裸机目标。虽然将<code>test</code>crate移植到<code>#[no_std]</code>环境中是<a target="_blank" rel="noopener" href="https://github.com/japaric/utest">可行的</a>，但这是非常不稳定的，需要一些黑科技，比如重新定义<code>panic</code>宏。</p>
<h3 id="自定义测试框架"><a href="#自定义测试框架" class="headerlink" title="自定义测试框架"></a>自定义测试框架</h3><p>幸运的是，Rust支持通过”unstable”的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/unstable-book/language-features/custom-test-frameworks.html"><code>custom_test_frameworks</code></a>特性替换默认的测试框架。这个特性下，测试不需要外部库，因此也可以在<code>#[no_std]</code>环境中工作。它的工作原理是收集所有带有<code>#[test_case]</code>属性的函数，然后以测试列表为参数调用用户指定的runner函数。因此，它给了实现者对测试过程尽可能大的控制权。</p>
<p>与默认的测试框架相比，缺少许多默认测试框架具有的高级功能，比如<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch11-01-writing-tests.html#checking-for-panics-with-should_panic"><code>should_panic</code>测试</a>就是不可用的。因此，如果需要的话，要由实现者自己实现这样的功能。这对我们来说是很理想的，因为我们有一个非常特殊的执行环境，在这种环境下，这种高级特性的默认实现可能本来就无法正常工作。例如，<code>#[should_panic]</code>属性依赖于栈展开来捕获panic，但我们恰好禁用了栈展开。</p>
<p>要为我们的内核实现一个自定义测试框架，我们在<code>main.rs</code>中添加以下内容：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(custom_test_frameworks)]</span></span><br><span class="line"><span class="meta">#![test_runner(crate::test_runner)]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_runner</span></span>(tests: &amp;[&amp;<span class="keyword">dyn</span> <span class="built_in">Fn</span>()]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Running &#123;&#125; tests&quot;</span>, tests.len());</span><br><span class="line">    <span class="keyword">for</span> test <span class="keyword">in</span> tests &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的runner只是打印一个简短的调试信息，然后调用列表中的每个测试函数。参数类型<code>&amp;[&amp;dyn Fn()]</code>，是由<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn()</code>trait</a>这一<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/1.30.0/book/first-edition/trait-objects.html">trait对象</a>的引用组成的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.slice.html">slice</a>。它基本上是一个可以像函数一样调用的类型的引用，所组成的列表。由于这些函数对于非测试用途的cargo run是无用的，所以我们使用<code>#[cfg(test)]</code>属性只在测试中运行它。</p>
<p>现在运行<code>cargo test</code>时，我们看到运行成功了（如果没有成功，请看下面的注意）。然而，我们仍然看到的是”Hello World”，而不是<code>test_runner</code>的消息。原因是<code>_start</code>函数仍然被用作入口点。自定义测试框架功能会生成一个调用<code>test_runner</code>的<code>main</code>函数，但这个函数被忽略了，因为我们使用了#[no_main]属性，并提供了我们自己的入口点。</p>
<article class="message is-warning"><div class="message-header">
<p>注意</p>
</div><div class="message-body">
<p><code>unstable.build-std</code>配置项仅在2020-07-15之后的Rust nightly中提供</p>
</div></article>

<p>目前在cargo中存在一个bug，在某些情况下会导致<code>cargo test</code>中出现”duplicate lang item”的错误。这是由于在<code>Cargo.toml</code>中将某个配置文件设置为了<code>panic = &quot;abort&quot;</code>。尝试删除它，然后<code>cargo test</code>应该就可以正常工作了。更多信息请参见这个<a target="_blank" rel="noopener" href="https://github.com/rust-lang/cargo/issues/7359"><code>cargo issue</code></a>。</p>
<p>为了解决这个问题，我们首先需要通过<code>reexport_test_harness_main</code>属性将生成的函数名称改为与<code>main</code>不同的名称。然后我们就可以从我们的<code>_start</code>函数中调用重命名的函数了。</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![reexport_test_harness_main = <span class="meta-string">&quot;test_main&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>() -&gt; ! &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello World&#123;&#125;&quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[cfg(test)]</span></span><br><span class="line">    test_main();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将测试框架入口函数的名称设置为<code>test_main</code>，并在<code>_start</code>入口点调用它。我们使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/1.30.0/book/first-edition/conditional-compilation.html">条件编译</a>，只在测试环境中添加对<code>test_main</code>的调用，因为该函数不会在正常cargo run时生成。</p>
<p>当我们现在执行<code>cargo test</code>时，就能在屏幕上看到<code>test_runner</code>打印的”Running 0 tests”。现在就可以创建第一个测试函数了：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test_case]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">trivial_assertion</span></span>() &#123;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;trivial assertion... &quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;[ok]&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在运行<code>cargo test</code>时，便可以看到以下输出：</p>
<p><img src="https://os.phil-opp.com/testing/qemu-test-runner-output.png" alt="QEMU中打印&quot;Hello World!&quot;, &quot;Running 1 tests&quot;, &quot;trivial assertion... [ok]&quot;"></p>
<p>传递给<code>test_runner</code>函数的<code>test</code> slice现在包含了对<code>trivial_assertion</code>函数的引用。由<code>trivial assertion... [ok]</code>在屏幕上的输出，我们看到测试被调用，并且测试通过了。</p>
<p>执行完测试后，<code>test_runner</code>结束并回到到<code>test_main</code>函数，而这个函数又返回到<code>_start</code>入口点函数。在<code>_start</code>结束前，程序进入了一个死循环，因为入口点函数不允许返回。这是个问题，因为我们希望<code>cargo test</code>在运行完所有测试后能够自动退出。</p>
<h2 id="退出QEMU"><a href="#退出QEMU" class="headerlink" title="退出QEMU"></a>退出QEMU</h2><p>现在，<code>_start</code>函数最后是一个死循环，因此，需要在每次执行<code>cargo test</code>时手动关闭QEMU。这很麻烦，因为我们希望在没有用户交互的脚本中运行<code>cargo test</code>。最直观的解决方案是实现一种适当的方式来关闭操作系统。但是实现这个过程比较复杂，因为它需要实现对<a target="_blank" rel="noopener" href="https://wiki.osdev.org/APM">APM</a>或<a target="_blank" rel="noopener" href="https://wiki.osdev.org/ACPI">ACPI</a>电源管理标准的支持。</p>
<p>幸运的是，还有一条捷径。QEMU支持一个特殊的<code>isa-debug-exit</code>设备, 它提供了一个从访客系统中退出QEMU的简单方法。要启用该设备，则需要给QEMU传递一个<code>-device</code>参数。这可以通过在<code>Cargo.toml</code>中添加一个<code>package.metadata.bootimage.test-args</code>配置键来实现：</p>
<figure class="highlight toml"><figcaption><span>in Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package.metadata.bootimage]</span></span><br><span class="line"><span class="attr">test-args</span> = [<span class="string">&quot;-device&quot;</span>, <span class="string">&quot;isa-debug-exit,iobase=0xf4,iosize=0x04&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><code>bootimage runner</code>将为所有可执行测试附加<code>test-args</code>参数到默认QEMU命令中。而对于正常的<code>cargo run</code>，这些参数会被忽略。</p>
<p>连同设备名(<code>isa-debug-exit</code>)，我们传递了<code>iobase</code>和<code>iosize</code>两个参数，这两个参数指定了设备可以从内核到达的I/O端口。</p>
<h3 id="I-O端口"><a href="#I-O端口" class="headerlink" title="I/O端口"></a>I/O端口</h3><p>对于x86架构，CPU与外设硬件之间的通信有两种不同的方法，即<strong>内存映射I/O</strong>和<strong>端口映射I/O</strong>。我们已经使用内存映射I/O通过内存地址<code>0xb8000</code>来访问<a target="_blank" rel="noopener" href="https://os.phil-opp.com/vga-text-mode/">VGA文本缓冲区</a>。这个地址不是映射到主存，而是映射到VGA设备上的一些内存。</p>
<p>与内存映射I/O不同，端口映射的I/O使用单独的I/O总线进行通信。每个连接的外设都有一个或多个端口号。为了与这样的I/O端口进行通信，有一种特殊的CPU指令，叫做<code>in</code>和<code>out</code>，这些指令需要指定一个端口号和一个字节数据作为参数（这些指令也有一些变体，允许发送一个<code>u16</code>或<code>u32</code>）。</p>
<p><code>isa-debug-exit</code>设备使用端口映射的I/O。<code>iobase</code>参数指定设备的端口地址（<code>0xf4</code>是x86的IO总线上的一个<a target="_blank" rel="noopener" href="https://wiki.osdev.org/I/O_Ports#The_list">一般不使用的端口</a>），<code>iosize</code>指定端口大小（<code>0x04</code>表示4个字节）。</p>
<h3 id="使用退出设备"><a href="#使用退出设备" class="headerlink" title="使用退出设备"></a>使用退出设备</h3><p><code>isa-debug-exit</code>设备的功能非常简单。当一个值被写入<code>iobase</code>所指定的I/O端口时，它会使QEMU以<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Exit_status">退出状态</a><code>(value &lt;&lt; 1) | 1</code>退出。因此，当我们向该端口写入<code>0</code>时，QEMU将以退出状态<code>(0 &lt;&lt; 1) | 1 = 1</code>退出，而当我们向该端口写入<code>1</code>时，将以退出状态<code>(1 &lt;&lt; 1) | 1 = 3</code>退出。</p>
<p>我们不需要手动调用<code>in</code>和<code>out</code>汇编指令，直接使用<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/"><code>x86_64</code></a> crate提供的抽象。在<code>Cargo.toml</code>的<code>dependencies</code>部分添加对该crate的依赖即可。</p>
<figure class="highlight rust"><figcaption><span>in Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">x86_64 = <span class="string">&quot;0.13.2&quot;</span></span><br></pre></td></tr></table></figure>

<p>现在我们可以使用crate提供的<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/instructions/port/struct.Port.html"><code>Port</code></a>类型来创建<code>exit_qemu</code>函数了：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span></span><br><span class="line"><span class="meta">#[repr(u32)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">QemuExitCode</span></span> &#123;</span><br><span class="line">    Success = <span class="number">0x10</span>,</span><br><span class="line">    Failed = <span class="number">0x11</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">exit_qemu</span></span>(exit_code: QemuExitCode) &#123;</span><br><span class="line">    <span class="keyword">use</span> x86_64::instructions::port::Port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> port = Port::new(<span class="number">0xf4</span>);</span><br><span class="line">        port.write(exit_code <span class="keyword">as</span> <span class="built_in">u32</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数在<code>0xf4</code>上创建了一个新<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/instructions/port/struct.Port.html"><code>Port</code></a>对象，作为<code>isa-debug-exit</code>设备的<code>iobase</code>。然后将参数退出代码写入该端口。我们使用<code>u32</code>是因为我们指定了<code>isa-debug-exit</code>设备的<code>iosize</code>为<code>4</code>字节。这两种操作都是非安全的，因为向I/O端口写入数据可能会导致不可预知的结果。</p>
<p>为了指定退出状态，我们创建了一个<code>QemuExitCode</code>枚举类型。想要达到的效果是，如果所有的测试都成功了就用成功退出代码退出，否则就用失败退出代码退出。该枚举被标记为<code>#[repr(u32)]</code>，这会强制编译器用一个<code>u32</code>整型来表示该枚举变量。我们用退出码<code>0x10</code>表示成功，<code>0x11</code>表示失败。实际的退出代码并不太重要，只要不与QEMU的默认退出代码冲突即可。例如，使用退出码<code>0</code>表示成功并不是一个好主意，因为它在转换后变成了<code>(0 &lt;&lt; 1) | 1 = 1</code>，这就是QEMU运行失败时的默认退出码，这将导致我们无法区分QEMU错误和测试运行成功。</p>
<p>现在就可以更新我们的<code>test_runner</code>了，在所有测试运行后会退出QEMU：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_runner</span></span>(tests: &amp;[&amp;<span class="keyword">dyn</span> <span class="built_in">Fn</span>()]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Running &#123;&#125; tests&quot;</span>, tests.len());</span><br><span class="line">    <span class="keyword">for</span> test <span class="keyword">in</span> tests &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// new</span></span><br><span class="line">    exit_qemu(QemuExitCode::Success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在运行<code>cargo test</code>时，看到QEMU在执行完测试后立即关闭。问题是，虽然我们传入了<code>Success</code>退出码，但<code>cargo test</code>却将测试解释为失败：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; cargo <span class="built_in">test</span></span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.03s</span><br><span class="line">     Running target/x86_64-blog_os/debug/deps/blog_os-5804fc7d2dd4c9be</span><br><span class="line">Building bootloader</span><br><span class="line">   Compiling bootloader v0.5.3 (/home/philipp/Documents/bootloader)</span><br><span class="line">    Finished release [optimized + debuginfo] target(s) <span class="keyword">in</span> 1.07s</span><br><span class="line">Running: `qemu-system-x86_64 -drive format=raw,file=/…/target/x86_64-blog_os/debug/</span><br><span class="line">    deps/bootimage-blog_os-5804fc7d2dd4c9be.bin -device isa-debug-exit,iobase=0xf4,</span><br><span class="line">    iosize=0x04`</span><br><span class="line">error: <span class="built_in">test</span> failed, to rerun pass <span class="string">&#x27;--bin blog_os&#x27;</span></span><br></pre></td></tr></table></figure>

<p>问题在于，<code>cargo test</code>将除<code>0</code>以外的所有错误代码视为失败。</p>
<h3 id="成功退出码"><a href="#成功退出码" class="headerlink" title="成功退出码"></a>成功退出码</h3><p>为了解决这个问题，<code>bootimage</code>提供了一个<code>test-success-exit-code</code>配置键，将指定的退出代码映射到退出代码<code>0</code>。</p>
<figure class="highlight rust"><figcaption><span>in Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[package.metadata.bootimage]</span><br><span class="line">test-args = […]</span><br><span class="line">test-success-exit-code = <span class="number">33</span>         # (<span class="number">0x10</span> &lt;&lt; <span class="number">1</span>) | <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>有了这个配置，<code>bootimage</code>就会把我们的成功退出码映射到退出码<code>0</code>上，如此，<code>cargo test</code>就会正确识别成功测试，也就不会再把成功测试算作失败了。</p>
<p>我们的测试函数现在会自动关闭QEMU，并能够将正确的测试结果上报。可以看到QEMU窗口瞬间闪过，以至于我们没有足够的时间阅读测试结果。如果能把测试结果打印到控制台就更好了，这样我们在QEMU退出后仍然能看到测试结果。</p>
<h2 id="打印到控制台"><a href="#打印到控制台" class="headerlink" title="打印到控制台"></a>打印到控制台</h2><p>为了在控制台上看到测试输出，我们需要以某种方式将数据从内核发送到主机系统。有很多方法可以实现，例如通过TCP网络接口发送数据。然而，设置网络协议栈是一项相当复杂的任务，所以我们将选择一个更简单的解决方案。</p>
<h3 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h3><p>一个简单的发送数据的方法是使用串口，这是一个古老的接口标准，在现代计算机中已经找不到了。串口协议很容易编程控制，QEMU可以将通过串口发送的字节重定向到主机的标准输出或文件中。</p>
<p>实现串行接口的芯片叫做<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">UART</a>。x86上的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter#UART_models">UART型号很多</a>，但幸运的是它们之间的区别仅在于一些我们用不到的高级功能。目前常见的UART都能兼容到<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/16550_UART">16550 UART</a>，所以我们的测试框架就选用这个型号。</p>
<p>我们将使用<a target="_blank" rel="noopener" href="https://docs.rs/uart_16550"><code>uart_16550</code></a> crate来初始化UART并通过串口发送数据。为了将它作为一个依赖项添加，我们更新了<code>Cargo.toml</code>和<code>main.rs</code>：</p>
<figure class="highlight toml"><figcaption><span>in Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">uart_16550</span> = <span class="string">&quot;0.2.0&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>uart_16550</code>crate中包含了用以表示UART寄存器的<code>SerialPort</code>结构体，但我们仍然需要自己构造一个实例。为此，我们创建一个新的<code>serial</code>模块，其内容如下：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> serial;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><figcaption><span>in src/serial.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> uart_16550::SerialPort;</span><br><span class="line"><span class="keyword">use</span> spin::Mutex;</span><br><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> SERIAL1: Mutex&lt;SerialPort&gt; = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> serial_port = <span class="keyword">unsafe</span> &#123; SerialPort::new(<span class="number">0x3F8</span>) &#125;;</span><br><span class="line">        serial_port.init();</span><br><span class="line">        Mutex::new(serial_port)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似<a target="_blank" rel="noopener" href="https://os.phil-opp.com/vga-text-mode/#lazy-statics">VGA文本缓冲区</a>中，使用<code>lazy_static</code>和<code>spinlock</code>来创建静态Writer实例的操作。我们这次通过使用<code>lazy_static</code>，确保<code>init</code>方法在第一次使用时有且仅有一次调用。</p>
<p>与<code>isa-debug-exit</code>设备一样，UART也是使用端口I/O进行编程的。由于UART比较复杂，它使用多个I/O端口来编程不同的设备寄存器。非安全函数<code>SerialPort::new</code>需要UART的第一个I/O端口的地址作为参数，从这个地址就可以计算出所有需要的端口地址。我们传递的是端口地址<code>0x3F8</code>，这是第一个串行接口的标准端口号。</p>
<p>为了使串口便于使用，我们添加了<code>serial_print!</code>和<code>serial_println!</code>宏：</p>
<figure class="highlight rust"><figcaption><span>in src/serial.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[doc(hidden)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">_print</span></span>(args: ::core::fmt::Arguments) &#123;</span><br><span class="line">    <span class="keyword">use</span> core::fmt::Write;</span><br><span class="line">    SERIAL1.lock().write_fmt(args).expect(<span class="string">&quot;Printing to serial failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Prints to the host through the serial interface.</span></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> serial_print &#123;</span><br><span class="line">    ($($arg:tt)*) =&gt; &#123;</span><br><span class="line">        $crate::serial::_print(<span class="built_in">format_args!</span>($($arg)*));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Prints to the host through the serial interface, appending a newline.</span></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> serial_println &#123;</span><br><span class="line">    () =&gt; ($crate::serial_print!(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">    ($fmt:expr) =&gt; ($crate::serial_print!(<span class="built_in">concat!</span>($fmt, <span class="string">&quot;\n&quot;</span>)));</span><br><span class="line">    ($fmt:expr, $($arg:tt)*) =&gt; ($crate::serial_print!(</span><br><span class="line">        <span class="built_in">concat!</span>($fmt, <span class="string">&quot;\n&quot;</span>), $($arg)*));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个实现与我们的<code>print</code>和<code>println</code>宏的实现非常相似。由于<code>SerialPort</code>类型已经实现了<code>fmt::Write</code>trait，因此不需要提供自己的实现。</p>
<p>这次不用再将测试结果打印到VGA文本缓冲区了，现在直接将结果打印到串行接口：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_runner</span></span>(tests: &amp;[&amp;<span class="keyword">dyn</span> <span class="built_in">Fn</span>()]) &#123;</span><br><span class="line">    serial_println!(<span class="string">&quot;Running &#123;&#125; tests&quot;</span>, tests.len());</span><br><span class="line">    […]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test_case]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">trivial_assertion</span></span>() &#123;</span><br><span class="line">    serial_print!(<span class="string">&quot;trivial assertion... &quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    serial_println!(<span class="string">&quot;[ok]&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到<code>serial_println</code>宏直接存在于根命名空间下，这是因为我们使用了<code>#[macro_export]</code>属性。因此，如果通过使用<code>crate::serial::serial_println</code>将无法导入该宏。</p>
<h3 id="QEMU参数"><a href="#QEMU参数" class="headerlink" title="QEMU参数"></a>QEMU参数</h3><p>要查看QEMU的串行输出，我们需要使用<code>-serial</code>参数来重定向输出到stdout：</p>
<figure class="highlight rust"><figcaption><span>in Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[package.metadata.bootimage]</span><br><span class="line">test-args = [</span><br><span class="line">    <span class="string">&quot;-device&quot;</span>, <span class="string">&quot;isa-debug-exit,iobase=0xf4,iosize=0x04&quot;</span>, <span class="string">&quot;-serial&quot;</span>, <span class="string">&quot;stdio&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>现在运行<code>cargo test</code>时，直接可以在控制台中看到测试输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; cargo <span class="built_in">test</span></span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.02s</span><br><span class="line">     Running target/x86_64-blog_os/debug/deps/blog_os-7b7c37b4ad62551a</span><br><span class="line">Building bootloader</span><br><span class="line">    Finished release [optimized + debuginfo] target(s) <span class="keyword">in</span> 0.02s</span><br><span class="line">Running: `qemu-system-x86_64 -drive format=raw,file=/…/target/x86_64-blog_os/debug/</span><br><span class="line">    deps/bootimage-blog_os-7b7c37b4ad62551a.bin -device</span><br><span class="line">    isa-debug-exit,iobase=0xf4,iosize=0x04 -serial stdio`</span><br><span class="line">Running 1 tests</span><br><span class="line">trivial assertion... [ok]</span><br></pre></td></tr></table></figure>

<p>然而，当测试失败时，我们仍然会在QEMU中看到输出，因为我们的<code>panic handler</code>仍然使用<code>println</code>。为了模拟这种情况，我们可以将测试<code>trivial_assertion</code>中的断言改为<code>assert_eq!(0, 1)</code>：</p>
<p><img src="https://os.phil-opp.com/testing/qemu-failed-test.png" alt="panic时仍然在QEMU中打印"></p>
<p>可以看到，panic信息仍然被打印到VGA缓冲区，而其余的测试输出则被打印到串口。panic信息非常有用，所以我们希望也能在控制台中看到这些信息。</p>
<h3 id="Panic时打印错误信息"><a href="#Panic时打印错误信息" class="headerlink" title="Panic时打印错误信息"></a>Panic时打印错误信息</h3><p>为了在panic中带着错误信息退出QEMU，我们可以使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/1.30.0/book/first-edition/conditional-compilation.html">条件编译</a>，在测试模式下使用另一个panic处理程序。</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现有的panic_handler</span></span><br><span class="line"><span class="meta">#[cfg(not(test))]</span> <span class="comment">// 新增条件编译属性</span></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">panic</span></span>(info: &amp;PanicInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, info);</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试模式下的panic_handler</span></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">panic</span></span>(info: &amp;PanicInfo) -&gt; ! &#123;</span><br><span class="line">    serial_println!(<span class="string">&quot;[failed]\n&quot;</span>);</span><br><span class="line">    serial_println!(<span class="string">&quot;Error: &#123;&#125;\n&quot;</span>, info);</span><br><span class="line">    exit_qemu(QemuExitCode::Failed);</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在测试panic处理函数中，我们使用<code>serial_println</code>代替<code>println</code>，然后用失败退出码退出QEMU。请注意，在<code>exit_qemu</code>调用之后，我们仍然需要写一个死循环，因为编译器并不知道在测试模式下<code>isa-debug-exit</code>设备会导致程序退出。</p>
<p>现在，QEMU也会因为测试失败而退出，并在控制台上打印一个有用的错误信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; cargo <span class="built_in">test</span></span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.02s</span><br><span class="line">     Running target/x86_64-blog_os/debug/deps/blog_os-7b7c37b4ad62551a</span><br><span class="line">Building bootloader</span><br><span class="line">    Finished release [optimized + debuginfo] target(s) <span class="keyword">in</span> 0.02s</span><br><span class="line">Running: `qemu-system-x86_64 -drive format=raw,file=/…/target/x86_64-blog_os/debug/</span><br><span class="line">    deps/bootimage-blog_os-7b7c37b4ad62551a.bin -device</span><br><span class="line">    isa-debug-exit,iobase=0xf4,iosize=0x04 -serial stdio`</span><br><span class="line">Running 1 tests</span><br><span class="line">trivial assertion... [failed]</span><br><span class="line"></span><br><span class="line">Error: panicked at <span class="string">&#x27;assertion failed: `(left == right)`</span></span><br><span class="line"><span class="string">  left: `0`,</span></span><br><span class="line"><span class="string"> right: `1`&#x27;</span>, src/main.rs:65:5</span><br></pre></td></tr></table></figure>

<p>现在能够在控制台上看到了所有的测试输出了，我们也不再需要瞬间闪过的QEMU窗口。接下来，我们要完全隐藏它。</p>
<h3 id="隐藏QEMU"><a href="#隐藏QEMU" class="headerlink" title="隐藏QEMU"></a>隐藏QEMU</h3><p>通过使用<code>isa-debug-exit</code>设备和串口完成完整的测试结果的上报，现在我们不再需要QEMU窗口了。可以通过给QEMU传递<code>-display none</code>参数来隐藏它：</p>
<figure class="highlight toml"><figcaption><span>in Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package.metadata.bootimage]</span></span><br><span class="line"><span class="attr">test-args</span> = [</span><br><span class="line">    <span class="string">&quot;-device&quot;</span>, <span class="string">&quot;isa-debug-exit,iobase=0xf4,iosize=0x04&quot;</span>, <span class="string">&quot;-serial&quot;</span>, <span class="string">&quot;stdio&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-display&quot;</span>, <span class="string">&quot;none&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>现在的QEMU完全在后台运行，不再打开任何窗口。这不仅减少了弹出窗口的干扰，而且还允许我们的测试框架在没有图形用户界面的环境中运行，如CI服务或<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Secure_Shell">SSH</a>连接。</p>
<h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>由于<code>cargo test</code>会等到测试运行结束才退出，所以一个永不返回的测试会永远的将测试阻塞。这很不幸，但在实践中并不是一个大问题，因为通常很容易避免在测试中写死循环。然而，在我们的案例中，死循环会在各种情况下发生：</p>
<ul>
<li>bootloader无法加载我们的内核，这会导致系统无休止地重启。</li>
<li>BIOS/UEFI固件无法加载bootloader，同样也会导致无休止地重启。</li>
<li>CPU在我们一些函数的最后进入了<code>loop &#123;&#125;</code>语句，例如因为QEMU退出设备不能正常工作。</li>
<li>硬件导致系统复位，比如CPU异常没有被捕捉到（在以后的文章中会有详细解释）。</li>
</ul>
<p>由于在很多情况下会出现死循环，<code>bootimage</code>工具默认为每个测试可执行文件设置了5分钟的超时。如果测试没有在这个时间内完成，它就会被标记为失败，并将 “Timed Out”错误打印到控制台。这个功能可以确保陷入死循环的测试不会永远的阻塞<code>cargo test</code>。</p>
<p>可以通过在<code>trivial_assertion</code>测试中加入一个<code>loop &#123;&#125;</code>语句自己尝试一下。当运行<code>cargo test</code>时，你会看到测试在5分钟后被标记为超时。超时时间可以通过<code>Cargo.toml</code>中的<code>test-timeout</code>键来进行配置：</p>
<figure class="highlight toml"><figcaption><span>in Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package.metadata.bootimage]</span></span><br><span class="line"><span class="attr">test-timeout</span> = <span class="number">300</span>          <span class="comment"># (in seconds)</span></span><br></pre></td></tr></table></figure>

<p>如果你不想等待5分钟<code>trivial_assertion</code>测试超时，可以暂时地降低这个值。</p>
<h3 id="自动插入打印"><a href="#自动插入打印" class="headerlink" title="自动插入打印"></a>自动插入打印</h3><p><code>trivial_assertion</code>测试目前需要使用<code>serial_print!</code>和<code>serial_println!</code>来打印自己的状态信息：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test_case]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">trivial_assertion</span></span>() &#123;</span><br><span class="line">    serial_print!(<span class="string">&quot;trivial assertion... &quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    serial_println!(<span class="string">&quot;[ok]&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为每一个测试手动添加这些打印语句是很麻烦的，升级一下<code>test_runner</code>函数就可以做到自动打印这些消息。要实现这一点，首先需要创建一个新的<code>Testable</code>trait：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Testable</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(&amp;<span class="keyword">self</span>) -&gt; ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个技巧是为所有具有<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/core/ops/trait.Fn.html"><code>Fn()</code>trait</a>的<code>T</code>类型实现这个测试用trait：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Testable <span class="keyword">for</span> T</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="built_in">Fn</span>(),</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        serial_print!(<span class="string">&quot;&#123;&#125;...\t&quot;</span>, core::any::type_name::&lt;T&gt;());</span><br><span class="line">        <span class="keyword">self</span>();</span><br><span class="line">        serial_println!(<span class="string">&quot;[ok]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实现<code>run</code>函数时，首先使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/core/any/fn.type_name.html"><code>any::type_name</code></a>函数打印函数名。这个函数在编译器中直接实现，它返回每个类型的字符串描述。对于函数来说，类型就是它们的名字，而这种情况这正是我们希望的。<code>\t</code>字符是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tab_key#Tab_characters">制表符tab</a>，为了与<code>[ok]</code>信息进行一定程度的对齐。</p>
<p>打印函数名后，我们使用<code>self()</code>调用测试函数本身。这只是因为我们要求<code>self</code>实现了<code>Fn()</code>trait。在测试函数返回后，我们打印[ok]来表示该函数没有panic。</p>
<p>最后一步是为<code>test_runner</code>升级新特性<code>Testable</code>trait：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">test_runner</span></span>(tests: &amp;[&amp;<span class="keyword">dyn</span> Testable]) &#123;</span><br><span class="line">    serial_println!(<span class="string">&quot;Running &#123;&#125; tests&quot;</span>, tests.len());</span><br><span class="line">    <span class="keyword">for</span> test <span class="keyword">in</span> tests &#123;</span><br><span class="line">        test.run(); <span class="comment">// new</span></span><br><span class="line">    &#125;</span><br><span class="line">    exit_qemu(QemuExitCode::Success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仅有的两个变化是测试参数的类型从<code>&amp;[&amp;dyn Fn()]</code>变成了<code>&amp;[&amp;dyn Testable]</code>，以及我们现在调用的是<code>test.run()</code>而不是<code>test()</code>。</p>
<p>现在可以从<code>trivial_assertion</code>测试中删除打印语句，因为它们现在是自动打印的：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test_case]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">trivial_assertion</span></span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在<code>cargo test</code>的输出是这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Running 1 tests</span><br><span class="line">blog_os::trivial_assertion...	[ok]</span><br></pre></td></tr></table></figure>

<p>现在函数名包含了函数的完整路径，这在不同模块中的测试函数有相同名称时很有用。其余的输出看起来和原来一样，只不过我们不再需要在测试中手动添加打印语句了。</p>
<h2 id="VGA缓冲区测试"><a href="#VGA缓冲区测试" class="headerlink" title="VGA缓冲区测试"></a>VGA缓冲区测试</h2><p>有了一个好用的测试框架，现在我们可以为VGA缓冲区的实现创建一些测试。首先，我们创建一个非常简单的测试来验证<code>println</code>是否能够正常工作：</p>
<figure class="highlight rust"><figcaption><span>in src/vga_buffer.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test_case]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_println_simple</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;test_println_simple output&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该测试只是打印一些字符到VGA缓冲区。如果测试没有panic，这意味着<code>println</code>调用也没有panic。</p>
<p>为了确保即使打印了很多行，并且行数多到从屏幕上方移除旧行，也不会发生panic，我们可以创建另一个测试：</p>
<figure class="highlight rust"><figcaption><span>in src/vga_buffer.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test_case]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_println_many</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">200</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;test_println_many output&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以创建一个测试函数来验证打印的行是否真的出现在屏幕上：</p>
<figure class="highlight rust"><figcaption><span>in src/vga_buffer.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test_case]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_println_output</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">&quot;Some test string that fits on a single line&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">    <span class="keyword">for</span> (i, c) <span class="keyword">in</span> s.chars().enumerate() &#123;</span><br><span class="line">        <span class="keyword">let</span> screen_char = WRITER.lock().buffer.chars[BUFFER_HEIGHT - <span class="number">2</span>][i].read();</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="built_in">char</span>::from(screen_char.ascii_character), c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数指定了一个测试字符串，先使用<code>println</code>打印，然后遍历屏幕字符，也就是静态变量<code>WRITER</code>中代表VGA文本缓冲区的二维数组。由于<code>println</code>打印到最后一行屏幕后立即附加一个换行符，所以字符串应该出现在第<code>BUFFER_HEIGHT - 2</code>行。</p>
<p>利用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.enumerate"><code>enumerate</code></a>函数，使用变量<code>i</code>记录迭代次数，然后用它来从VGA缓冲区二维数组中获取与<code>c</code>对应的字符，通过将屏幕字符的<code>ascii_character</code>与c进行比较，我们确保字符串的每个字符都真正出现在VGA文本缓冲区中。</p>
<p>我们还可以创建更多的测试函数，例如，测试打印很长的行时字符是否被正确封装的函数；或者测试是否能够正确处理换行符、非打印字符、非unicode字符的函数。</p>
<p>然而，在这篇文章的其余部分，我们将解释如何创建集成测试来测试不同组件之间的交互。</p>
<h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>Rust中<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch11-03-test-organization.html#integration-tests">集成测试</a>的惯例是把它们放到项目根目录下的<code>tests</code>目录中（即与src目录平级）。默认测试框架和自定义测试框架都会自动识别并执行该目录下的所有测试。</p>
<p>所有的集成测试都是与与<code>main.rs</code>完全分开的单独的可执行文件。这意味着我们需要为每个测试定义一个入口点函数。让我们创建一个名为<code>basic_boot</code>的集成测试示例，仔细看看它是如何工作的：</p>
<figure class="highlight rust"><figcaption><span>in tests/basic_boot.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"><span class="meta">#![feature(custom_test_frameworks)]</span></span><br><span class="line"><span class="meta">#![test_runner(crate::test_runner)]</span></span><br><span class="line"><span class="meta">#![reexport_test_harness_main = <span class="meta-string">&quot;test_main&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::panic::PanicInfo;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span> <span class="comment">// don&#x27;t mangle the name of this function</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>() -&gt; ! &#123;</span><br><span class="line">    test_main();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_runner</span></span>(tests: &amp;[&amp;<span class="keyword">dyn</span> <span class="built_in">Fn</span>()]) &#123;</span><br><span class="line">    <span class="built_in">unimplemented!</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">panic</span></span>(info: &amp;PanicInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于集成测试是独立的可执行文件，我们需要再次提供所有的crate属性（如<code>no_std</code>、<code>no_main</code>、<code>test_runner</code>等）。我们还需要创建一个新的入口点函数<code>_start</code>，它调用测试入口点函数<code>test_main</code>。我们不需要任何<code>cfg(test)</code>属性，因为集成测试的可执行文件永远不会以非测试模式构建。</p>
<p>我们使用总是panic的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/macro.unimplemented.html"><code>unimplemented</code></a>宏作为<code>test_runner</code>函数的占位符，而且暂时在<code>panic_handler</code>中只做<code>loop</code>。理想情况下，我们希望能像在<code>main.rs</code>中一样使用<code>serial_println</code>宏和<code>exit_qemu</code>函数实现这些函数。问题是，我们无法访问这些函数，因为测试是完全独立于main.rs可执行文件构建的。</p>
<p>如果你在这个阶段运行<code>cargo test</code>，你会得到一个无休止的循环，因为<code>panic_handler</code>会无休止地循环。你需要使用<code>Ctrl+c</code>快捷键来退出QEMU。</p>
<h3 id="创建单独的库"><a href="#创建单独的库" class="headerlink" title="创建单独的库"></a>创建单独的库</h3><p>为了使集成测试能够使用所需的功能，我们需要从<code>main.rs</code>中分离出一个库，以供其他crate和集成测试可执行文件使用。为此，我们创建一个新的<code>src/lib.rs</code>文件：</p>
<figure class="highlight rust"><figcaption><span>src/lib.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br></pre></td></tr></table></figure>

<p>与<code>main.rs</code>一样，<code>lib.rs</code>也是一个特殊的文件，会被cargo自动识别。这个库是一个独立的编译单元，所以我们需要再次指定<code>#![no_std]</code>属性。</p>
<p>为了使我们的库能与<code>cargo test</code>配合使用，我们还需要将<code>main.rs</code>中的测试函数和属性移到<code>lib.rs</code>中：</p>
<figure class="highlight rust"><figcaption><span>in src/lib.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#![cfg_attr(test, no_main)]</span></span><br><span class="line"><span class="meta">#![feature(custom_test_frameworks)]</span></span><br><span class="line"><span class="meta">#![test_runner(crate::test_runner)]</span></span><br><span class="line"><span class="meta">#![reexport_test_harness_main = <span class="meta-string">&quot;test_main&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::panic::PanicInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Testable</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(&amp;<span class="keyword">self</span>) -&gt; ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Testable <span class="keyword">for</span> T</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="built_in">Fn</span>(),</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        serial_print!(<span class="string">&quot;&#123;&#125;...\t&quot;</span>, core::any::type_name::&lt;T&gt;());</span><br><span class="line">        <span class="keyword">self</span>();</span><br><span class="line">        serial_println!(<span class="string">&quot;[ok]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">test_runner</span></span>(tests: &amp;[&amp;<span class="keyword">dyn</span> Testable]) &#123;</span><br><span class="line">    serial_println!(<span class="string">&quot;Running &#123;&#125; tests&quot;</span>, tests.len());</span><br><span class="line">    <span class="keyword">for</span> test <span class="keyword">in</span> tests &#123;</span><br><span class="line">        test.run();</span><br><span class="line">    &#125;</span><br><span class="line">    exit_qemu(QemuExitCode::Success);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">test_panic_handler</span></span>(info: &amp;PanicInfo) -&gt; ! &#123;</span><br><span class="line">    serial_println!(<span class="string">&quot;[failed]\n&quot;</span>);</span><br><span class="line">    serial_println!(<span class="string">&quot;Error: &#123;&#125;\n&quot;</span>, info);</span><br><span class="line">    exit_qemu(QemuExitCode::Failed);</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Entry point for `cargo test`</span></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>() -&gt; ! &#123;</span><br><span class="line">    test_main();</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">panic</span></span>(info: &amp;PanicInfo) -&gt; ! &#123;</span><br><span class="line">    test_panic_handler(info)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了使可执行文件和集成测试能够调用<code>test_runner</code>，我们不对它应用<code>cfg(test)</code>属性，并将其公开。我们还将<code>panic_handler</code>的实现提取到一个公共的<code>test_panic_handler</code>函数中，这样它也可以用于可执行文件。</p>
<p>由于我们的<code>lib.rs</code>是独立于<code>main.rs</code>进行测试的，所以当库以测试模式编译时，我们需要添加一个<code>_start</code>入口点和一个<code>panic_handler</code>。通过使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a> crate属性，我们在这种情况下有条件地启用<code>no_main</code>属性。</p>
<p>继续将<code>QemuExitCode</code>枚举和<code>exit_qemu</code>函数移出，并将它们公开：</p>
<figure class="highlight rust"><figcaption><span>in src/lib.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span></span><br><span class="line"><span class="meta">#[repr(u32)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">QemuExitCode</span></span> &#123;</span><br><span class="line">    Success = <span class="number">0x10</span>,</span><br><span class="line">    Failed = <span class="number">0x11</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">exit_qemu</span></span>(exit_code: QemuExitCode) &#123;</span><br><span class="line">    <span class="keyword">use</span> x86_64::instructions::port::Port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> port = Port::new(<span class="number">0xf4</span>);</span><br><span class="line">        port.write(exit_code <span class="keyword">as</span> <span class="built_in">u32</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，可执行文件和集成测试可以从库中导入这些函数，而不需要定义自己的实现。为了让<code>println</code>和<code>serial_println</code>也能使用，我们把模块的声明也移到了这里：</p>
<figure class="highlight rust"><figcaption><span>in src/lib.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> serial;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> vga_buffer;</span><br></pre></td></tr></table></figure>

<p>我们将这些模块公开，以使它们可以在库外使用。这也是使<code>println</code>和<code>serial_println</code>宏可用的必要条件，因为它们使用了模块的<code>_print</code>函数。</p>
<p>现在我们可以使用新写好的库更新main.rs：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"><span class="meta">#![feature(custom_test_frameworks)]</span></span><br><span class="line"><span class="meta">#![test_runner(blog_os::test_runner)]</span></span><br><span class="line"><span class="meta">#![reexport_test_harness_main = <span class="meta-string">&quot;test_main&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::panic::PanicInfo;</span><br><span class="line"><span class="keyword">use</span> blog_os::println;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>() -&gt; ! &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello World&#123;&#125;&quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[cfg(test)]</span></span><br><span class="line">    test_main();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// This function is called on panic.</span></span><br><span class="line"><span class="meta">#[cfg(not(test))]</span></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">panic</span></span>(info: &amp;PanicInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, info);</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">panic</span></span>(info: &amp;PanicInfo) -&gt; ! &#123;</span><br><span class="line">    blog_os::test_panic_handler(info)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个库可以像普通的外部crate一样使用。调用它就像调用本项目的crate一样，在这里就是<code>blog_os</code>。上面的代码在<code>test_runner</code>属性中使用了<code>blog_os::test_runner</code>函数，在<code>cfg(test)</code>的<code>panic_handler</code>中使用了<code>blog_os::test_panic_handler</code>函数。同时，它还导入了<code>println</code>宏，使其可以用于<code>_start</code>和<code>panic</code>函数。</p>
<p>这时，<code>cargo run</code>和<code>cargo test</code>应该又可以工作了。当然，<code>cargo test</code>仍然会无休止地循环（你可以用<code>Ctrl+c</code>退出）。让我们通过在集成测试中使用所需的库函数来解决这个问题。</p>
<h3 id="完成集成测试"><a href="#完成集成测试" class="headerlink" title="完成集成测试"></a>完成集成测试</h3><p>如同<code>src/main.rs</code>一样，我们的<code>tests/basic_boot.rs</code>可执行文件也可以从新库中导入类型。这让我们可以导入缺少的组件来完成集成测试：</p>
<figure class="highlight rust"><figcaption><span>in tests/basic_boot.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![test_runner(blog_os::test_runner)]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">panic</span></span>(info: &amp;PanicInfo) -&gt; ! &#123;</span><br><span class="line">    blog_os::test_panic_handler(info)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们不需要重新实现一个测试runner，而是使用我们库中的<code>test_runner</code>函数。对于panic处理器，我们则调用<code>blog_os::test_panic_handler</code>函数，就像我们在<code>main.rs</code>中做的那样。</p>
<p>现在<code>cargo test</code>又正常退出了。当你运行它的时候，你会发现，它分别为<code>lib.rs</code>、<code>main.rs</code>和<code>basic_boot.rs</code>构建和运行测试。对于<code>main.rs</code>和<code>basic_boot</code>集成测试，它报告”Running 0 tests”，因为这些文件没有任何用<code>#[test_case]</code>注释的函数。</p>
<p>现在我们可以在<code>basic_boot.rs</code>中添加测试。例如，我们可以测试<code>println</code>是否能够正常工作，就像我们在VGA缓冲区测试中做的那样：</p>
<figure class="highlight rust"><figcaption><span>in tests/basic_boot.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> blog_os::println;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test_case]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_println</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;test_println output&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们现在运行<code>cargo test</code>时，我们看到它找到并执行了测试函数。</p>
<p>这个测试现在看起来可能有点无用，因为它几乎和VGA缓冲区的那个测试一模一样。但是，将来我们的<code>main.rs</code>和<code>lib.rs</code>的<code>_start</code>函数可能会扩充新内容，并在运行<code>test_main</code>函数之前调用各种初始化例程，这样两个测试就会在截然不同的环境中执行。</p>
<p>通过在<code>basic_boot</code>环境下测试<code>println</code>，而不调用<code>_start</code>中的任何初始化例程，我们可以确保<code>println</code>在启动后能正常工作。这一点很重要，因为我们需要依靠它来打印panic信息。</p>
<h3 id="更多测试"><a href="#更多测试" class="headerlink" title="更多测试"></a>更多测试</h3><p>集成测试的强大之处在于，它们被视为完全独立的程序执行。这使得它们可以完全控制环境，从而可以测试代码是否与CPU或硬件设备正确交互。</p>
<p>我们的<code>basic_boot</code>测试是一个非常简单的集成测试的例子。在未来，我们的内核将增加更多特性，并以各种方式与硬件交互。通过添加集成测试，我们可以确保这些交互正常工作（且能够持续正常工作）符合预期。对于未来可能的测试，我们有一些想法：</p>
<ul>
<li><strong>CPU异常</strong>：当代码执行了无效的操作（比如除零运算），CPU会抛出一个异常。内核可以为这种异常注册处理函数。集成测试可以验证当CPU异常发生时，是否调用了正确的异常处理函数；或是在可解决的异常后发生后，是否能继续执行正确操作。</li>
<li><strong>页表</strong>：页表定义了哪些内存区域是有效的和可访问的。通过修改页表，可以分配新的内存区域，例如在启动程序时。集成测试可以在<code>_start</code>函数中对页表进行一些修改，然后在<code>#[test_case]</code>函数中验证修改是否有预期效果。</li>
<li><strong>用户空间程序</strong>：用户空间程序是指对系统资源访问受限的程序。例如，它们不能访问内核数据结构或其他程序的内存。集成测试可以启动用户空间程序并执行被禁止的操作，而后验证内核是否阻止了这些应该被禁止的操作。</li>
</ul>
<p>你可以想象，还有很多测试是可能的。通过添加这样的测试，我们可以确保当我们在内核中添加新功能或者重构代码时，不会意外地破坏它们。当我们的内核变得更大、更复杂时，这一点尤其重要。</p>
<h3 id="测试应该panic的行为"><a href="#测试应该panic的行为" class="headerlink" title="测试应该panic的行为"></a>测试应该panic的行为</h3><p>标准库的测试框架支持名为<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html#testing-panics"><code>#[should_panic]</code>的属性</a>，以允许构建应该失败的测试。这很有用，例如当传递一个无效参数时，可以验证函数是否会出现错误。不幸的是，<code>#[no_std]</code>的crate并不支持这个属性，因为它需要标准库的支持。</p>
<p>虽然我们不能在内核中使用<code>#[should_panic]</code>属性，但是我们可以通过创建一个集成测试来获得类似的行为，这个测试可以从panic处理程序中获得成功的错误代码。让我们开始创建这样一个名为<code>should_panic</code>的测试：</p>
<figure class="highlight rust"><figcaption><span>in tests/should_panic.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::panic::PanicInfo;</span><br><span class="line"><span class="keyword">use</span> blog_os::&#123;QemuExitCode, exit_qemu, serial_println&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">panic</span></span>(_info: &amp;PanicInfo) -&gt; ! &#123;</span><br><span class="line">    serial_println!(<span class="string">&quot;[ok]&quot;</span>);</span><br><span class="line">    exit_qemu(QemuExitCode::Success);</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个测试仍然不完整，因为它还没有定义<code>_start</code>函数或任何自定义测试runner属性。让我们来补充缺失的部分：</p>
<figure class="highlight rust"><figcaption><span>in tests/should_panic.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(custom_test_frameworks)]</span></span><br><span class="line"><span class="meta">#![test_runner(test_runner)]</span></span><br><span class="line"><span class="meta">#![reexport_test_harness_main = <span class="meta-string">&quot;test_main&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>() -&gt; ! &#123;</span><br><span class="line">    test_main();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">test_runner</span></span>(tests: &amp;[&amp;<span class="keyword">dyn</span> <span class="built_in">Fn</span>()]) &#123;</span><br><span class="line">    serial_println!(<span class="string">&quot;Running &#123;&#125; tests&quot;</span>, tests.len());</span><br><span class="line">    <span class="keyword">for</span> test <span class="keyword">in</span> tests &#123;</span><br><span class="line">        test();</span><br><span class="line">        serial_println!(<span class="string">&quot;[test did not panic]&quot;</span>);</span><br><span class="line">        exit_qemu(QemuExitCode::Failed);</span><br><span class="line">    &#125;</span><br><span class="line">    exit_qemu(QemuExitCode::Success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试没有复用<code>lib.rs</code>中的<code>test_runner</code>，而是定义了自己的<code>test_runner</code>函数，当测试没有panic并返回时（我们希望测试会产生panic），就以失败码退出。如果没有定义测试函数，runner就会以成功码退出。由于runner总是在运行一个测试后退出，所以定义多个<code>#[test_case]</code>函数是没有意义的。</p>
<p>现在我们可以创建一个应该会失败的测试：</p>
<figure class="highlight rust"><figcaption><span>in tests/should_panic.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> blog_os::serial_print;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test_case]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">should_fail</span></span>() &#123;</span><br><span class="line">    serial_print!(<span class="string">&quot;should_panic::should_fail...\t&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试使用<code>assert_eq</code>来断言<code>0</code>和<code>1</code>相等，这当然会失败，于是测试就可以如愿以偿的panic了。注意，我们需要在这里使用<code>serial_print!</code>手动打印函数名，因为我们没有使用<code>Testable</code>trait。</p>
<p>当我们通过<code>cargo test --test should_panic</code>运行测试时，我们看到测试是成功的，因为测试如期panic了。当我们注释掉断言一行并再次运行测试时，我们看到它确实失败了，出现了”test did not panic”的消息。</p>
<p>这种方法的一个重要缺点是，它只对单个测试函数有效。对于多个<code>#[test_case]</code>函数，只有第一个函数被执行，因为在调用了panic处理器之后便无法继续执行了。目前我还不知道有什么好的方法来解决这个问题，如果你有什么想法，请告诉我！</p>
<h3 id="无环境测试"><a href="#无环境测试" class="headerlink" title="无环境测试"></a>无环境测试</h3><p>对于只有一个测试函数的集成测试（如<code>should_panic</code>测试），其实并不需要测试runner。在这样的情况下，我们可以完全禁用测试runner，并直接在<code>_start</code>函数中运行我们的测试。</p>
<p>其中的关键是在<code>Cargo.toml</code>中禁用测试的harness标志，它定义了集成测试是否使用测试runner。当它被设置为<code>false</code>时，默认的测试runner和自定义测试runner功能都会被禁用，这样测试就会被当作一个普通的可执行文件来处理。</p>
<p>让我们为<code>should_panic</code>测试禁用<code>harness</code>标识：</p>
<figure class="highlight toml"><figcaption><span>in Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[[test]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;should_panic&quot;</span></span><br><span class="line"><span class="attr">harness</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>现在，我们通过删除测试runner相关代码，大幅简化了<code>should_panic</code>测试，看起来是这样的：</p>
<figure class="highlight rust"><figcaption><span>in tests/should_panic.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::panic::PanicInfo;</span><br><span class="line"><span class="keyword">use</span> blog_os::&#123;exit_qemu, serial_print, serial_println, QemuExitCode&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>() -&gt; ! &#123;</span><br><span class="line">    should_fail();</span><br><span class="line">    serial_println!(<span class="string">&quot;[test did not panic]&quot;</span>);</span><br><span class="line">    exit_qemu(QemuExitCode::Failed);</span><br><span class="line">    <span class="keyword">loop</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">should_fail</span></span>() &#123;</span><br><span class="line">    serial_print!(<span class="string">&quot;should_panic::should_fail...\t&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">panic</span></span>(_info: &amp;PanicInfo) -&gt; ! &#123;</span><br><span class="line">    serial_println!(<span class="string">&quot;[ok]&quot;</span>);</span><br><span class="line">    exit_qemu(QemuExitCode::Success);</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们直接从<code>_start</code>函数中调用<code>should_fail</code>函数，如果函数能够返回，则以失败码退出。当我们现在运行<code>cargo test --test should_panic</code>时，我们看到测试的行为和之前完全一样。</p>
<p>除了创建<code>should_panic</code>测试外，禁用<code>harness</code>属性对于复杂的集成测试也很有用，例如当各测试函数均有副作用，需要按照指定的顺序运行时。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>测试是一种非常有用的技术，可以确保某些组件具有所期望的行为。即使测试不能表明没有bug，但也仍是找到bug的有用工具，尤其是避免回溯。</p>
<p>这篇文章解释了如何为Rust内核建立一个测试框架。我们使用Rust的自定义测试框架功能在裸机环境中实现对简单的<code>＃[test_case]</code>属性的支持。 通过使用QEMU的<code>isa-debug-exit</code>设备，测试runner可以在运行测试后退出QEMU并报告测试结果。为了将错误消息打印到控制台而不是VGA缓冲区，我们为串行端口创建了一个基础驱动程序。</p>
<p>在为<code>println</code>宏创建了一些测试之后，我们在后半部分探讨了集成测试。我们了解到集成测试位于<code>tests</code>目录中，并被视为完全独立的可执行文件。为了使他们能够访问<code>exit_qemu</code>函数和<code>serial_println</code>宏，我们将大部分代码移入了一个库，该库可以被所有可执行文件和集成测试导入。由于集成测试在各自独立的环境中运行，因此可以测试与硬件的交互或创建应引起panic的测试。</p>
<p>现在，我们有了一个在QEMU内真实环境中运行的测试框架。通过在以后的文章中创建更多测试，我们可以使内核变得更复杂时依旧保持可维护性。</p>
<h2 id="下期预告"><a href="#下期预告" class="headerlink" title="下期预告"></a>下期预告</h2><p>在下一篇文章中，我们将探讨<em>CPU异常</em>。当发生非法事件时，CPU将抛出这些异常，例如除零或访问未映射的内存页面（即所谓的“页面错误”）。能够捕获和检查这些异常对于调试将来的错误非常重要。异常处理也非常类似于硬件中断的处理，这是提供键盘支持所必需的。</p>
<h2 id="支持本项目"><a href="#支持本项目" class="headerlink" title="支持本项目"></a>支持本项目</h2><p>创建和<a target="_blank" rel="noopener" href="https://os.phil-opp.com/status-update/">维护</a>这个博客和相关库是一项繁重的工作，但我真的很喜欢。通过支持我，您可以让我在新内容、新功能和持续维护上投入更多时间。</p>
<p>支持我的最好方式是<a target="_blank" rel="noopener" href="https://github.com/sponsors/phil-opp">在GitHub上赞助我</a>，因为他们不收取任何中间费用。如果你喜欢其他平台，我也有<a target="_blank" rel="noopener" href="https://www.patreon.com/phil_opp">Patreon</a>和<a target="_blank" rel="noopener" href="https://donorbox.org/phil-opp">Donorbox</a>账户。后者是最灵活的，因为它支持多种货币和一次性捐款。</p>
<p>感谢您的支持！</p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Rust/">Rust</a><a class="link-muted mr-2" rel="tag" href="/tags/Operating-System/">Operating System</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatpay.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/03/06/writing-an-os-in-rust-2.1/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">使用Rust编写操作系统 - 2.1 - CPU异常</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/02/28/writing-an-os-in-rust-1.3/"><span class="level-item">使用Rust编写操作系统 - 1.3 - VGA文本模式</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><script src="https://utteranc.es/client.js" repo="zlotus/comment" issue-term="pathname" label="some-issue-label" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/opm_sq.png" alt="子实"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">子实</p><p class="is-size-6 is-block">程序员</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>陕西/西安</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">79</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">23</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zlotus" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com/qinzishi"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/Zealot_uS"><i class="fab fa-twitter"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.zhihu.com/people/zlotus" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Diary/"><span class="level-start"><span class="level-item">Diary</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">65</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Shell/"><span class="level-start"><span class="level-item">Shell</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Coroutines/"><span class="tag">Coroutines</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">31</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenCV/"><span class="tag">OpenCV</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Operating-System/"><span class="tag">Operating System</span><span class="tag">21</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Paper/"><span class="tag">Paper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Raspberry-Pi/"><span class="tag">Raspberry Pi</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag">29</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TensorFlow/"><span class="tag">TensorFlow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tokio/"><span class="tag">Tokio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZMQ/"><span class="tag">ZMQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ctpn/"><span class="tag">ctpn</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/llama/"><span class="tag">llama</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macOS/"><span class="tag">macOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/obsidion/"><span class="tag">obsidion</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%A5%E8%AE%B0/"><span class="tag">日记</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E8%B0%88/"><span class="tag">杂谈</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B/"><span class="tag">编程</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%84%9A%E6%9C%AC/"><span class="tag">脚本</span><span class="tag">4</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a><p class="is-size-7"><span>&copy; 2024 子实</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>