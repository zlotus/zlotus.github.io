<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>使用Rust编写操作系统 - 2.2 - 双重故障 - 子实</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="子实"><meta name="msapplication-TileImage" content="/img/avatar-o.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="子实"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="使用Rust编写操作系统 - 2.2 - CPU异常"><meta property="og:type" content="article"><meta property="og:title" content="使用Rust编写操作系统 - 2.2 - 双重故障"><meta property="og:url" content="https://zlotus.github.io/2021/03/15/writing-an-os-in-rust-2.2/"><meta property="og:site_name" content="子实"><meta property="og:description" content="使用Rust编写操作系统 - 2.2 - CPU异常"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://os.phil-opp.com/double-fault-exceptions/qemu-catch-double-fault.png"><meta property="og:image" content="https://os.phil-opp.com/double-fault-exceptions/qemu-double-fault-on-stack-overflow.png"><meta property="article:published_time" content="2021-03-15T10:18:00.000Z"><meta property="article:modified_time" content="2021-03-15T10:18:00.000Z"><meta property="article:author" content="子实"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Operating System"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://os.phil-opp.com/double-fault-exceptions/qemu-catch-double-fault.png"><meta property="twitter:creator" content="@Zealot_uS"><meta property="twitter:site" content="Zealot_uS"><link rel="publisher" href="+LotusQin"><meta property="fb:admins" content="qinzishi"><meta property="fb:app_id" content="qinzishi"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zlotus.github.io/2021/03/15/writing-an-os-in-rust-2.2/"},"headline":"使用Rust编写操作系统 - 2.2 - 双重故障","image":["https://os.phil-opp.com/double-fault-exceptions/qemu-catch-double-fault.png","https://os.phil-opp.com/double-fault-exceptions/qemu-double-fault-on-stack-overflow.png"],"datePublished":"2021-03-15T10:18:00.000Z","dateModified":"2021-03-15T10:18:00.000Z","author":{"@type":"Person","name":"子实"},"publisher":{"@type":"Organization","name":"子实","logo":{"@type":"ImageObject","url":"https://zlotus.github.io/img/opm_sq.png"}},"description":"使用Rust编写操作系统 - 2.2 - CPU异常"}</script><link rel="icon" href="/img/avatar-o.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/2014/07/09/about-me/">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-15T10:18:00.000Z" title="3/15/2021, 6:18:00 PM">2021-03-15</time>发表</span><span class="level-item"><time dateTime="2021-03-15T10:18:00.000Z" title="3/15/2021, 6:18:00 PM">2021-03-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a></span><span class="level-item">1 小时读完 (大约7109个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">使用Rust编写操作系统 - 2.2 - 双重故障</h1><div class="content"><article class="message message-immersive is-warning">
<div class="message-body">
<i class="fas fa-exclamation-triangle mr-2"></i>本文所有内容均为翻译，原文：<a target="_blank" rel="noopener" href="https://os.phil-opp.com/double-fault-exceptions/">Double Faults</a>；原项目：<a target="_blank" rel="noopener" href="https://os.phil-opp.com/">Writing an OS in Rust</a>
</div>
</article>

<p>本文将详细探讨双重故障异常，这种异常是在CPU无法调用异常处理程序时发生的。通过处理此异常，我们能够避免导致系统重置的致命<em>三重故障</em>。为了能够在任何情况下防止三重故障，我们还将建立一个<em>中断栈表</em>，以便在单独的内核栈上捕获双重故障。</p>
<span id="more"></span>

<p>这个博客是在<a target="_blank" rel="noopener" href="https://github.com/phil-opp/blog_os">GitHub</a>上公开开发的。如果你有任何问题或疑问，请在那里开一个issue。你也可以在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/double-fault-exceptions/#comments">底部</a>留言。这篇文章的完整源代码可以在<a target="_blank" rel="noopener" href="https://github.com/phil-opp/blog_os/tree/post-06">post-06</a>分支中找到。</p>
<h2 id="何为双重故障？"><a href="#何为双重故障？" class="headerlink" title="何为双重故障？"></a>何为双重故障？</h2><p>总的来说，双重故障是一种特殊异常，当CPU无法调用异常处理程序时才会诱发这种异常，例如当发生页面错误却并未在中<a target="_blank" rel="noopener" href="https://os.phil-opp.com/cpu-exceptions/#the-interrupt-descriptor-table">断描述符表</a>（IDT）中注册页面错误处理程序时。这类似于编程语言中用于捕获所有异常的代码块，比如像C++中的<code>catch(...)</code>或是像Java及C#中的<code>catch(Exception e)</code>。</p>
<p>双重故障的行为与普通异常类似。它的向量索引为<code>8</code>，我们可以在IDT中为其定义一个普通的处理函数。提供双重故障处理程序非常重要，因为如果未处理双重故障，则会发生致命的三重故障。三重故障无法被捕获，而大多数硬件对三重故障做出的反应就是系统复位。</p>
<h3 id="触发双重故障"><a href="#触发双重故障" class="headerlink" title="触发双重故障"></a>触发双重故障</h3><p>让我们通过触发一个未注册处理函数的异常来引发双重故障：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>() -&gt; ! &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello World&#123;&#125;&quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    blog_os::init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发页面错误</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        *(<span class="number">0xdeadbeef</span> <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u64</span>) = <span class="number">42</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">    <span class="meta">#[cfg(test)]</span></span><br><span class="line">    test_main();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;It did not crash!&quot;</span>);</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>unsafe</code>块向无效地址<code>0xdeadbeef</code>写入数据。虚拟地址未映射到页表中的物理地址，于是发生页面错误。我们尚未在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/cpu-exceptions/#the-interrupt-descriptor-table">IDT</a>中注册页面错误处理程序，因此发生了双重故障。</p>
<p>现在启动内核时，我们看到它陷入无限重启。重启原因如下：</p>
<ol>
<li>CPU尝试向<code>0xdeadbeef</code>写入，这将导致页面错误。</li>
<li>CPU查找IDT中的相应条目，发现该条目未指定任何处理函数。因此，它不能调用页面错误处理程序，并诱发双重故障。</li>
<li>CPU查看双重故障处理程序的IDT条目，但该条目同样未指定处理函数。于是，诱发<em>三重故障</em>。</li>
<li>三重故障是致命的。QEMU像大多数真实硬件一样对此做出反应——命令系统重置。</li>
</ol>
<p>为了防止出现三重故障，我们需要为页面错误提供处理函数，或者为双重故障提供处理函数。我们希望在任何情况下都能够避免三重故障，因此，我们从所有未注册异常都将调用的双重故障入手解决此类问题。</p>
<h2 id="双重故障处理程序"><a href="#双重故障处理程序" class="headerlink" title="双重故障处理程序"></a>双重故障处理程序</h2><p>双重故障是一个带有错误码的普通异常，因此我们指定的函数类似于断点处理函数：</p>
<figure class="highlight rust"><figcaption><span>in src/interrupts.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> IDT: InterruptDescriptorTable = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> idt = InterruptDescriptorTable::new();</span><br><span class="line">        idt.breakpoint.set_handler_fn(breakpoint_handler);</span><br><span class="line">        idt.double_fault.set_handler_fn(double_fault_handler); <span class="comment">// new</span></span><br><span class="line">        idt</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;x86-interrupt&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">double_fault_handler</span></span>(</span><br><span class="line">    stack_frame: &amp;<span class="keyword">mut</span> InterruptStackFrame, _error_code: <span class="built_in">u64</span>) -&gt; !</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;EXCEPTION: DOUBLE FAULT\n&#123;:#?&#125;&quot;</span>, stack_frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理程序将输出一条简短的错误消息，并转储异常栈帧。双重故障处理程序的错误码始终为零，因此没有必要打印它。与断点处理程序的不同之处在于，双重故障处理程序是<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/rust-by-example/fn/diverging.html">发散函数</a>，这是因为<code>x86_64</code>架构禁止从双重故障异常中返回。</p>
<p>现在启动内核时，应该看到调用了双重故障处理程序：</p>
<p><img src="https://os.phil-opp.com/double-fault-exceptions/qemu-catch-double-fault.png" alt="双重故障异常"></p>
<p>生效了！这次的执行过程如下：</p>
<ol>
<li>CPU尝试写入<code>0xdeadbeef</code>，这将导致页面错误。</li>
<li>像以前一样，CPU查找IDT中的相应条目，发现未定义任何处理函数，于是诱发双重故障。</li>
<li>CPU跳至我们新注册的双重故障处理程序。</li>
</ol>
<p>由于CPU现在可以调用双重故障处理程序，因此不再诱发三次故障（无限重启）。</p>
<p>如此简单！那么，为什么我们需要为这一主题撰写一整篇文章呢？好了，我们现在可以捕获<em>大多数</em>双重故障，但是在某些情况下，我们目前的方案仍不够用。</p>
<h2 id="双重故障诱因"><a href="#双重故障诱因" class="headerlink" title="双重故障诱因"></a>双重故障诱因</h2><p>在查看特殊情况之前，我们需要知道双重故障的确切诱因。在上一节中我们使用了一个非常模糊的定义：</p>
<blockquote>
<p>双重故障是一种特殊异常，当CPU无法调用异常处理程序时才会诱发这种异常。</p>
</blockquote>
<p>“无法调用”的确切含义是什么？该处理程序不存在吗？处理程序<a target="_blank" rel="noopener" href="http://pages.cs.wisc.edu/~remzi/OSTEP/vm-beyondphys.pdf">被换出</a>了吗？如果处理程序本身又导致异常时会发生什么呢？</p>
<p>例如，考虑以下情况发生时：</p>
<ol>
<li>发生断点异常，但是相应的处理函数被换出时？</li>
<li>发生页面错误，但是页面错误处理程序被换出时？</li>
<li>除零处理程序会导致断点异常，但是该断点处理程序被换出时？</li>
<li>我们的内核栈溢出了，同时命中保护页时？</li>
</ol>
<p>幸运的是，AMD64手册(<a target="_blank" rel="noopener" href="https://www.amd.com/system/files/TechDocs/24593.pdf">PDF</a>)中描述了准确定义（位于第8.2.9节）。根据该描述，“在执行先前（第一个）异常处理程序期间发生第二个异常时，<em>可能</em>会诱发双重故障异常”。 这个<em>“可能”</em>很重要：只有非常特殊的异常组合才会导致双重故障。这些组合是：</p>
<table>
<thead>
<tr>
<th>第一个异常</th>
<th>第二个异常</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://wiki.osdev.org/Exceptions#Divide-by-zero_Error">除0错误</a>，<br><a target="_blank" rel="noopener" href="https://wiki.osdev.org/Exceptions#Invalid_TSS">无效任务状态段</a>，<br><a target="_blank" rel="noopener" href="https://wiki.osdev.org/Exceptions#Segment_Not_Present">段不存在</a>，<br><a target="_blank" rel="noopener" href="https://wiki.osdev.org/Exceptions#Stack-Segment_Fault">栈段错误</a>，<br><a target="_blank" rel="noopener" href="https://wiki.osdev.org/Exceptions#General_Protection_Fault">一般性保护错误</a></td>
<td><a target="_blank" rel="noopener" href="https://wiki.osdev.org/Exceptions#Invalid_TSS">无效任务状态段</a>，<br><a target="_blank" rel="noopener" href="https://wiki.osdev.org/Exceptions#Segment_Not_Present">段不存在</a>，<br><a target="_blank" rel="noopener" href="https://wiki.osdev.org/Exceptions#Stack-Segment_Fault">栈段错误</a>，<br><a target="_blank" rel="noopener" href="https://wiki.osdev.org/Exceptions#General_Protection_Fault">一般性保护错误</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://wiki.osdev.org/Exceptions#Page_Fault">页面错误</a></td>
<td><a target="_blank" rel="noopener" href="https://wiki.osdev.org/Exceptions#Page_Fault">页面错误</a>，<br><a target="_blank" rel="noopener" href="https://wiki.osdev.org/Exceptions#Invalid_TSS">无效任务状态段</a>，<br><a target="_blank" rel="noopener" href="https://wiki.osdev.org/Exceptions#Segment_Not_Present">段不存在</a>，<br><a target="_blank" rel="noopener" href="https://wiki.osdev.org/Exceptions#Stack-Segment_Fault">栈段错误</a>，<br><a target="_blank" rel="noopener" href="https://wiki.osdev.org/Exceptions#General_Protection_Fault">一般性保护错误</a></td>
</tr>
</tbody></table>
<p>于是，诸如除零错误后接页面错误就相安无事（继续调用页面错误处理程序），但是除零错误后接一般性保护错误就会导致双重故障。</p>
<p>借助此表，我们可以回答上述四个问题中的前三个：</p>
<ol>
<li>如果发生断点异常，同时相应的处理函数被换出，则会发生页面错误，并调用页面错误处理程序。</li>
<li>如果发生页面错误，同时页面错误处理程序被换出，则会发生双重故障，并调用双重故障处理程序。</li>
<li>如果除零错误处理程序导致断点异常，则CPU会尝试调用断点处理程序。如果断点处理程序被换出，则会发生页面错误并调用页面错误处理程序。</li>
</ol>
<p>实际上，即使没有在IDT中注册处理函数的异常的情况也遵循此方案：当发生异常时，CPU会尝试读取相应的IDT条目。由于该条目为0，即无效的IDT条目，因此会诱发<em>一般性保护错误</em>。我们也没有为一般保护错误定义处理函数，因此会诱发另一个一般性保护故障。根据上表，这将导致双重故障。</p>
<h3 id="内核栈溢出"><a href="#内核栈溢出" class="headerlink" title="内核栈溢出"></a>内核栈溢出</h3><p>让我们看第四个问题：</p>
<blockquote>
<p>如果我们的内核栈溢出且命中保护页，会发生什么？</p>
</blockquote>
<p>保护页是栈底的特殊内存页，可用来检测栈溢出。该页面未映射到任何物理内存，因此对其进行的访问动作将会导致页面错误，而不是静默的破坏内存其他数据。bootloader为我们的内核栈设置了一个保护页面，因此栈溢出会导致<em>页面错误</em>。</p>
<p>当发生页面错误时，CPU在IDT中查找页面错误处理程序，并尝试将<a target="_blank" rel="noopener" href="https://os.phil-opp.com/cpu-exceptions/#the-interrupt-stack-frame">中断栈帧</a>压栈。但是，当前的栈指针仍指向不存在的保护页。于是，发生第二个页面错误，这将导致双重故障（根据上表）。</p>
<p>现在CPU将尝试调用<em>双重故障处理程序</em>。但是，在出现双重故障时，CPU也会尝试压入异常栈帧。此时栈指针仍指向保护页，于是发生第三个页错误，这将导致<em>三重故</em>障并使系统重启。可见，在这种情况下，目前的双重故障处理程序无法避免三重故障。</p>
<p>让我们自己尝试一下！通过调用无限递归函数就可以轻松诱发内核栈溢出：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span> <span class="comment">// don&#x27;t mangle the name of this function</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>() -&gt; ! &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello World&#123;&#125;&quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    blog_os::init();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">stack_overflow</span></span>() &#123;</span><br><span class="line">        stack_overflow(); <span class="comment">// 每次递归都会将返回地址压栈</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发栈溢出</span></span><br><span class="line">    stack_overflow();</span><br><span class="line"></span><br><span class="line">    […] <span class="comment">// test_main(), println(…), and loop &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们在QEMU中运行这段代码时，将看到系统再次陷入无限重启。</p>
<p>那么应该怎样避免这个问题呢？我们不能忽略异常栈帧压栈，因为这是CPU的硬件行为。因此，我们需要确保在发生双重故障时栈不会溢出。幸运的是，x86_64架构可以解决此问题。</p>
<h2 id="切换栈"><a href="#切换栈" class="headerlink" title="切换栈"></a>切换栈</h2><p>当发生异常时，x86_64架构能够切换到预定义的已知良好的栈上。此切换发生在硬件级别，因此可以在CPU推送异常栈帧之前执行。</p>
<p>切换机制通过<em>中断栈表</em>(IST)实现。IST是由7个指向已知良好栈的指针组成的表。以Rust伪代码描述类似：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InterruptStackTable</span></span> &#123;</span><br><span class="line">    stack_pointers: [<span class="built_in">Option</span>&lt;StackPointer&gt;; <span class="number">7</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每个异常处理程序，我们可以通过相应<a target="_blank" rel="noopener" href="https://os.phil-opp.com/cpu-exceptions/#the-interrupt-descriptor-table">IDT条目</a>中的<code>stack_pointers</code>参数在IST中指定一个栈。例如，我们可以将IST中的第一个栈用于双重故障处理程序。此后，每当发生双重故障时，CPU都会自动切换到该栈。该切换将发生在一切压栈动作之前，因此能够防止三重故障。</p>
<h3 id="IST和TSS"><a href="#IST和TSS" class="headerlink" title="IST和TSS"></a>IST和TSS</h3><p><em>中断栈表</em>(IST)是旧时代遗留的结构体<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Task_state_segment"><em>任务状态段</em></a>(TSS)中的一部分。在32位模式下TSS用于保存有关任务的各种信息（如处理器寄存器状态），例如用于<a target="_blank" rel="noopener" href="https://wiki.osdev.org/Context_Switching#Hardware_Context_Switching">硬件上下文切换</a>。但是，在64位模式下不再支持硬件上下文切换，并且TSS的格式已完全更改。</p>
<p>在x86_64上，TSS不再用于保存任务相关信息。现在，它包含两个栈表（IST便是其中之一）。32位和64位TSS之间的唯一公共字段指向<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Task_state_segment#I.2FO_port_permissions">I/O port permissions bitmap</a>。</p>
<p>64位TSS具有以下格式：</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
</tr>
</thead>
<tbody><tr>
<td>（保留位）</td>
<td><code>u32</code></td>
</tr>
<tr>
<td>特权栈表</td>
<td><code>[u64; 3]</code></td>
</tr>
<tr>
<td>（保留位）</td>
<td><code>u64</code></td>
</tr>
<tr>
<td>中断栈表</td>
<td><code>[u64; 7]</code></td>
</tr>
<tr>
<td>（保留位）</td>
<td><code>u64</code></td>
</tr>
<tr>
<td>（保留位）</td>
<td><code>u16</code></td>
</tr>
<tr>
<td>I/O映射基地址</td>
<td><code>u16</code></td>
</tr>
</tbody></table>
<p>当特权级别变更时，CPU使用<em>特权栈表</em>。例如，如果在CPU处于用户模式（特权级别3）时发生异常，则在调用异常处理程序之前，CPU通常会切换到内核模式（特权级别0）。在这种情况下，CPU将切换到“特权栈表”中的第0个栈（因为0是目标特权级别）。我们目前还没有任何用户模式程序，因此我们暂时忽略此表。</p>
<h3 id="新建TSS"><a href="#新建TSS" class="headerlink" title="新建TSS"></a>新建TSS</h3><p>让我们创建一个新的TSS，并在其中断栈表中包含一个单独的双重故障栈。为此，我们需要一个TSS结构体。幸运的是，<code>x86_64</code>crate已经包含了<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/tss/struct.TaskStateSegment.html"><code>TaskStateSegment结构体</code></a>。</p>
<p>我们在新的<code>gdt</code>（稍后会解释这个缩写的意义）模块中创建TSS：</p>
<figure class="highlight rust"><figcaption><span>in src/lib.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> gdt;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><figcaption><span>in src/gdt.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> x86_64::VirtAddr;</span><br><span class="line"><span class="keyword">use</span> x86_64::structures::tss::TaskStateSegment;</span><br><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> DOUBLE_FAULT_IST_INDEX: <span class="built_in">u16</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> TSS: TaskStateSegment = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> tss = TaskStateSegment::new();</span><br><span class="line">        tss.interrupt_stack_table[DOUBLE_FAULT_IST_INDEX <span class="keyword">as</span> <span class="built_in">usize</span>] = &#123;</span><br><span class="line">            <span class="keyword">const</span> STACK_SIZE: <span class="built_in">usize</span> = <span class="number">4096</span> * <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">mut</span> STACK: [<span class="built_in">u8</span>; STACK_SIZE] = [<span class="number">0</span>; STACK_SIZE];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> stack_start = VirtAddr::from_ptr(<span class="keyword">unsafe</span> &#123; &amp;STACK &#125;);</span><br><span class="line">            <span class="keyword">let</span> stack_end = stack_start + STACK_SIZE;</span><br><span class="line">            stack_end</span><br><span class="line">        &#125;;</span><br><span class="line">        tss</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用<code>lazy_static</code>是因为Rust的常量求值器还不够强大，无法在编译时进行上面的初始化操作。我们定义第0个IST条目为双重故障栈（换做其他任何IST条目均可）。再将双重故障栈的高位地址写入第0个条目。写入高位地址是因为x86上的栈向下增长，即从高位地址到低位地址（译注：即高位为栈底，低位为栈顶）。</p>
<p>我们尚未实现内存管理，因此目前并没有一个合适的方法能够用于新栈的分配。作为代替，我们使用<code>static mut</code>数组作为栈存储空间。这里需要使用<code>unsafe</code>块，因为在访问可变静态变量时，编译器无法保证数据竞争条件。重要的是它是一个<code>static mut</code>而不是一个普通<code>static</code>，否则bootloader会将其映射到只读页面。我们将在以后的文章中将其替换为适当的栈分配方法，使得这里不再需要<code>unsafe</code>块。</p>
<p>请注意，此双重故障栈并没用以防止栈溢出的保护页面。这意味着我们不应该在双重故障处理程序中执行密集的栈操作，从而导致栈溢出并破坏栈下方的内存。</p>
<h4 id="加载TSS"><a href="#加载TSS" class="headerlink" title="加载TSS"></a>加载TSS</h4><p>我们创建了一个新的TSS，现在需要告诉CPU它应该使用这个新TSS。不幸的是，这有点麻烦，因为TSS使用分段系统（出于历史原因）。这里我们不应也不能直接加载表，而应向<a target="_blank" rel="noopener" href="https://web.archive.org/web/20190217233448/https://www.flingos.co.uk/docs/reference/Global-Descriptor-Table/">全局描述符表</a>(GDT)添加新的段描述符。之后，就可以使用相应的GDT索引调用<a target="_blank" rel="noopener" href="https://www.felixcloutier.com/x86/ltr">ltr指令</a>来加载我们的TSS。（这就是为什么我们将模块命名为<code>gdt</code>。）</p>
<h3 id="全局描述符表"><a href="#全局描述符表" class="headerlink" title="全局描述符表"></a>全局描述符表</h3><p>全局描述符表（GDT）是旧时代遗留下来的，出现在内存分页成为事实上的标准之前，当时用来进行<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_memory_segmentation">内存分段</a>。不过它仍然在64位模式下的多种操作中起作用，例如内核模式/用户模式的配置或TSS的加载。</p>
<p>GDT是包含程序<em>段</em>的结构体，在内存分页成为标准之前的旧架构中，用于将程序彼此隔离。有关分段的更多信息，请查阅一本名为<a target="_blank" rel="noopener" href="http://pages.cs.wisc.edu/~remzi/OSTEP/">“Three Easy Pieces”</a>的免费书籍中的同名章节。虽然在64位模式下不再支持分段，但是GDT仍然存在。现在它主要用于两件事：在内核空间和用户空间之间切换，以及加载TSS结构。</p>
<h4 id="创建GDT"><a href="#创建GDT" class="headerlink" title="创建GDT"></a>创建GDT</h4><p>让我们创建一个静态<code>GDT</code>，其中包含我们的静态变量<code>TSS</code>：</p>
<figure class="highlight rust"><figcaption><span>in src/gdt.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> x86_64::structures::gdt::&#123;GlobalDescriptorTable, Descriptor&#125;;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> GDT: GlobalDescriptorTable = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> gdt = GlobalDescriptorTable::new();</span><br><span class="line">        gdt.add_entry(Descriptor::kernel_code_segment());</span><br><span class="line">        gdt.add_entry(Descriptor::tss_segment(&amp;TSS));</span><br><span class="line">        gdt</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续通过<code>lazy_static</code>，用代码段和TSS段创建一个新的GDT。</p>
<h4 id="加载GDT"><a href="#加载GDT" class="headerlink" title="加载GDT"></a>加载GDT</h4><p>创建一个新的<code>gdt::init</code>函数用于载GDT，我们再从（译注：<code>lib.rs</code>中的）总<code>init</code>函数中调用该初始化：</p>
<figure class="highlight rust"><figcaption><span>in src/gdt.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">init</span></span>() &#123;</span><br><span class="line">    GDT.load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><figcaption><span>in src/lib.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">init</span></span>() &#123;</span><br><span class="line">    gdt::init();</span><br><span class="line">    interrupts::init_idt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在GDT已加载（因为<code>_start</code>函数调用了总<code>init</code>），但是我们仍然看到栈溢出时的无限重启。</p>
<h3 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h3><p>此时的问题在于新的GDT段尚未激活，因为段和TSS寄存器仍为旧GDT中的值。我们还需要修改双重故障IDT条目，使其能够使用新栈。</p>
<p>总之，我们需要执行以下操作：</p>
<ol>
<li><strong>重载代码段寄存器</strong>：我​​们更改了GDT，应该重载代码段寄存器<code>cs</code>。这是必需的，因为旧的段选择器现在可能指向其他GDT描述符（例如TSS描述符）。</li>
<li><strong>加载TSS</strong>：我们加载了一个包含TSS选择器的GDT，但是我们仍然需要告诉CPU去使用这个新的TSS。</li>
<li><strong>更新IDT条目</strong>：一旦加载了TSS，CPU就能够访问有效的中断栈表(IST)了。然后，通过修改双重故障的IDT条目，就可以告诉CPU它应该使用新的双重故障栈了。</li>
</ol>
<p>对于前两个步骤，我们需要访问<code>gdt::init</code>函数中的<code>code_selector</code>和<code>tss_selector</code>变量。要使得这两个变量能够被访问，我们可以通过新建<code>Selectors</code>结构体使它们成为静态变量的一部分：</p>
<figure class="highlight rust"><figcaption><span>in src/gdt.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> x86_64::structures::gdt::SegmentSelector;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> GDT: (GlobalDescriptorTable, Selectors) = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> gdt = GlobalDescriptorTable::new();</span><br><span class="line">        <span class="keyword">let</span> code_selector = gdt.add_entry(Descriptor::kernel_code_segment());</span><br><span class="line">        <span class="keyword">let</span> tss_selector = gdt.add_entry(Descriptor::tss_segment(&amp;TSS));</span><br><span class="line">        (gdt, Selectors &#123; code_selector, tss_selector &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Selectors</span></span> &#123;</span><br><span class="line">    code_selector: SegmentSelector,</span><br><span class="line">    tss_selector: SegmentSelector,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，可以使用选择器来重载<code>cs</code>段寄存器并加载我们的TSS：</p>
<figure class="highlight rust"><figcaption><span>in src/gdt.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">init</span></span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> x86_64::instructions::segmentation::set_cs;</span><br><span class="line">    <span class="keyword">use</span> x86_64::instructions::tables::load_tss;</span><br><span class="line"></span><br><span class="line">    GDT.<span class="number">0</span>.load();</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        set_cs(GDT.<span class="number">1</span>.code_selector);</span><br><span class="line">        load_tss(GDT.<span class="number">1</span>.tss_selector);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/instructions/segmentation/fn.set_cs.html"><code>set_cs</code></a>重载代码段寄存器，并使用<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/instructions/tables/fn.load_tss.html"><code>load_tss</code></a>加载TSS。这两个函数被标记为<code>unsafe</code>，因此需要在<code>unsafe</code>块中调用——它们可能会因为加载了无效选择器而破坏内存安全。</p>
<p>我们已经加载了有效的TSS和中断堆栈表，现在，可以在IDT中为双重故障处理程序设置栈索引了：</p>
<figure class="highlight rust"><figcaption><span>in src/interrupts.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::gdt;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> IDT: InterruptDescriptorTable = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> idt = InterruptDescriptorTable::new();</span><br><span class="line">        idt.breakpoint.set_handler_fn(breakpoint_handler);</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            idt.double_fault.set_handler_fn(double_fault_handler)</span><br><span class="line">                .set_stack_index(gdt::DOUBLE_FAULT_IST_INDEX); <span class="comment">// new</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        idt</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>set_stack_index</code>方法是非安全的，调用者必须确保使用的索引有效，并且未用于其他异常。</p>
<p>现在，每当发生双重故障时，CPU应该都能切换到双重故障栈。因此，我们能够捕获<em>所有</em>双重故障，包括内核栈溢出：</p>
<p><img src="https://os.phil-opp.com/double-fault-exceptions/qemu-double-fault-on-stack-overflow.png" alt="QEMU栈溢出时的双重故障"></p>
<p>从现在开始，我们再也不会看到三重故障！为确保我们不会意外地破坏以上操作，我们应该为此添加一个测试。</p>
<h2 id="栈溢出测试"><a href="#栈溢出测试" class="headerlink" title="栈溢出测试"></a>栈溢出测试</h2><p>为了测试新写的<code>gdt</code>模块，并确保在栈溢出时正确调用了双重故障处理程序，我们可以添加一个集成测试。大致思路是在测试函数中引发双重故障，以验证是否调用了双重故障处理程序。</p>
<p>让我们从一个最小化的测试程序：</p>
<figure class="highlight rust"><figcaption><span>in tests/stack_overflow.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::panic::PanicInfo;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>() -&gt; ! &#123;</span><br><span class="line">    <span class="built_in">unimplemented!</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">panic</span></span>(info: &amp;PanicInfo) -&gt; ! &#123;</span><br><span class="line">    blog_os::test_panic_handler(info)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像我们的<code>panic_handler</code>测试一样，该测试将在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/testing/#no-harness-tests">没有测试环境</a>的条件下运行。这是因为出现双重错误后程序无法继续执行，因此执行多于一个的测试是没有意义的。要禁用测试的测试环境，我们将以下内容添加到我们的Cargo.toml中：</p>
<figure class="highlight toml"><figcaption><span>in Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[[test]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;stack_overflow&quot;</span></span><br><span class="line"><span class="attr">harness</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>现在，<code>cargo test --test stack_overflow</code>应该可以编译。当然，运行测试会失败，因为<code>unimplemented</code>宏会引起panic。</p>
<h3 id="实现-start"><a href="#实现-start" class="headerlink" title="实现_start"></a>实现<code>_start</code></h3><p><code>_start</code>函数的实现将会像这样：</p>
<figure class="highlight rust"><figcaption><span>in tests/stack_overflow.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> blog_os::serial_print;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>() -&gt; ! &#123;</span><br><span class="line">    serial_print!(<span class="string">&quot;stack_overflow::stack_overflow...\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">    blog_os::gdt::init();</span><br><span class="line">    init_test_idt();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出发栈溢出</span></span><br><span class="line">    stack_overflow();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;Execution continued after stack overflow&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[allow(unconditional_recursion)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">stack_overflow</span></span>() &#123;</span><br><span class="line">    stack_overflow(); <span class="comment">// 每次递归都会将返回地址压栈</span></span><br><span class="line">    volatile::Volatile::new(<span class="number">0</span>).read(); <span class="comment">// 防止尾递归优化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里不调用<code>interrupts::init_idt</code>函数，而是调用<code>gdt::init</code>函数来初始化新的GDT，原因是我们要注册一个自定义双重故障处理程序，它将执行<code>exit_qemu(QemuExitCode::Success)</code>退出，而不是直接panic。我们还将调用<code>init_test_idt</code>函数，稍后将对其进行说明。</p>
<p><code>stack_overflow</code>函数与<code>main.rs</code>中的函数几乎相同。唯一的不同是，我们在函数末尾使用<a target="_blank" rel="noopener" href="https://docs.rs/volatile/0.2.6/volatile/struct.Volatile.html"><code>Volatile</code></a>类型进行了额外的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Volatile_(computer_programming)">易失性</a>读取，以防止称为<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tail_call"><em>尾调用消除</em></a>的编译器优化。此优化允许编译器将最后一条语句为递归调用的递归函数，从递归调用函数转换为带有循环的普通函数（译注：尾递归优化将递归化为循环）。若有此优化，则递归化为循环后函数将不再会新建额外的栈帧（用于返回地址压栈），于是该函数对于栈的使用将变为常量（译注：循环没有返回地址压栈环节，相较于递归会大幅提升执行效率与资源利用率）。</p>
<p>但是，在我们的情况下，我们的确希望栈溢出的发生，于是我们在函数的末尾添加了一个假的易失性读操作，以禁止编译器删除该语句。因此，该函数不再是<em>尾递归</em>，就可以防止递归转换为循环。我们还添加了<code>allow(unconditional_recursion)</code>属性，以使编译器保持不对这个无限递归的函数发出编译警告。</p>
<h3 id="测试IDT"><a href="#测试IDT" class="headerlink" title="测试IDT"></a>测试IDT</h3><p>如上所述，测试需要使用自己的IDT，并自定义双重故障处理程序。实现看起来像这样：</p>
<figure class="highlight rust"><figcaption><span>in tests/stack_overflow.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line"><span class="keyword">use</span> x86_64::structures::idt::InterruptDescriptorTable;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> TEST_IDT: InterruptDescriptorTable = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> idt = InterruptDescriptorTable::new();</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            idt.double_fault</span><br><span class="line">                .set_handler_fn(test_double_fault_handler)</span><br><span class="line">                .set_stack_index(blog_os::gdt::DOUBLE_FAULT_IST_INDEX);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        idt</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">init_test_idt</span></span>() &#123;</span><br><span class="line">    TEST_IDT.load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该实现非常类似于我们在<code>interrupts.rs</code>中的IDT。就像在原来的IDT中，给用于双重故障处理程序的IST设置栈索引，以便触发异常时切换到这个已知良好的栈。最后<code>init_test_idt</code>函数通过<code>load</code>方法将IDT加载到CPU上。</p>
<h3 id="双重故障处理程序-1"><a href="#双重故障处理程序-1" class="headerlink" title="双重故障处理程序"></a>双重故障处理程序</h3><p>唯一缺少的部分是我们的双重故障处理程序。看起来像这样：</p>
<figure class="highlight rust"><figcaption><span>in tests/stack_overflow.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> blog_os::&#123;exit_qemu, QemuExitCode, serial_println&#125;;</span><br><span class="line"><span class="keyword">use</span> x86_64::structures::idt::InterruptStackFrame;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;x86-interrupt&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">test_double_fault_handler</span></span>(</span><br><span class="line">    _stack_frame: &amp;<span class="keyword">mut</span> InterruptStackFrame,</span><br><span class="line">    _error_code: <span class="built_in">u64</span>,</span><br><span class="line">) -&gt; ! &#123;</span><br><span class="line">    serial_println!(<span class="string">&quot;[ok]&quot;</span>);</span><br><span class="line">    exit_qemu(QemuExitCode::Success);</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用双重故障处理程序时，我们以成功码退出QEMU，该代码将测试标记为已通过。由于集成测试是完全独立的可执行文件，因此我们仍需要在测试文件的顶部设置<code>#![feature(abi_x86_interrupt)]</code>属性。</p>
<p>现在，我们可以通过<code>cargo test --test stack_overflow</code>来运行该测试（或通过<code>cargo test</code>运行所有测试）。不出所料，我们在控制台中看到输出<code>stack_overflow... [ok]</code>。尝试注释掉<code>set_stack_index</code>一行：它应该导致测试失败。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在这篇文章中，我们了解了什么是双重故障以及它将会在在什么情况下会发生。我们添加了一个基本的双重故障处理程序，该处理程序可以打印一条错误消息，并为此添加了集成测试。</p>
<p>我们还启用了硬件支持的双重故障异常上的切换栈功能，这保证了在栈溢出时程序依然能够正常运行。在实现它的过程中，我们了解了任务状态段（TSS）和其中包含的中断堆栈表（IST），以及用于在旧架构上进行内存分段的全局描述符表（GDT）。</p>
<h2 id="下期预告"><a href="#下期预告" class="headerlink" title="下期预告"></a>下期预告</h2><p>下一篇文章将介绍如何处理来自外部设备（如计时器，键盘或网络控制器）的中断。这些硬件中断与异常非常相似，比如它们同样也通过IDT调度。但是，与异常不同，它们不会直接出现在CPU上，而是会汇总在<em>中断控制器</em>上，然后根据优先级将它们转发给CPU。在接下来的内容中，我们将探索<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Intel_8259">Intel 8259</a>(“PIC”)中断控制器，并学习如何实现对键盘的支持。</p>
<h2 id="支持本项目"><a href="#支持本项目" class="headerlink" title="支持本项目"></a>支持本项目</h2><p>创建和<a target="_blank" rel="noopener" href="https://os.phil-opp.com/status-update/">维护</a>这个博客和相关库是一项繁重的工作，但我真的很喜欢。通过支持我，您可以让我在新内容、新功能和持续维护上投入更多时间。</p>
<p>支持我的最好方式是<a target="_blank" rel="noopener" href="https://github.com/sponsors/phil-opp">在GitHub上赞助我</a>，因为他们不收取任何中间费用。如果你喜欢其他平台，我也有<a target="_blank" rel="noopener" href="https://www.patreon.com/phil_opp">Patreon</a>和<a target="_blank" rel="noopener" href="https://donorbox.org/phil-opp">Donorbox</a>账户。后者是最灵活的，因为它支持多种货币和一次性捐款。</p>
<p>感谢您的支持！</p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Rust/">Rust</a><a class="link-muted mr-2" rel="tag" href="/tags/Operating-System/">Operating System</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatpay.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/03/18/writing-an-os-in-rust-2.3/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">使用Rust编写操作系统 - 2.3 - 硬件中断</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/03/06/writing-an-os-in-rust-2.1/"><span class="level-item">使用Rust编写操作系统 - 2.1 - CPU异常</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><script src="https://utteranc.es/client.js" repo="zlotus/comment" issue-term="pathname" label="some-issue-label" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/opm_sq.png" alt="子实"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">子实</p><p class="is-size-6 is-block">程序员</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>陕西/西安</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">80</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">23</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zlotus" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com/qinzishi"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/Zealot_uS"><i class="fab fa-twitter"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.zhihu.com/people/zlotus" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Diary/"><span class="level-start"><span class="level-item">Diary</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">66</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Shell/"><span class="level-start"><span class="level-item">Shell</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Coroutines/"><span class="tag">Coroutines</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">32</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenCV/"><span class="tag">OpenCV</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Operating-System/"><span class="tag">Operating System</span><span class="tag">21</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Paper/"><span class="tag">Paper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Raspberry-Pi/"><span class="tag">Raspberry Pi</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag">29</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TensorFlow/"><span class="tag">TensorFlow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tokio/"><span class="tag">Tokio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZMQ/"><span class="tag">ZMQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ctpn/"><span class="tag">ctpn</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/llama/"><span class="tag">llama</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macOS/"><span class="tag">macOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/obsidion/"><span class="tag">obsidion</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%A5%E8%AE%B0/"><span class="tag">日记</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E8%B0%88/"><span class="tag">杂谈</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B/"><span class="tag">编程</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%84%9A%E6%9C%AC/"><span class="tag">脚本</span><span class="tag">4</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a><p class="is-size-7"><span>&copy; 2024 子实</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>