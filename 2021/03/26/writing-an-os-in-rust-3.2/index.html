<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>使用Rust编写操作系统 - 3.2 - 内存分页实现 - 子实</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="子实"><meta name="msapplication-TileImage" content="/img/avatar-o.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="子实"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="使用Rust编写操作系统 - 3.2 - 内存分页实现"><meta property="og:type" content="article"><meta property="og:title" content="使用Rust编写操作系统 - 3.2 - 内存分页实现"><meta property="og:url" content="https://zlotus.github.io/2021/03/26/writing-an-os-in-rust-3.2/"><meta property="og:site_name" content="子实"><meta property="og:description" content="使用Rust编写操作系统 - 3.2 - 内存分页实现"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://os.phil-opp.com/paging-introduction/x86_64-page-table-translation.svg"><meta property="og:image" content="https://os.phil-opp.com/paging-implementation/identity-mapped-page-tables.svg"><meta property="og:image" content="https://os.phil-opp.com/paging-implementation/page-tables-mapped-at-offset.svg"><meta property="og:image" content="https://os.phil-opp.com/paging-implementation/map-complete-physical-memory.svg"><meta property="og:image" content="https://os.phil-opp.com/paging-implementation/temporarily-mapped-page-tables.svg"><meta property="og:image" content="https://os.phil-opp.com/paging-implementation/recursive-page-table.png"><meta property="og:image" content="https://os.phil-opp.com/paging-implementation/recursive-page-table-access-level-1.png"><meta property="og:image" content="https://os.phil-opp.com/paging-implementation/recursive-page-table-access-level-2.png"><meta property="og:image" content="https://os.phil-opp.com/paging-implementation/recursive-page-table-access-level-3.png"><meta property="og:image" content="https://os.phil-opp.com/paging-introduction/x86_64-table-indices-from-address.svg"><meta property="og:image" content="https://os.phil-opp.com/paging-implementation/table-indices-from-address-recursive-level-1.svg"><meta property="og:image" content="https://os.phil-opp.com/paging-implementation/table-indices-from-address-recursive-level-2.svg"><meta property="og:image" content="https://os.phil-opp.com/paging-implementation/table-indices-from-address-recursive-level-3.svg"><meta property="og:image" content="https://os.phil-opp.com/paging-implementation/table-indices-from-address-recursive-level-4.svg"><meta property="og:image" content="https://os.phil-opp.com/paging-implementation/qemu-print-level-4-table.png"><meta property="og:image" content="https://os.phil-opp.com/paging-implementation/qemu-translate-addr.png"><meta property="og:image" content="https://os.phil-opp.com/paging-implementation/qemu-mapper-translate-addr.png"><meta property="og:image" content="https://os.phil-opp.com/paging-implementation/required-page-frames-example.svg"><meta property="og:image" content="https://os.phil-opp.com/paging-implementation/qemu-new-mapping.png"><meta property="article:published_time" content="2021-03-26T09:44:00.000Z"><meta property="article:modified_time" content="2021-03-26T09:44:00.000Z"><meta property="article:author" content="子实"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Operating System"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://os.phil-opp.com/paging-introduction/x86_64-page-table-translation.svg"><meta property="twitter:creator" content="@Zealot_uS"><meta property="twitter:site" content="Zealot_uS"><link rel="publisher" href="+LotusQin"><meta property="fb:admins" content="qinzishi"><meta property="fb:app_id" content="qinzishi"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zlotus.github.io/2021/03/26/writing-an-os-in-rust-3.2/"},"headline":"使用Rust编写操作系统 - 3.2 - 内存分页实现","image":["https://os.phil-opp.com/paging-implementation/recursive-page-table.png","https://os.phil-opp.com/paging-implementation/recursive-page-table-access-level-1.png","https://os.phil-opp.com/paging-implementation/recursive-page-table-access-level-2.png","https://os.phil-opp.com/paging-implementation/recursive-page-table-access-level-3.png","https://os.phil-opp.com/paging-implementation/qemu-print-level-4-table.png","https://os.phil-opp.com/paging-implementation/qemu-translate-addr.png","https://os.phil-opp.com/paging-implementation/qemu-mapper-translate-addr.png","https://os.phil-opp.com/paging-implementation/qemu-new-mapping.png"],"datePublished":"2021-03-26T09:44:00.000Z","dateModified":"2021-03-26T09:44:00.000Z","author":{"@type":"Person","name":"子实"},"publisher":{"@type":"Organization","name":"子实","logo":{"@type":"ImageObject","url":"https://zlotus.github.io/img/opm_sq.png"}},"description":"使用Rust编写操作系统 - 3.2 - 内存分页实现"}</script><link rel="icon" href="/img/avatar-o.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/2014/07/09/about-me/">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-26T09:44:00.000Z" title="3/26/2021, 5:44:00 PM">2021-03-26</time>发表</span><span class="level-item"><time dateTime="2021-03-26T09:44:00.000Z" title="3/26/2021, 5:44:00 PM">2021-03-26</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a></span><span class="level-item">2 小时读完 (大约15754个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">使用Rust编写操作系统 - 3.2 - 内存分页实现</h1><div class="content"><article class="message message-immersive is-warning">
<div class="message-body">
<i class="fas fa-exclamation-triangle mr-2"></i>本文所有内容均为翻译，原文：<a target="_blank" rel="noopener" href="https://os.phil-opp.com/paging-implementation/">Paging Implementation</a>；原项目：<a target="_blank" rel="noopener" href="https://os.phil-opp.com/">Writing an OS in Rust</a>
</div>
</article>

<p>本文将展示如何在内核中实现对内存分页的支持。我们首先将探讨使内核可以访问物理页表帧的各种技术，并讨论它们各自的优缺点。然后，实现地址转换函数和创建新映射函数。</p>
<span id="more"></span>

<p>这个博客是在<a target="_blank" rel="noopener" href="https://github.com/phil-opp/blog_os">GitHub</a>上公开开发的。如果你有任何问题或疑问，请在那里开一个issue。你也可以在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/paging-introduction/#comments">底部</a>留言。这篇文章的完整源代码可以在<a target="_blank" rel="noopener" href="https://github.com/phil-opp/blog_os/tree/post-09">post-09</a>分支中找到。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a target="_blank" rel="noopener" href="https://os.phil-opp.com/paging-introduction/">上一篇文章</a>介绍了分页的概念，通过与分段进行比较来引入分页，解释了分页和页表的工作原理，然后介绍了<code>x86_64</code>的4级页表设计。我们发现bootloader已经为内核设置了页表层次结构，这意味着我们的内核已经在虚拟地址上运行。这有助于提高安全性，因为非法内存访问并不能修改任意物理内存，只会导致页面错误异常。</p>
<p>前文结尾我们留下一个问题——<a target="_blank" rel="noopener" href="https://os.phil-opp.com/paging-introduction/#accessing-the-page-tables">无法从内核访问页表</a>——这是因为页表存储在物理内存中，而内核已经运行在虚拟地址上。本文将在这一点上深入，探讨使内核能够访问页表帧的不同方法。我们将讨论每种方法的优缺点，然后为内核确定一种适合的方法。</p>
<p>要实现该方法，首先，我们将需要bootloader的支持，因此需要对其进行配置。然后，我们将实现一个遍历页表层次结构的函数，以将虚拟地址转换为物理地址。最后，我们将学习如何在页表中创建新的映射，以及如何找到未使用的内存帧来创建新的页表。</p>
<h2 id="访问页表的方法"><a href="#访问页表的方法" class="headerlink" title="访问页表的方法"></a>访问页表的方法</h2><p>从内核访问页表并不像看起来那样简单。为理解这个问题，让我们回顾前文的示例，4级页表层次结构：</p>
<p><img src="https://os.phil-opp.com/paging-introduction/x86_64-page-table-translation.svg" alt="x86_64页表转换"></p>
<p>这里的关键是每个页表条目都会存储下一张表的<em>物理地址</em>。这样做既避免了对这些地址再进行转换——会对性能造成不利影响——也避免了地址转换陷入无限递归。</p>
<p>对我们来说，问题在于无法直接通过内核访问物理地址，因为内核仍运行在虚拟地址上。例如，当我们访问地址<code>4 KiB</code>时，我们访问的是<em>虚拟</em>地址<code>4 KiB</code>，而不是存储第4级页表的<em>物理</em>地址<code>4 KiB</code>。当我们要访问物理地址<code>4KiB</code>时，我们只能通过映射到它的某个虚拟地址来进行访问。</p>
<p>因此，为了访问页表帧，我们需要将一些虚拟页映射到这些帧上。创建映射的方法有很多，而这些方法都允许我们访问任意页表帧。</p>
<h3 id="恒等映射"><a href="#恒等映射" class="headerlink" title="恒等映射"></a>恒等映射</h3><p>一个简单的解决方案是对所有页表进行恒等映射：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/identity-mapped-page-tables.svg" alt="恒等映射页表"></p>
<p>在上图中，我们看到了很多恒等映射的页面表帧。如此，页表的物理地址也同时是有效的虚拟地址，我们因此可以轻松地从CR3寄存器开始访问到所有级别的页表。</p>
<p>但是，它会使虚拟地址空间变得混乱，并使得找到更大尺寸的连续存储区域变得更加困难。例如，假设我们要在上图中创建一个大小为1000KiB的虚拟内存区域，比如用于<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memory-mapped_file">内存映射文件</a>。我们无法从<code>28KiB</code>开始该区域，因为它会与已经映射的页面<code>1004KiB</code>发生冲突。因此，我们必须进一步寻找，直到找到足够大的连续未映射区域，例如<code>1008KiB</code>。这是与<a target="_blank" rel="noopener" href="https://os.phil-opp.com/paging-introduction/#fragmentation">分段</a>类似的碎片问题。</p>
<p>同样，这会使得创建新的页表变得更加困难，因为我们需要为新表找到大小相称且尚未使用的物理帧。例如，假设我们为内存映射文件保留了从1008KiB开始的<code>1000KiB</code><em>虚拟</em>内存区域，于是便不能再使用<em>物理</em>地址在<code>1000KiB</code>和<code>2008KiB</code>之间的任何帧，因为无法对其进行恒等映射。</p>
<h3 id="固定偏移量映射"><a href="#固定偏移量映射" class="headerlink" title="固定偏移量映射"></a>固定偏移量映射</h3><p>为了避免使虚拟地址空间变的混乱，我们可以为<strong>页表映射划分单独的内存区域</strong>。因此，我们不再恒等映射页表帧，而将页表帧以固定偏移量映射到虚拟地址空间中。例如，偏移量可以是<code>10 TiB</code>：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/page-tables-mapped-at-offset.svg" alt="带偏移量的页表映射"></p>
<p>通过将<code>10TiB..(10TiB+物理内存大小)</code>范围内的虚拟内存地址专门用于页表映射，我们避免了恒等映射的冲突问题。只有在虚拟地址空间寻址空间远大于物理内存大小时，才可以为虚拟地址空间保留如此巨大的区域。不过这个大小在x86_64上很容易达到，因为48位虚拟地址地址的寻址空间为256TiB。</p>
<p>该方法仍然有一个缺点，就是每当我们创建一个新的页表时，都需要创建一个新的映射。另外，该方法不允许访问其他地址空间的页表，这在创建新进程时很有用。</p>
<h3 id="完整物理内存映射"><a href="#完整物理内存映射" class="headerlink" title="完整物理内存映射"></a>完整物理内存映射</h3><p>要来解决这些问题，我们不再仅映射页表帧，而是<strong>映射完整物理内存</strong>：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/map-complete-physical-memory.svg" alt="映射完整物理内存"></p>
<p>这种方法允许内核访问任意物理内存，包括其他地址空间的页表帧。保留的虚拟内存范围与以上一节相同，不同之处在于虚拟内存不再包含未映射的页面（译注：即虚拟内存空间将全部映射到物理帧）。</p>
<p>这种方法的缺点是需要额外的页表来存储物理内存的映射。这些页表需要存储在某个地方，因此它们会用掉一部分物理内存，这在内存较小的设备上可能是个问题。</p>
<p>不过，在x86_64上我们可以使用2MiB的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Page_%28computer_memory%29#Multiple_page_sizes">巨页</a>进行映射，而不是默认的4KiB页面。这样，映射32GiB内存，仅需要1个3级表和32个2级表（译注：一个2级表包含512个2MiB的巨页条目，即一个2级表可映射1GiB）总共132KiB的空间用于存储页表（译注：每页表512条目，每条目占8B空间，即每页表占4KiB空间，一共占(1+32)*4KiB=132KiB）。而且巨页还可以提升缓存效率，因为巨页在转换后备缓冲区（TLB）中使用的条目更少。</p>
<h3 id="临时映射"><a href="#临时映射" class="headerlink" title="临时映射"></a>临时映射</h3><p>对于物理内存量很小的设备，我们只能在需要访问时才临时映射页表帧。为了能够创建临时映射，我们只需要一个恒等映射的1级页表：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/temporarily-mapped-page-tables.svg" alt="临时映射页表"></p>
<p>图中的1级表控制虚拟地址空间的前2MiB（译注：512个大小为4KiB的虚拟页面）。这是因为它可以通过从CR3寄存器开始并跟随4级、3级和2级页表中的第0个条目来访问。索引为<code>8</code>的条目将地址<code>32KiB</code>上的虚拟页映射到地址<code>32KiB上</code>的物理帧，也就是恒等映射了1级表本身。图中使用<code>32KiB</code>处的水平箭头表明了此恒等映射。</p>
<p>通过写入恒等映射的1级表，我们的内核最多可以创建511个临时映射（512减去恒等映射所需的条目）。在上面的示例中，内核创建了两个临时映射：</p>
<ul>
<li>将1级表的第0个条目映射到地址为<code>24KiB</code>的帧，便创建了一个虚拟的临时映射，将<code>0​​KiB</code>处的虚拟页映射到2级页表所在的物理帧，如虚线箭头所示。</li>
<li>将1级表的第9个条目映射到地址为<code>4KiB</code>的帧，便创建了一个虚拟的临时映射，将<code>36KiB</code>处的虚拟页映射到4级页表所在的物理帧，如虚线箭头所示。</li>
</ul>
<p>现在，内核可以通过写入<code>0KiB</code>页面来访问第2级页表，以及通过写入<code>36KiB</code>页面来访问第4级页表。</p>
<p>使用临时映射访问任意页表帧的过程为：</p>
<ul>
<li>在恒等映射的1级表中搜索未使用条目。</li>
<li>将该条目映射到我们想要访问的页表所在的物理帧。</li>
<li>通过映射到该条目的虚拟页面访问目标帧。</li>
<li>将该条目设置回未使用状态，从而删除本次临时映射。</li>
</ul>
<p>这种方法重复使用相同的512个虚拟页面来创建映射，因此仅需要4KiB的物理内存。缺点是它有点麻烦，特别是因为新的映射可能需要修改多个级别的页表，这意味着我们需要将上述过程重复多次。</p>
<h3 id="递归页表"><a href="#递归页表" class="headerlink" title="递归页表"></a>递归页表</h3><p>另一个根本不需要附加页表的有趣方法是递归映射页表。这种方法的思路是将4级页表的某些条目映射到4级表本身。如此可以有效地保留一部分虚拟地址空间，并将所有当前和将来的页表帧映射到该空间。</p>
<p>让我们通过一个例子来理解该方法是如何工作的：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/recursive-page-table.png" alt="递归页表"></p>
<p>这与本文<a href="./#%E8%AE%BF%E9%97%AE%E9%A1%B5%E8%A1%A8">开头示例</a>的唯一区别是，4级表中索引511处的附加条目映射到了4级表本身的<code>4KiB</code>物理帧。</p>
<p>通过让CPU在转换中跟踪此条目，它不会到达3级表，而又回到这一4级表。这类似于调用自身的递归函数，因此此表称为<em>递归页表</em>。重要的是，CPU假定4级表中的​​每个条目都指向3级表，因此现在将4级表视为3级表。这之所以可行，是因为所有级别的表在x86_64上的布局都完全相同。</p>
<p>通过在开始实际转换之前访问一次或多次递归项，我们可以有效地减少CPU遍历的级别数。例如，如果我们只访问一次递归条目，然后进入3级表，则CPU会认为3级表是2级表。更进一步，它将2级表视为1级表，将1级表视为映射的帧。这意味着我们现在可以读写1级页表，因为CPU认为它是映射的帧。下图说明了5个翻译步骤：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/recursive-page-table-access-level-1.png" alt="递归页表访问1级页表"></p>
<p>类似的，在开始转换之前，我们可以两次访问递归项，以将遍历的级别数减少为两个：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/recursive-page-table-access-level-2.png" alt="递归页表访问2级页表"></p>
<p>让我们逐步观察改操作：首先，CPU访问4级表上的递归条目，并认为自己已到达3级表。然后，它再次访问递归条目，并认为自己已到达2级表。但实际上，CPU仍然位于4级表中。当CPU现在访问另一个条目时，它将进入在3级表，但认为自己已经在1级表上了。因此，当下一个条目指向2级表时，CPU认为它指向映射的帧，这使我们可以读写2级表。</p>
<p>访问3级和4级表的工作方式相同。为了访问3级表，我们重复访问了3次递归项，使CPU认为它已经在1级表中了。然后，我们访问另一个条目并到达第3级表，CPU将其视为映射帧。要访问4级表本身，我们只需访问递归项四次，直到CPU将4级表本身视为映射帧（下图中的蓝色）。</p>
<p><img src="https://os.phil-opp.com/paging-implementation/recursive-page-table-access-level-3.png" alt="递归页表访问3级页表"></p>
<p>你可能需要花一些时间来理解这个思路，但是在实践中却非常有效。</p>
<p>在下面的小节中，我们将解释如何构造虚拟地址以一次或多次访问递归项。我们不会在实现中使用递归分页，因此你可以跳过这一节继续阅读后文。</p>
<hr>
<h4 id="计算地址（选读）"><a href="#计算地址（选读）" class="headerlink" title="计算地址（选读）"></a>计算地址（选读）</h4><p>可以看到在实际地址转换前通过一次或多次递归地访问条目来访问所有级别的页表。由于访问这四个级别的表的索引是直接从虚拟地址中派生的，因此我们需要为此方法构造特殊的虚拟地址。请记住，页表索引是通过以下方式从虚拟地址中派生的：</p>
<p><img src="https://os.phil-opp.com/paging-introduction/x86_64-table-indices-from-address.svg" alt="虚拟地址中的x86_64页表索引"></p>
<p>假设我们要访问映射特定页面的1级页表。如上所述，这意味着在继续执行4级，3级和2级索引之前，我们必须访问一次递归项。为此，我们将地址的每个块向右移动一个块，并将原始4级索引设置为递归索引：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/table-indices-from-address-recursive-level-1.svg" alt="1级递归地址的页表索引"></p>
<p>为了访问2级表，我们将每个索引块向右移动两个块，并将原始4级索引和原始3级索引的块都设置为递归索引：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/table-indices-from-address-recursive-level-2.svg" alt="2级递归地址的页表索引"></p>
<p>通过将每个块向右移动三个块并对原始4级，3级和2级地址块使用递归索引，便可以访问3级页表：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/table-indices-from-address-recursive-level-3.svg" alt="3级递归地址的页表索引"></p>
<p>最后，我们可以通过将每个块向右移动四个块并使用除偏移量以外的所有地址块作为递归索引来访问4级表：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/table-indices-from-address-recursive-level-4.svg" alt="4级递归地址的页表索引"></p>
<p>现在就可以计算全部四个级别的页表的虚拟地址了。我们甚至可以通过将其索引乘以8（页面表条目的大小）来计算精确指向特定页面表条目的地址。</p>
<p>下表总结了用于访问不同级别页表帧的地址结构：</p>
<table>
<thead>
<tr>
<th>用于访问</th>
<th>虚拟地址结构(<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Octal">八进制</a>)</th>
</tr>
</thead>
<tbody><tr>
<td>页</td>
<td><code>0o_SSSSSS_AAA_BBB_CCC_DDD_EEEE</code></td>
</tr>
<tr>
<td>1级页表项</td>
<td><code>0o_SSSSSS_RRR_AAA_BBB_CCC_DDDD</code></td>
</tr>
<tr>
<td>2级页表项</td>
<td><code>0o_SSSSSS_RRR_RRR_AAA_BBB_CCCC</code></td>
</tr>
<tr>
<td>3级页表项</td>
<td><code>0o_SSSSSS_RRR_RRR_RRR_AAA_BBBB</code></td>
</tr>
<tr>
<td>4级页表项</td>
<td><code>0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA</code></td>
</tr>
</tbody></table>
<p>其中<code>AAA</code>是4级索引，<code>BBB</code>是3级索引，<code>CCC</code>是2级索引，<code>DDD</code>是映射帧的1级索引，而<code>EEEE</code>是映射帧的偏移量。<code>RRR</code>是递归条目的索引。当索引（三位数，译注：9位二进制数转换为3位八进制数）转换为偏移量（四位数，译注：12位二进制偏移地址转换为4位八进制数）时，可以通过将其乘以8（页表项的大小，译注：八进制下乘八相当于左移一位）来完成。有了这样的偏移量，结果地址就直接指向相应的页表条目。</p>
<p><code>SSSSSS</code>是符号扩展位，这意味着它们都是第47位的副本。这是对x86_64架构上有效地址的特殊要求。我们在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/paging-introduction/#paging-on-x86-64">上一篇文章</a>中对此进行了解释。</p>
<p>之所以使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Octal">八进制</a>表示地址，是因为每个八进制字符表示三个位，这使我们可以清楚地区分不同页表级别的9位索引。对于每个字符代表四个位的十六进制来说是不可能的。</p>
<h5 id="用Rust代码实现"><a href="#用Rust代码实现" class="headerlink" title="用Rust代码实现"></a><em>用Rust代码实现</em></h5><p>要在Rust代码中构造这样的地址，可以使用位运算：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希望访问的指定页表的虚拟地址</span></span><br><span class="line"><span class="keyword">let</span> addr: <span class="built_in">usize</span> = […];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r = <span class="number">0o777</span>; <span class="comment">// 递归索引</span></span><br><span class="line"><span class="keyword">let</span> sign = <span class="number">0o177777</span> &lt;&lt; <span class="number">48</span>; <span class="comment">// 符号扩展位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算希望转换的页表索引</span></span><br><span class="line"><span class="keyword">let</span> l4_idx = (addr &gt;&gt; <span class="number">39</span>) &amp; <span class="number">0o777</span>; <span class="comment">// 4级索引</span></span><br><span class="line"><span class="keyword">let</span> l3_idx = (addr &gt;&gt; <span class="number">30</span>) &amp; <span class="number">0o777</span>; <span class="comment">// 3级索引</span></span><br><span class="line"><span class="keyword">let</span> l2_idx = (addr &gt;&gt; <span class="number">21</span>) &amp; <span class="number">0o777</span>; <span class="comment">// 2级索引</span></span><br><span class="line"><span class="keyword">let</span> l1_idx = (addr &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0o777</span>; <span class="comment">// 1级索引</span></span><br><span class="line"><span class="keyword">let</span> page_offset = addr &amp; <span class="number">0o7777</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算页表地址</span></span><br><span class="line"><span class="keyword">let</span> level_4_table_addr =</span><br><span class="line">    sign | (r &lt;&lt; <span class="number">39</span>) | (r &lt;&lt; <span class="number">30</span>) | (r &lt;&lt; <span class="number">21</span>) | (r &lt;&lt; <span class="number">12</span>);</span><br><span class="line"><span class="keyword">let</span> level_3_table_addr =</span><br><span class="line">    sign | (r &lt;&lt; <span class="number">39</span>) | (r &lt;&lt; <span class="number">30</span>) | (r &lt;&lt; <span class="number">21</span>) | (l4_idx &lt;&lt; <span class="number">12</span>);</span><br><span class="line"><span class="keyword">let</span> level_2_table_addr =</span><br><span class="line">    sign | (r &lt;&lt; <span class="number">39</span>) | (r &lt;&lt; <span class="number">30</span>) | (l4_idx &lt;&lt; <span class="number">21</span>) | (l3_idx &lt;&lt; <span class="number">12</span>);</span><br><span class="line"><span class="keyword">let</span> level_1_table_addr =</span><br><span class="line">    sign | (r &lt;&lt; <span class="number">39</span>) | (l4_idx &lt;&lt; <span class="number">30</span>) | (l3_idx &lt;&lt; <span class="number">21</span>) | (l2_idx &lt;&lt; <span class="number">12</span>);</span><br></pre></td></tr></table></figure>

<p>上面的代码假定递归映射条目的索引为<code>0o777</code>，即最后一个4级条目511。不过目前情况并非如此，因此代码尚无法工作。请参阅下文，了解如何告诉bootloader设置递归映射。</p>
<p>除了手动执行按位运算之外，还可以使用<code>x86_64</code>crate的<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/mapper/struct.RecursivePageTable.html"><code>RecursivePageTable</code></a>类型，该类型为各种页表操作提供安全的抽象。例如，以下代码展示了如何将虚拟地址转换为其映射的物理地址：</p>
<figure class="highlight rust"><figcaption><span>in src/memory.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> x86_64::structures::paging::&#123;Mapper, Page, PageTable, RecursivePageTable&#125;;</span><br><span class="line"><span class="keyword">use</span> x86_64::&#123;VirtAddr, PhysAddr&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 为4级页表创建`RecursivePageTable`实例</span></span><br><span class="line"><span class="keyword">let</span> level_4_table_addr = […];</span><br><span class="line"><span class="keyword">let</span> level_4_table_ptr = level_4_table_addr <span class="keyword">as</span> *<span class="keyword">mut</span> PageTable;</span><br><span class="line"><span class="keyword">let</span> recursive_page_table = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> level_4_table = &amp;<span class="keyword">mut</span> *level_4_table_ptr;</span><br><span class="line">    RecursivePageTable::new(level_4_table).unwrap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 为给出的虚拟地址计算物理地址</span></span><br><span class="line"><span class="keyword">let</span> addr: <span class="built_in">u64</span> = […]</span><br><span class="line"><span class="keyword">let</span> addr = VirtAddr::new(addr);</span><br><span class="line"><span class="keyword">let</span> page: Page = Page::containing_address(addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现转换</span></span><br><span class="line"><span class="keyword">let</span> frame = recursive_page_table.translate_page(page);</span><br><span class="line">frame.map(|frame| frame.start_address() + <span class="built_in">u64</span>::from(addr.page_offset()))</span><br></pre></td></tr></table></figure>

<p>与上一段代码相同，运行此代码需要有效的递归映射。使用这种映射，可以像上一个代码示例中那样计算给定的<code>level_4_table_addr</code>。</p>
<hr>
<p>递归分页是一种有趣的技术，也展示了页表中的单个映射功能有多强大。它相对容易实现，只需要极少的设置（即设置一个递归项），因此它作为我们的第一个分页实验确实是一个不错选择。</p>
<p>不过，它也有一些缺点：</p>
<ul>
<li>该方法会占用大量虚拟内存空间（512GiB，译注：即占用4级页表一个条目）。不过48位虚拟地址空间较大，这也不算是一个大问题，但这可能会导致次优的缓存行为。</li>
<li>该方法仅允许轻松访问当前活动的地址空间。通过更改递归项，仍然可以访问其他地址空间，但是需要临时映射才能切换回去。我们在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/remap-the-kernel/#overview"><em>重新映射内核</em></a>（已过时）一文中描述了如何执行此操作。</li>
<li>该方法在很大程度上依赖于x86的页表格式，可能无法在其他架构中使用。</li>
</ul>
<h2 id="Bootloader支持"><a href="#Bootloader支持" class="headerlink" title="Bootloader支持"></a>Bootloader支持</h2><p>所有这些方法在初始化时都需要对其页表进行修改。例如，需要创建物理内存的映射，或者需要递归映射4级表的条目。目前的问题是我们还没有能够访问页表的方法，因此也无法创建这些必要的的映射。</p>
<p>这意味着我们需要bootloader的帮助，该程序会创建内核运行的页表。bootloader可以访问页表，因此它可以创建我们需要的任何映射。在当前的实现中，<code>bootloader</code>crate支持上面提到的两种方法，并可以通过<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/cargo/reference/features.html#the-features-section">cargo功能</a>进行控制：</p>
<ul>
<li><code>map_physical_memory</code>特性可以将整个物理内存映射到虚拟地址空间中的某处。因此，内核可以访问所有物理内存，于是我们可以实现<a href="./#%E6%98%A0%E5%B0%84%E5%AE%8C%E6%95%B4%E7%9A%84%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98"><em>映射完整物理内存</em></a>中的方法。</li>
<li>使用<code>recursive_page_table</code>特性，bootloader将递归映射4级页表的一个条目。这允许内核按照<a href="./#%E9%80%92%E5%BD%92%E9%A1%B5%E8%A1%A8"><em>递归页表</em></a>部分中的描述访问页面表。</li>
</ul>
<p>我们为内核选择第一种方法，因为它简单，平台独立且功能更强大（还允许访问非页表帧）。为了启用所需的bootloader支持，我们将<code>map_physical_memory</code>特性添加到了<code>bootloader</code>的依赖项中：</p>
<figure class="highlight toml"><figcaption><span>in Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">bootloader</span> = &#123; version = <span class="string">&quot;0.9.8&quot;</span>, features = [<span class="string">&quot;map_physical_memory&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>

<p>启用此特性后，bootloader会将完整的物理内存映射到一些未使用的虚拟地址范围。为了将希望使用的虚拟地址范围告诉内核，引导加载程序会传递一个<em>引导信息</em>结构体。</p>
<h3 id="引导信息"><a href="#引导信息" class="headerlink" title="引导信息"></a>引导信息</h3><p><code>bootloader</code>crate定义了一个<a target="_blank" rel="noopener" href="https://docs.rs/bootloader/0.9.3/bootloader/bootinfo/struct.BootInfo.html"><code>BootInfo</code></a>结构体，包含传递给内核的所有信息。该结构体仍处于早期阶段，因此在更新为将来与<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/cargo/reference/specifying-dependencies.html#caret-requirements">语义版本不兼容</a>的bootloader版本时，可能会造成损坏。启用<code>map_physical_memory</code>特性后，它将包含<code>memory_map</code>和<code>physical_memory_offset</code>两个字段：</p>
<ul>
<li><code>memory_map</code>字段包含可用物理内存的概述。该字段告诉内核系统中有多少可用物理内存，以及哪些内存区域是为诸如VGA硬件之类的设备所保留的。可以从BIOS或UEFI固件查询内存映射，但查询只能在启动过程的早期。也正是由于这个原因，内存映射必须由bootloader提供，因为内核无法在之后检索该映射。在下文中，我们将需要内存映射。</li>
<li><code>physical_memory_offset</code>字段包含物理内存映射到虚拟地址的起始地址。通过将此偏移量添加到物理地址，即可获得相应的虚拟地址。这使我们可以从内核访问任意物理内存。</li>
</ul>
<p>bootloader将<code>BootInfo</code>结构体以<code>_start</code>函数的<code>＆&#39;static BootInfo</code>参数的形式传递给内核。我们尚未在该函数中声明此参数，按照下面的方式修改：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> bootloader::BootInfo;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>(boot_info: &amp;<span class="symbol">&#x27;static</span> BootInfo) -&gt; ! &#123; <span class="comment">// new argument</span></span><br><span class="line">    […]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面的文章中，我们一直都缺少该参数也并没有造成什么问题，因为x86_64调用约定在CPU寄存器中传递了第一个参数。因此，若不声明该参数，只会使得参数被忽略。但是，如果我们不小心使用了错误的参数类型，那将会造成问题，因为编译器并不知道我们入口点函数的正确类型签名。</p>
<h3 id="entry-point宏"><a href="#entry-point宏" class="headerlink" title="entry_point宏"></a><code>entry_point</code>宏</h3><p>由于<code>_start</code>函数是从bootloader外部调用的，因此不会检查该函数的签名。这意味着我们可以让该函数接受任意参数也不产生任何编译错误，但是函数将无法运行或在运行时导致未定义的行为。</p>
<p>为了确保入口点函数始终具有bootloader期望的正确签名，<code>bootloader</code>crate提供了<a target="_blank" rel="noopener" href="https://docs.rs/bootloader/0.6.4/bootloader/macro.entry_point.html"><code>entry_point</code></a>宏，这个宏提供了类型检查的方式来将Rust函数定义为入口点。让我们使用此宏重写入口点函数：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> bootloader::&#123;BootInfo, entry_point&#125;;</span><br><span class="line"></span><br><span class="line">entry_point!(kernel_main);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">kernel_main</span></span>(boot_info: &amp;<span class="symbol">&#x27;static</span> BootInfo) -&gt; ! &#123;</span><br><span class="line">    […]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们不再需要使用<code>extern &quot;C&quot;</code>或<code>no_mangle</code>修饰入口点，因为该宏为我们在底层定义了真正<code>_start</code>入口点。现在，<code>kernel_main</code>函数就是一个普通的的Rust函数，因此我们可以为其选择一个任意名称。重要的是对它进行类型检查，以便在我们使用错误的函数签名时（例如通过添加参数或更改参数类型）产生编译错误。</p>
<p>让我们在<code>lib.rs</code>中做出相同的更改：</p>
<figure class="highlight rust"><figcaption><span>in src/lib.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">use</span> bootloader::&#123;entry_point, BootInfo&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line">entry_point!(test_kernel_main);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Entry point for `cargo test`</span></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_kernel_main</span></span>(_boot_info: &amp;<span class="symbol">&#x27;static</span> BootInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="comment">// like before</span></span><br><span class="line">    init();</span><br><span class="line">    test_main();</span><br><span class="line">    hlt_loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于入口点仅在测试模式下使用，因此我们为本次修改的条目均添加<code>#[cfg(test)]</code>属性。此外，为了避免与<code>main.rs</code>的<code>kernel_main</code>混淆，我们也为测试入口点指定了不同的名称的函数<code>test_kernel_main</code>。目前暂时不使用<code>BootInfo</code>参数，于是我们在参数名称前添加<code>_</code>前缀以消除未使用某变量的编译警告。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>现在，我们可以访问物理内存了，也终于可以开始实现页表代码了。第一步，我们要看一下内核正在运行的当前活动页表。第二步，我们将创建一个转换函数，该函数返回给定虚拟地址所映射的物理地址。最后一步，我们将尝试修改页表以创建新的映射。</p>
<p>在开始之前，我们为代码创建一个新的<code>memory</code>模块：</p>
<figure class="highlight rust"><figcaption><span>in src/lib.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> memory;</span><br></pre></td></tr></table></figure>

<p>再为该模块创建一个空的<code>src/memory.rs</code>文件。</p>
<h3 id="访问页表"><a href="#访问页表" class="headerlink" title="访问页表"></a>访问页表</h3><p>在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/paging-introduction/#accessing-the-page-tables">上一篇文章的末尾</a>，我们试图观察内核运行的页表，但是由于无法访问<code>CR3</code>寄存器指向的物理帧而失败。现在我们将接着上一篇文章，通过创建一个<code>active_level_4_table</code>函数来返回对活动4级页表的引用：</p>
<figure class="highlight rust"><figcaption><span>in src/memory.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> x86_64::&#123;</span><br><span class="line">    structures::paging::PageTable,</span><br><span class="line">    VirtAddr,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 返回4级页表的可变引用</span></span><br><span class="line"><span class="comment">/// </span></span><br><span class="line"><span class="comment">/// 该函数为非安全，因为调用者必须保证已将完整的物理内存</span></span><br><span class="line"><span class="comment">/// 映射到偏移量为`physical_memory_offset`的虚拟内存中了。</span></span><br><span class="line"><span class="comment">/// 同时，该函数只能被调用一次，以避免产生其他`＆mut`引用（可能会造成未定义的行为）。</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">active_level_4_table</span></span>(physical_memory_offset: VirtAddr)</span><br><span class="line">    -&gt; &amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> PageTable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">use</span> x86_64::registers::control::Cr3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (level_4_table_frame, _) = Cr3::read();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> phys = level_4_table_frame.start_address();</span><br><span class="line">    <span class="keyword">let</span> virt = physical_memory_offset + phys.as_u64();</span><br><span class="line">    <span class="keyword">let</span> page_table_ptr: *<span class="keyword">mut</span> PageTable = virt.as_mut_ptr();</span><br><span class="line"></span><br><span class="line">    &amp;<span class="keyword">mut</span> *page_table_ptr <span class="comment">// unsafe</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们从<code>CR3</code>寄存器中读取活动4级表的物理帧。然后，我们获取其物理起始地址，将其转换为<code>u64</code>，再为其添加<code>physical_memory_offset</code>，以获取映射页表帧的虚拟地址。最后，我们通过<code>as_mut_ptr</code>方法将虚拟地址转换为<code>*mut PageTable</code>裸指针，再为该指针非安全地创建<code>＆mut PageTable</code>引用。创建<code>＆mut</code>引用而非<code>＆</code>引用，是因为我们将在下文对页面表进行修改。</p>
<p>这里不需要使用非安全块，因为Rust会将<code>unsafe fn</code>函数体当做一个大型<code>unsafe</code>块来对待。这会使代码更加危险，可能稍不注意就会在前几行中意外引入非安全操作。这也使发现非安全操作变得更加困难。目前有一个<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rfcs/pull/2585">RFC</a>提出对此行为的修改。</p>
<p>现在，我们可以使用此函数来打印4级表的条目：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">kernel_main</span></span>(boot_info: &amp;<span class="symbol">&#x27;static</span> BootInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">use</span> blog_os::memory::active_level_4_table;</span><br><span class="line">    <span class="keyword">use</span> x86_64::VirtAddr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello World&#123;&#125;&quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    blog_os::init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> phys_mem_offset = VirtAddr::new(boot_info.physical_memory_offset);</span><br><span class="line">    <span class="keyword">let</span> l4_table = <span class="keyword">unsafe</span> &#123; active_level_4_table(phys_mem_offset) &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, entry) <span class="keyword">in</span> l4_table.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> !entry.is_unused() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;L4 Entry &#123;&#125;: &#123;:?&#125;&quot;</span>, i, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">    <span class="meta">#[cfg(test)]</span></span><br><span class="line">    test_main();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;It did not crash!&quot;</span>);</span><br><span class="line">    blog_os::hlt_loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们将<code>BootInfo</code>结构体重的<code>physical_memory_offset</code>字段转换为<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/addr/struct.VirtAddr.html"><code>VirtAddr</code></a>，再传给<code>active_level_4_table</code>函数。然后，使用<code>iter</code>函数迭代页表条目，并使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.enumerate"><code>enumerate</code></a>函数为每个元素添加遍历索引<code>i</code>。我们仅打印非空条目，因为全部512个条目无法一起显示在屏幕上。</p>
<p>运行可以看到以下输出：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/qemu-print-level-4-table.png" alt="QEMU打印4级页表"></p>
<p>我们看到了多个非空条目，它们都映射到不同的3级表。因为内核代码、内核堆栈、物理内存映射和引导信息都会使用单独的内存区域。</p>
<p>为了进一步遍历页表并查看第3级表，我们可以将条目的映射帧再次转换为虚拟地址：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> x86_64::structures::paging::PageTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !entry.is_unused() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;L4 Entry &#123;&#125;: &#123;:?&#125;&quot;</span>, i, entry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取物理地址条目并再次转换</span></span><br><span class="line">    <span class="keyword">let</span> phys = entry.frame().unwrap().start_address();</span><br><span class="line">    <span class="keyword">let</span> virt = phys.as_u64() + boot_info.physical_memory_offset;</span><br><span class="line">    <span class="keyword">let</span> ptr = VirtAddr::new(virt).as_mut_ptr();</span><br><span class="line">    <span class="keyword">let</span> l3_table: &amp;PageTable = <span class="keyword">unsafe</span> &#123; &amp;*ptr &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印3级表的非空条目</span></span><br><span class="line">    <span class="comment">// print non-empty entries of the level 3 table</span></span><br><span class="line">    <span class="keyword">for</span> (i, entry) <span class="keyword">in</span> l3_table.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> !entry.is_unused() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;  L3 Entry &#123;&#125;: &#123;:?&#125;&quot;</span>, i, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于查看2级和1级表，只需对3级和2级条目重复该过程即可。你可以想象，这很快就会变得非常冗长，因此我们在这里不显示完整的代码。</p>
<p>手动遍历页表很有趣，因为它有助于了解CPU如何执行转换。但是，大多数时候我们只对给定虚拟地址的映射物理地址感兴趣，因此让我们为其创建一个函数。</p>
<h3 id="转换地址"><a href="#转换地址" class="headerlink" title="转换地址"></a>转换地址</h3><p>为了将虚拟地址转换为物理地址，我们必须遍历全部四级页表，直到到达映射的帧为止。让我们创建一个执行此转换的函数：</p>
<figure class="highlight rust"><figcaption><span>in src/memory.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> x86_64::PhysAddr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 将指定的虚拟地址转换为映射的物理地址，如果该地址未被映射则返回`None`。</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// 该函数为非安全，因为调用者必须保证已将完整的物理内存</span></span><br><span class="line"><span class="comment">/// 映射到偏移量为`physical_memory_offset`的虚拟内存中了。</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">translate_addr</span></span>(addr: VirtAddr, physical_memory_offset: VirtAddr)</span><br><span class="line">    -&gt; <span class="built_in">Option</span>&lt;PhysAddr&gt;</span><br><span class="line">&#123;</span><br><span class="line">    translate_addr_inner(addr, physical_memory_offset)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再将该函数传递给安全函数<code>translate_addr_inner</code>，以限制非安全操作的范围。前面提到，Rust会将<code>unsafe fn</code>函数体当做一个大型<code>unsafe</code>块来对待。因此，通过调用私有安全函数，可以再次明确每个不安全操作。</p>
<p>其中的私有函数包含实际的实现细节：</p>
<figure class="highlight rust"><figcaption><span>in src/memory.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// `translate_addr`调用的私有函数</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// 该函数可以安全地限制`unsafe`操作的范围，因为Rust将非安全函数整体视为非安全块。</span></span><br><span class="line"><span class="comment">/// 该函数只能通过该模块外部的`unsafe fn`来访问。</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">translate_addr_inner</span></span>(addr: VirtAddr, physical_memory_offset: VirtAddr)</span><br><span class="line">    -&gt; <span class="built_in">Option</span>&lt;PhysAddr&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">use</span> x86_64::structures::paging::page_table::FrameError;</span><br><span class="line">    <span class="keyword">use</span> x86_64::registers::control::Cr3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从CR3寄存器中读取活动的4级帧</span></span><br><span class="line">    <span class="keyword">let</span> (level_4_table_frame, _) = Cr3::read();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> table_indexes = [</span><br><span class="line">        addr.p4_index(), addr.p3_index(), addr.p2_index(), addr.p1_index()</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> frame = level_4_table_frame;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历多级页表</span></span><br><span class="line">    <span class="keyword">for</span> &amp;index <span class="keyword">in</span> &amp;table_indexes &#123;</span><br><span class="line">        <span class="comment">// 将帧转换为页表的引用</span></span><br><span class="line">        <span class="keyword">let</span> virt = physical_memory_offset + frame.start_address().as_u64();</span><br><span class="line">        <span class="keyword">let</span> table_ptr: *<span class="keyword">const</span> PageTable = virt.as_ptr();</span><br><span class="line">        <span class="keyword">let</span> table = <span class="keyword">unsafe</span> &#123;&amp;*table_ptr&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取页表条目并更新`frame`变量</span></span><br><span class="line">        <span class="keyword">let</span> entry = &amp;table[index];</span><br><span class="line">        frame = <span class="keyword">match</span> entry.frame() &#123;</span><br><span class="line">            <span class="literal">Ok</span>(frame) =&gt; frame,</span><br><span class="line">            <span class="literal">Err</span>(FrameError::FrameNotPresent) =&gt; <span class="keyword">return</span> <span class="literal">None</span>,</span><br><span class="line">            <span class="literal">Err</span>(FrameError::HugeFrame) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;huge pages not supported&quot;</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加上页偏移量得到物理地址</span></span><br><span class="line">    <span class="literal">Some</span>(frame.start_address() + <span class="built_in">u64</span>::from(addr.page_offset()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们不选择复用<code>active_level_4_table</code>函数，而是再次从<code>CR3</code>寄存器中读取4级帧。这样做可以简化此原型实现。不用担心，我们将在稍后创建一个更好的解决方案。</p>
<p><code>VirtAddr</code>结构体已经提供了用于计算进入四个级别页表的索引的方法。我们将这些索引存储在一个小的数组中，之后便可以使用<code>for</code>循环遍历页表。在循环之外，我们记录最后被访问的<code>frame</code>，以便稍后计算其物理地址。该帧在迭代时指向页表帧，并在最后一次迭代后（即在访问1级条目之后）指向映射的帧。</p>
<p>在循环内部，我们再次使用<code>physical_memory_offset</code>将帧转换为页表引用。然后，我们读取当前页表的条目，并使用<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/page_table/struct.PageTableEntry.html#method.frame"><code>PageTableEntry::frame</code></a>函数检索映射的帧。如果条目未映射到帧，则返回<code>None</code>。如果条目映射到2MiB或1GiB的巨页，则产生panic。</p>
<p>让我们通过转换一些地址来测试转换函数：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">kernel_main</span></span>(boot_info: &amp;<span class="symbol">&#x27;static</span> BootInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="comment">// new import</span></span><br><span class="line">    <span class="keyword">use</span> blog_os::memory::translate_addr;</span><br><span class="line"></span><br><span class="line">    […] <span class="comment">// hello world and blog_os::init</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> phys_mem_offset = VirtAddr::new(boot_info.physical_memory_offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> addresses = [</span><br><span class="line">        <span class="comment">// 恒等映射VGA缓冲区页</span></span><br><span class="line">        <span class="number">0xb8000</span>,</span><br><span class="line">        <span class="comment">// 某代码页</span></span><br><span class="line">        <span class="number">0x201008</span>,</span><br><span class="line">        <span class="comment">// 某栈页</span></span><br><span class="line">        <span class="number">0x0100_0020_1a10</span>,</span><br><span class="line">        <span class="comment">// 映射到物理地址0的虚拟地址</span></span><br><span class="line">        boot_info.physical_memory_offset,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;address <span class="keyword">in</span> &amp;addresses &#123;</span><br><span class="line">        <span class="keyword">let</span> virt = VirtAddr::new(address);</span><br><span class="line">        <span class="keyword">let</span> phys = <span class="keyword">unsafe</span> &#123; translate_addr(virt, phys_mem_offset) &#125;;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; -&gt; &#123;:?&#125;&quot;</span>, virt, phys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    […] <span class="comment">// test_main(), &quot;it did not crash&quot; printing, and hlt_loop()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行可以看到以下输出：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/qemu-translate-addr.png" alt="QEMU地址转换"></p>
<p>如预期的那样，恒等映射的地址<code>0xb8000</code>转换为相同的物理地址。代码页和栈页转换为一些随机的物理地址，这取决于bootloader如何为内核创建初始映射。值得注意的是，转换后的最后12位（译注：在图中的十六进制体现为最后3位）始终保持不变，这是合理的，因为这些位是<a target="_blank" rel="noopener" href="https://os.phil-opp.com/paging-introduction/#paging-on-x86-64"><em>页面偏移量</em></a>，而不是被转换地址的一部分。</p>
<p>由于可以通过加上<code>physical_memory_offset</code>来访问每个物理地址，因此<code>physical_memory_offset</code>地址本身的转换应指向物理地址<code>0</code>。但是，转换失败，因为该映射使用巨页来提高效率，但我们的实现尚不支持巨页。</p>
<h3 id="使用OffsetPageTable"><a href="#使用OffsetPageTable" class="headerlink" title="使用OffsetPageTable"></a>使用<code>OffsetPageTable</code></h3><p>将虚拟地址转换为物理地址是OS内核中的常见任务，因此<code>x86_64</code>crate为其提供了一种抽象。该实现已经支持巨页和除<code>translate_addr</code>之外的其他几个页表函数，因此下文将使用该抽象进行操作，而不是在我们自己的实现中手动添加对巨页的支持。</p>
<p>该抽象基于两个trait，它们定义了各种页表映射函数：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/mapper/trait.Mapper.html"><code>Mapper</code></a> trait的泛型约束为<code>PageSize</code>，它提供操作页面的函数。例如：<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/mapper/trait.Mapper.html#tymethod.translate_page"><code>translate_page</code></a>用于将给定页面转换为其相应大小的帧，<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/mapper/trait.Mapper.html#method.map_to"><code>map_to</code></a>函数在页表中创建新的映射。</li>
<li><a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/mapper/trait.Translate.html"><code>Translate</code></a> trait提供了适用于多种页面大小的函数，例如<code>translate_addr</code>或普通<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/mapper/trait.Translate.html"><code>translate</code></a>。</li>
</ul>
<p>trait仅定义了接口，并未提供任何实现。<code>x86_64</code>crate当前提供三种类型，这些类型按照不同需求实现了这些trait。<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/mapper/struct.OffsetPageTable.html"><code>OffsetPageTable</code></a>类型假定完整的物理内存以某个偏移量全部映射到虚拟地址空间。<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/mapper/struct.MappedPageTable.html"><code>MappedPageTable</code></a>更加灵活一些：它只假定每个页表帧均被映射到了一个位于虚拟地址空间中的可计算地址。最后，可以使用<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/mapper/struct.RecursivePageTable.html"><code>RecursivePageTable</code></a>类型通过<a href="./#%E9%80%92%E5%BD%92%E9%A1%B5%E8%A1%A8">递归页表</a>访问页表帧。</p>
<p>对我们来说，bootloader将完整的物理内存映射到附加<code>physical_memory_offset</code>偏移量的虚拟地址，因此我们可以使用<code>OffsetPageTable</code>类型。要初始化该类型，我们在内存模块中创建一个新的<code>init</code>函数：</p>
<figure class="highlight rust"><figcaption><span>in src/memory.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> x86_64::structures::paging::OffsetPageTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化OffsetPageTable</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// 该函数为非安全，因为调用者必须保证已将完整的物理内存</span></span><br><span class="line"><span class="comment">/// 映射到偏移量为`physical_memory_offset`的虚拟内存中了。</span></span><br><span class="line"><span class="comment">/// 同时，该函数只能被调用一次，以避免产生其他`＆mut`引用（可能会造成未定义的行为）。</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">init</span></span>(physical_memory_offset: VirtAddr) -&gt; OffsetPageTable&lt;<span class="symbol">&#x27;static</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> level_4_table = active_level_4_table(physical_memory_offset);</span><br><span class="line">    OffsetPageTable::new(level_4_table, physical_memory_offset)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make private</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">active_level_4_table</span></span>(physical_memory_offset: VirtAddr)</span><br><span class="line">    -&gt; &amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> PageTable</span><br><span class="line">&#123;…&#125;</span><br></pre></td></tr></table></figure>

<p>该函数将<code>physical_memory_offset</code>作为参数，新建并返回一个具有<code>&#39;static</code>生命周期的<code>OffsetPageTable</code>实例。这意味着该实例在内核的完整运行时始终保持有效。在函数主体中，我们首先调用<code>active_level_4_table</code>函数获取4级页表的可变引用。然后，我们将此引用作为第一个参数传递给<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/mapper/struct.OffsetPageTable.html#method.new"><code>OffsetPageTable::new</code></a>函数。我们使用<code>physical_memory_offset</code>变量作为第二个参数传递给<code>new</code>函数，该参数期望得到虚拟地址映射到物理地址的起点（译注：即虚拟地址映射到物理地址时附加的偏移量）。</p>
<p>从现在开始，仅应从<code>init</code>函数调用<code>active_level_4_table</code>函数，因为当多次调用它时，很容使可变的引用产生多个别名，而这可能会导致未定义的行为。因此，应通过删除<code>pub</code>关键字来使该函数变为私有。</p>
<p>现在，我们可以使用<code>Translate::translate_addr</code>方法来代替我们自己的<code>memory::translate_addr</code>函数。只需要在<code>kernel_main</code>中做几行更改：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">kernel_main</span></span>(boot_info: &amp;<span class="symbol">&#x27;static</span> BootInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="comment">// new: different imports</span></span><br><span class="line">    <span class="keyword">use</span> blog_os::memory;</span><br><span class="line">    <span class="keyword">use</span> x86_64::&#123;structures::paging::Translate, VirtAddr&#125;;</span><br><span class="line"></span><br><span class="line">    […] <span class="comment">// hello world and blog_os::init</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> phys_mem_offset = VirtAddr::new(boot_info.physical_memory_offset);</span><br><span class="line">    <span class="comment">// new: initialize a mapper</span></span><br><span class="line">    <span class="keyword">let</span> mapper = <span class="keyword">unsafe</span> &#123; memory::init(phys_mem_offset) &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> addresses = […]; <span class="comment">// same as before</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;address <span class="keyword">in</span> &amp;addresses &#123;</span><br><span class="line">        <span class="keyword">let</span> virt = VirtAddr::new(address);</span><br><span class="line">        <span class="comment">// new: use the `mapper.translate_addr` method</span></span><br><span class="line">        <span class="keyword">let</span> phys = mapper.translate_addr(virt);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; -&gt; &#123;:?&#125;&quot;</span>, virt, phys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    […] <span class="comment">// test_main(), &quot;it did not crash&quot; printing, and hlt_loop()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要导入<code>Translate</code>trait以使用它提供的<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/mapper/trait.Translate.html#method.translate_addr"><code>translate_addr</code></a>方法。</p>
<p>此时运行，我们会看到与以前相同的转换结果，不同之处在于巨页也可以转换了：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/qemu-mapper-translate-addr.png" alt="QEMU使用mapper转换虚拟地址"></p>
<p>不出所料，<code>0xb8000</code>、代码地址和栈地址的转换结果与我们自己实现的转换函数相同。此外，我们现在看到虚拟地址<code>physical_memory_offset</code>映射到物理地址<code>0x0</code>。</p>
<p>通过使用<code>MappedPageTable</code>类型的转换功能，我们就没必要自己实现对巨页的支持了。另外，还可以访问其他页面函数——如<code>map_to</code>——我们将在下一节中使用。</p>
<p>现在，我们不再需要前面手动实现的<code>memory::translate_addr</code>和<code>memory::translate_addr_inner</code>函数了，因此可以将它们删除。</p>
<h3 id="创建新映射"><a href="#创建新映射" class="headerlink" title="创建新映射"></a>创建新映射</h3><p>到目前为止，我们仅查看了页表，还从未修改页表。让我们通过为先前未映射的页面创建一个新的映射来试着修改页表。</p>
<p>该操作将使用<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/mapper/trait.Mapper.html"><code>Mapper</code></a> trait的<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/mapper/trait.Mapper.html#method.map_to"><code>map_to</code></a>函数来实现，让我们首先看一下这个函数。文档说明该函数有四个参数，分别是：想要映射的页面，该页面应映射到的帧，要为该页表项设置的标志，以及<code>frame_allocator</code>。这里需要帧分配函数，是因为映射给定页面时，可能需要创建新的页表，而这个过程需要新给页表分配未使用的帧。</p>
<h4 id="一个示例函数create-example-mapping"><a href="#一个示例函数create-example-mapping" class="headerlink" title="一个示例函数create_example_mapping"></a>一个示例函数<code>create_example_mapping</code></h4><p>第一步是创建一个新的<code>create_example_mapping</code>函数，该函数将给定的虚拟页面映射到VGA文本缓冲区的物理帧<code>0xb8000</code>。我们选择该帧是因为它使我们能够轻松测试映射是否被正确创建：我们只需要对新映射的页面进行写入，就可以在屏幕上观察到写入是否成功。</p>
<p><code>create_example_mapping</code>函数如下所示：</p>
<figure class="highlight rust"><figcaption><span>in src/memory.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> x86_64::&#123;</span><br><span class="line">    PhysAddr,</span><br><span class="line">    structures::paging::&#123;Page, PhysFrame, Mapper, Size4KiB, FrameAllocator&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Creates an example mapping for the given page to frame `0xb8000`.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">create_example_mapping</span></span>(</span><br><span class="line">    page: Page,</span><br><span class="line">    mapper: &amp;<span class="keyword">mut</span> OffsetPageTable,</span><br><span class="line">    frame_allocator: &amp;<span class="keyword">mut</span> <span class="keyword">impl</span> FrameAllocator&lt;Size4KiB&gt;,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">use</span> x86_64::structures::paging::PageTableFlags <span class="keyword">as</span> Flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> frame = PhysFrame::containing_address(PhysAddr::new(<span class="number">0xb8000</span>));</span><br><span class="line">    <span class="keyword">let</span> flags = Flags::PRESENT | Flags::WRITABLE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> map_to_result = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> 不安全用法，仅演示用</span></span><br><span class="line">        mapper.map_to(page, frame, flags, frame_allocator)</span><br><span class="line">    &#125;;</span><br><span class="line">    map_to_result.expect(<span class="string">&quot;map_to failed&quot;</span>).flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了需要被映射的<code>page</code>之外，该函数还需要<code>OffsetPageTable</code>实例的可变引用和一个<code>frame_allocator</code>。<code>frame_allocator</code>参数使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters"><code>impl Trait</code></a>语法约束该<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch10-00-generics.html">泛型</a>参数必须实现<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/trait.FrameAllocator.html"><code>FrameAllocator</code></a> trait。而该trait又约束了其泛型参数必须实现<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/page/trait.PageSize.html"><code>PageSize</code></a> trait，以便同时支持4KiB标准页和2MiB/1GiB巨页。我们只想创建一个4KiB映射，因此我们将泛型参数设置为<code>Size4KiB</code>。</p>
<p><a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/mapper/trait.Mapper.html#method.map_to"><code>map_to</code></a>为非安全方法，而调用者必须确保该帧未被使用。两次映射同一帧会导致未定义行为，例如，当两个不同的<code>＆mut</code>引用指向同一物理内存位置时。在我们的例子中，确实也二次映射了已被映射的VGA文本缓冲区帧，因此打破了所需的安全条件。不过，<code>create_example_mapping</code>函数只是一个临时测试函数，在后文中将被删除，也无伤大雅。我们在该行上添加了<code>FIXME</code>注释，以提醒我们这种不安全用法。</p>
<p>除了<code>page</code>和<code>unused_frame</code>外，<code>map_to</code>方法还使用了一组用于映射的标志，和一个<code>frame_allocator</code>的引用，稍后将对此分配器进行说明。设置<code>PRESENT</code>是因为所有有效条目都需要该标志，而<code>WRITABLE</code>标志则使映射的页面可写入。关于所有可用的标志的列表，请参见上一篇文章的<a target="_blank" rel="noopener" href="https://os.phil-opp.com/paging-introduction/#page-table-format"><em>页表格式</em></a>一节。</p>
<p><a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/mapper/trait.Mapper.html#method.map_to"><code>map_to</code></a>函数可能会失败，因此它将返回一个<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/result/enum.Result.html"><code>Result</code></a>。这只是示例用代码，不需要高鲁棒性，因此我们在发生panic时仅使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/result/enum.Result.html#method.expect"><code>expect</code></a>应付。调用成功时该函数将返回<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/mapper/struct.MapperFlush.html"><code>MapperFlush</code></a>类型，该类型提供了一种调用其<a target="_blank" rel="noopener" href="https://docs.rs/x86_64/0.13.2/x86_64/structures/paging/mapper/struct.MapperFlush.html#method.flush"><code>flush</code></a>方法即可从转换后备缓冲区（TLB）中刷新新映射页面的简便方法。像<code>Result</code>一样，该类型也使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/#results-must-be-used"><code>#[must_use]</code></a>属性在我们意外忘记调用<code>flush</code>方法时发出警告。</p>
<h4 id="一个假的FrameAllocator"><a href="#一个假的FrameAllocator" class="headerlink" title="一个假的FrameAllocator"></a>一个假的<code>FrameAllocator</code></h4><p>为了能够调用<code>create_example_mapping</code>，首先需要创建一个实现了<code>FrameAllocator</code>trait的类型。如上所述，如果<code>map_to</code>需要新的帧，则该trait就负责为新页表分配帧。</p>
<p>让我们先从简单的情况入手：假设我们不需要创建新的页表。在这种情况下，这个帧分配器始终返回<code>None</code>就足够了。下面的代码创建了一个<code>EmptyFrameAllocator</code>来测试我们的映射函数：</p>
<figure class="highlight rust"><figcaption><span>in src/memory.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 一个始终返回`None`的帧分配器</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">EmptyFrameAllocator</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> FrameAllocator&lt;Size4KiB&gt; <span class="keyword">for</span> EmptyFrameAllocator &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">allocate_frame</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;PhysFrame&gt; &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FrameAllocator</code>的实现是非安全的，因为实现者必须保证分配器仅分配未使用的帧。否则，可能会发生不确定的行为，例如，当两个虚拟页面映射到同一物理帧上时。而我们的<code>EmptyFrameAllocator</code>只返回<code>None</code>，因此并不出现生这种问题。</p>
<h4 id="选择一个虚拟页面"><a href="#选择一个虚拟页面" class="headerlink" title="选择一个虚拟页面"></a>选择一个虚拟页面</h4><p>现在，我们有一个简单的帧分配器，可以将其传递给<code>create_example_mapping</code>函数了。不过这个分配器始终返回<code>None</code>，所以它也就只能用在创建映射时并不需要额外的页表帧的情况了。为了了解何时需要额外页表帧以及何时不需要额外页表帧，让我们看一个示例：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/required-page-frames-example.svg" alt="需要页表帧的例子"></p>
<p>图的左侧为虚拟地址空间，右侧为物理地址空间，中间为页表。页表如虚线所示，存储在物理存储帧中。虚拟地址空间在地址<code>0x803fe00000</code>中包含一个映射的页面，以蓝色标记。为了将此页面转换为其所在的帧，CPU遍历全部4级页表，直到到达地址为<code>36KiB</code>的帧。</p>
<p>此外，图中以红色显示VGA文本缓冲区的物理帧。我们的目标是使用<code>create_example_mapping</code>函数将先前未映射的虚拟页面映射到此帧。不过由于<code>EmptyFrameAllocator</code>始终返回<code>None</code>，我们自然希望创建映射时不会用到该类型来分配额外的帧。而这取决于我们为映射选择的虚拟页面。</p>
<p>图中以黄色标记了虚拟地址空间中的两个候选页面，一个位于地址<code>0x803fdfd000</code>，就在被映射页（蓝色）之前3页。该地址的4级和3级页表索引与蓝页相同（译注：索引为别为1、0），但2级和1级索引却不同（参阅<a target="_blank" rel="noopener" href="https://os.phil-opp.com/paging-introduction/#paging-on-x86-64">上一篇文章</a>，译注：索引分别为126、125）。2级表中的索引不同意味着此页面使用了不同的1级表。如果我们选择该页作为我们示例中的映射，那么由于1级表尚不存在，就需要创建该表，也就需要一个额外的未使用的物理帧。而位于地址<code>0x803fe02000</code>的另一个候选页面则不存在此问题，因为它使用与蓝色页面相同的1级页表（译注：索引分别为1、0、127、2）。因此，所有必需的页表已经存在。</p>
<p> 总之，创建新映射的难度取决于我们要映射的虚拟页面。在最简单的情况下，该页面的1级页表已经存在，我们只需要写入一个条目即可。在最困难的情况下，该页面所在的内存区域中尚不存在3级表，因此我们需要首先创建新的3级表、2级表、1级表。</p>
<p>为了让<code>create_example_mapping</code>函数能够使用<code>EmptyFrameAllocator</code>类型，我们需要选择一个所有页表均已存在的页面。要找到这样的页面，我们可以利用bootloader会将自身加载到虚拟地址空间的第一个兆字节中这一行为。这意味着该区域的所有页面都存在一个有效的1级表。因此，我们可以在此内存区域中选择任何未使用的页面作为示例映射，比如选择地址为<code>0</code>的页面。通常，该页面应保持未使用状态，以确保解引用空指针会导致页面错误，因此我们知道bootloader将该地址保留为未映射状态。</p>
<h4 id="创建映射"><a href="#创建映射" class="headerlink" title="创建映射"></a>创建映射</h4><p>至此，我们准备好了<code>create_example_mapping</code>函数所需的所有参赛，现在可以修改<code>kernel_main</code>函数，以将映射位于虚拟地址<code>0</code>的页面。由于我们会将页面映射到VGA文本缓冲区的帧上，那么也应该也能够通过该页面写在屏幕上。实现如下：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">kernel_main</span></span>(boot_info: &amp;<span class="symbol">&#x27;static</span> BootInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">use</span> blog_os::memory;</span><br><span class="line">    <span class="keyword">use</span> x86_64::&#123;structures::paging::Page, VirtAddr&#125;; <span class="comment">// new import</span></span><br><span class="line"></span><br><span class="line">    […] <span class="comment">// hello world and blog_os::init</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> phys_mem_offset = VirtAddr::new(boot_info.physical_memory_offset);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> mapper = <span class="keyword">unsafe</span> &#123; memory::init(phys_mem_offset) &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> frame_allocator = memory::EmptyFrameAllocator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射未使用的页面</span></span><br><span class="line">    <span class="keyword">let</span> page = Page::containing_address(VirtAddr::new(<span class="number">0</span>));</span><br><span class="line">    memory::create_example_mapping(page, &amp;<span class="keyword">mut</span> mapper, &amp;<span class="keyword">mut</span> frame_allocator);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过新映射像屏幕写入字符串`New!`</span></span><br><span class="line">    <span class="keyword">let</span> page_ptr: *<span class="keyword">mut</span> <span class="built_in">u64</span> = page.start_address().as_mut_ptr();</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; page_ptr.offset(<span class="number">400</span>).write_volatile(<span class="number">0x_f021_f077_f065_f04e</span>)&#125;;</span><br><span class="line"></span><br><span class="line">    […] <span class="comment">// test_main(), &quot;it did not crash&quot; printing, and hlt_loop()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先使用<code>mapper</code>和<code>frame_allocator</code>的可变引用作为参数，调用<code>create_exmaple_mapping</code>函数，来为位于虚拟地址<code>0</code>处的页面创建映射。这会将该页面映射到VGA文本缓冲区的帧上，因此我们应该能够在屏幕上看到对其进行的任何写入。</p>
<p>然后，我们将页面转换为裸指针，并向偏移量<code>400</code>处写入一个值。我们不在页面开头进行写入，因为VGA缓冲区的首会直接被下一个<code>println</code>移出屏幕。写入值<code>0x_f021_f077_f065_f04e</code>代表字符串”<em>New!</em>“。在白色背景上。正如我们在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/vga-text-mode/#volatile"><em>“VGA文本模式”</em>一文</a>中所了解的那样，对VGA缓冲区的写操作应该是易失性的，因此我们使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.pointer.html#method.write_volatile"><code>write_volatile</code></a>方法。</p>
<p>在QEMU中运行将看到以下输出：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/qemu-new-mapping.png" alt="QEMU新的映射"></p>
<p>屏幕上的”<em>New!</em>“是通过页面<code>0</code>写入的，这意味着我们成功在页表中创建了新的映射。</p>
<p>仅因为负责虚拟地址<code>0</code>处页面的1级页表已存在，所以创建该映射才起作用。当我们尝试为尚不存在1级表的页面进行映射时，<code>map_to</code>函数将失败，因为它试图从<code>EmptyFrameAllocator</code>分配帧以创建新的页面表。当我们尝试映射页面<code>0xdeadbeaf000</code>而不是页面<code>0</code>时，就会看到这种情况：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">kernel_main</span></span>(boot_info: &amp;<span class="symbol">&#x27;static</span> BootInfo) -&gt; ! &#123;</span><br><span class="line">    […]</span><br><span class="line">    <span class="keyword">let</span> page = Page::containing_address(VirtAddr::new(<span class="number">0xdeadbeaf000</span>));</span><br><span class="line">    […]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行会出现带有以下错误信息的panic：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panicked at <span class="string">&#x27;map_to failed: FrameAllocationFailed&#x27;</span>, /…/result.rs:999:5</span><br></pre></td></tr></table></figure>

<p>要映射没有1级页表的页面，我们需要创建一个适当的<code>FrameAllocator</code>。但是，我们如何知道哪些帧未被使用，以及到底有多少物理内存可用呢？</p>
<h3 id="分配帧"><a href="#分配帧" class="headerlink" title="分配帧"></a>分配帧</h3><p>为了创建新的页表，我们需要创建一个适当的帧分配器。为此，我们使用<code>memory_map</code>，它曾作为<code>BootInfo</code>结构体的一部分传给bootloader：</p>
<figure class="highlight rust"><figcaption><span>in src/memory.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> bootloader::bootinfo::MemoryMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 一个从bootloader内存映射中返回可用帧的帧分配器</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">BootInfoFrameAllocator</span></span> &#123;</span><br><span class="line">    memory_map: &amp;<span class="symbol">&#x27;static</span> MemoryMap,</span><br><span class="line">    next: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> BootInfoFrameAllocator &#123;</span><br><span class="line">    <span class="comment">/// 从传入的内存映射中创建帧分配器</span></span><br><span class="line">    <span class="comment">/// </span></span><br><span class="line">    <span class="comment">/// 该函数为非安全，因为调用者必须确保传入的内存映射是有效的。</span></span><br><span class="line">    <span class="comment">/// 主要要求是其中所有标记为`USABLE`的帧实际上都未被使用。</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">init</span></span>(memory_map: &amp;<span class="symbol">&#x27;static</span> MemoryMap) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        BootInfoFrameAllocator &#123;</span><br><span class="line">            memory_map,</span><br><span class="line">            next: <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该结构体有两个字段：一个对bootloader传递的内存映射的<code>&#39;static</code>引用，以及一个跟踪分配器应返回的下一帧的编号的字段<code>next</code>。</p>
<p>如我们在<a href="./#%E5%BC%95%E5%AF%BC%E4%BF%A1%E6%81%AF"><em>引导信息</em></a>一节中所介绍的那样，内存映射由<code>BIOS/UEFI</code>固件提供。它只能在引导过程早期被查询，因此bootloader已经为我们调用了相应的函数。存储器映射由<a target="_blank" rel="noopener" href="https://docs.rs/bootloader/0.6.4/bootloader/bootinfo/struct.MemoryRegion.html"><code>MemoryRegion</code></a>结构体列表组成，结构体包含每个存储区域的起始地址、长度和类型（例如未使用，保留等）。</p>
<p><code>init</code>函数使用给定的内存映射初始化<code>BootInfoFrameAllocator</code>。<code>next</code>字段初始化为<code>0</code>，且该值会随着每个帧的分配而增长，以避免两次返回相同的帧。由于我们不知道内存映射的可用帧是否已在其他地方使用，因此<code>init</code>函数必须标记为<code>unsafe</code>才能要求调用者提供额外的保证。</p>
<h4 id="写一个usable-frames方法"><a href="#写一个usable-frames方法" class="headerlink" title="写一个usable_frames方法"></a>写一个<code>usable_frames</code>方法</h4><p>在实现<code>FrameAllocator</code>trait之前，我们先添加一个辅助方法，以将内存映射转换为能够返回可用帧的迭代器：</p>
<figure class="highlight rust"><figcaption><span>in src/memory.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> bootloader::bootinfo::MemoryRegionType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> BootInfoFrameAllocator &#123;</span><br><span class="line">    <span class="comment">/// 返回内存映射中可用帧的迭代器</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">usable_frames</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">impl</span> <span class="built_in">Iterator</span>&lt;Item = PhysFrame&gt; &#123;</span><br><span class="line">        <span class="comment">// 获取内存映射中的可用区域</span></span><br><span class="line">        <span class="keyword">let</span> regions = <span class="keyword">self</span>.memory_map.iter();</span><br><span class="line">        <span class="keyword">let</span> usable_regions = regions</span><br><span class="line">            .filter(|r| r.region_type == MemoryRegionType::Usable);</span><br><span class="line">        <span class="comment">// 将各区域化为其地址范围</span></span><br><span class="line">        <span class="keyword">let</span> addr_ranges = usable_regions</span><br><span class="line">            .map(|r| r.range.start_addr()..r.range.end_addr());</span><br><span class="line">        <span class="comment">// 将这些帧的起始地址化为迭代器</span></span><br><span class="line">        <span class="keyword">let</span> frame_addresses = addr_ranges.flat_map(|r| r.step_by(<span class="number">4096</span>));</span><br><span class="line">        <span class="comment">// 使用这些起始地址创建`PhysFrame`类型</span></span><br><span class="line">        frame_addresses.map(|addr| PhysFrame::containing_address(PhysAddr::new(addr)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数使用组合多个迭代器的方法，将初始<code>MemoryMap</code>转换为返回可用物理帧的迭代器：</p>
<ul>
<li>首先，我们调用<code>iter</code>方法将内存映射转换为返回<a target="_blank" rel="noopener" href="https://docs.rs/bootloader/0.6.4/bootloader/bootinfo/struct.MemoryRegion.html"><code>MemoryRegions</code></a>的迭代器。</li>
<li>然后，我们使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.filter"><code>filter</code></a>方法跳过任何保留区域或别的不可用的区域。bootloader会为其创建的所有映射更新内存映射，因此内核使用的帧（代码，数据或栈）或用于存储引导信息的帧就已经被标记为<code>InUse</code>或类似的标志。因此，我们可以确定<code>Usable</code>帧不会在其他地方使用。</li>
<li>之后，我们使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.map"><code>map</code></a>组合器和Rust的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/ops/struct.Range.html">range语法</a>将内存区域的迭代器转换为地址范围的迭代器。</li>
<li>接下来，我们使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.flat_map"><code>flat_map</code></a>将地址范围转换为帧起始地址的迭代器，在这个过程中同时使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.step_by"><code>step_by</code></a>每隔4096字节选择一个地址。这是因为页面大小为4096字节（即4 KiB），每隔4096选择一个地址便得到了每个帧的起始地址。Bootloader页面会对齐所有可用的内存区域，因此我们在这里不需要任何用于对齐或舍入的代码。之所以使用<code>flat_map</code>而非<code>map</code>，是因为想要得到<code>Iterator&lt;Item = u64&gt;</code>而非<code>Iterator&lt;Item = Iterator&lt;Item = u64&gt;&gt;</code>。（译注：上一步得到的迭代器是<code>Iterator&lt;Item = Range&lt;u64&gt;&gt;</code>，因此只有使用<code>flat_map</code>将内外迭代器都打开才能操作其中的<code>u64</code>）。</li>
<li>最后，我们将起始地址转换为<code>PhysFrame</code>类型，以构造<code>Iterator&lt;Item = PhysFrame&gt;</code>。</li>
</ul>
<p>该函数的返回类型使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits"><code>impl Trait</code></a>特性。这样，我们可以指定返回值某种实现了<code>Iterator</code>trait特性且其中迭代元素类型为<code>PhysFrame</code>的类型，而无需指明具体的返回类型。注意，我们<em>无法</em>指明返回值的具体类型，因为它依赖于一个匿名的闭包。</p>
<h4 id="实现FrameAllocatortrait"><a href="#实现FrameAllocatortrait" class="headerlink" title="实现FrameAllocatortrait"></a>实现<code>FrameAllocator</code>trait</h4><p>现在我们可以实现<code>FrameAllocator</code>trait了：</p>
<figure class="highlight rust"><figcaption><span>in src/memory.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> FrameAllocator&lt;Size4KiB&gt; <span class="keyword">for</span> BootInfoFrameAllocator &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">allocate_frame</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;PhysFrame&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> frame = <span class="keyword">self</span>.usable_frames().nth(<span class="keyword">self</span>.next);</span><br><span class="line">        <span class="keyword">self</span>.next += <span class="number">1</span>;</span><br><span class="line">        frame</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先使用<code>usable_frames</code>方法从内存映射中获取可用帧的迭代器。然后，使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.nth"><code>Iterator::nth</code></a>函数获取索引为 <code>self.next</code>的帧（从而跳过第<code>(self.next-1)</code>帧）。在返回该帧之前，将<code>self.next</code>增加一，以便在下一次调用时返回下一个帧。</p>
<p>这种实现方式并不是十分理想，因为在每次分配帧时该函数都会重新创建<code>usable_frame</code>分配器。最好直接将迭代器存储为结构体的一个字段，然后，我们将不需要再调用<code>nth</code>方法，而是只需在每次分配时调用<code>next</code>。不过，这种方法的问题在于，目前还无法在结构体字段中存储<code>impl Trait</code>类型。不过在未来某一天，当Rust的<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rfcs/pull/2071"><em>named existential types</em></a>完全实现时，这个方法也许会变得可行。</p>
<h4 id="使用BootInfoFrameAllocator"><a href="#使用BootInfoFrameAllocator" class="headerlink" title="使用BootInfoFrameAllocator"></a>使用<code>BootInfoFrameAllocator</code></h4><p>现在，我们可以修改<code>kernel_main</code>函数，以传入<code>BootInfoFrameAllocator</code>实例代替原来的<code>EmptyFrameAllocator</code>实例了：</p>
<figure class="highlight rust"><figcaption><span>in src/main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">kernel_main</span></span>(boot_info: &amp;<span class="symbol">&#x27;static</span> BootInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">use</span> blog_os::memory::BootInfoFrameAllocator;</span><br><span class="line">    […]</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> frame_allocator = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        BootInfoFrameAllocator::init(&amp;boot_info.memory_map)</span><br><span class="line">    &#125;;</span><br><span class="line">    […]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用引导信息帧分配器后映射成功，我们再次看到了白底黑字的”<em>New!</em>“出现在屏幕上。在后台，<code>map_to</code>方法通过以下方式创建了缺少的页表：</p>
<ul>
<li>使用传入的<code>frame_allocator</code>分配未使用的帧。</li>
<li>将帧初始化为全零以创建一个新的空页表。</li>
<li>将更高级别的表的条目映射到该帧。</li>
<li>使用下一级表继续执行。</li>
</ul>
<p>虽然我们的<code>create_example_mapping</code>函数只是一些示例代码，但至少现在已经能够为任意页面创建新的映射了。这对于在以后的文章中进行内存的分配或多线程的实现时至关重要。</p>
<p>不过目前，我们应该先删掉<code>create_example_mapping</code>函数，以避免<a href="./#%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B%E5%87%BD%E6%95%B0create-example-mapping">上述</a>的意外调用导致的未定义的行为。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在这篇文章中，我们学习了访问页表物理帧的各种技术，包括恒等映射、完整物理内存映射、临时映射和递归页表等。接下来我们选择了映射完整的物理内存，因为它简单、可移植且功能强大。</p>
<p>如果没有页表的访问权限，我们就无法映射内核中的物理内存，因此我们需要bootloader的支持。<code>bootloader</code>crate支持通过可选的cargo特性创建我们所期望的映射。而我们所需的引导信息将以<code>&amp;BootInfo</code>参数的形式从入口点函数中传递给内核。</p>
<p>在代码实现的过程中，我们首先通过手动遍历页表的方式实现了地址转换函数，然后转而使用<code>x86_64</code>crate的<code>MappedPageTable</code>类型代替我们手写的代码。此外，我们还学习了如何在页表中创建新的映射，以及如何在bootloader传入的内存映射之上创建必要的<code>FrameAllocator</code>。</p>
<h2 id="下期预告"><a href="#下期预告" class="headerlink" title="下期预告"></a>下期预告</h2><p>下一篇文章将为我们的内核创建一个堆内存区域，这将使我们能够<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/boxed/struct.Box.html">分配内存</a>并使用各种<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/collections/index.html">集合类型</a>。</p>
<h2 id="支持本项目"><a href="#支持本项目" class="headerlink" title="支持本项目"></a>支持本项目</h2><p>创建和<a target="_blank" rel="noopener" href="https://os.phil-opp.com/status-update/">维护</a>这个博客和相关库是一项繁重的工作，但我真的很喜欢。通过支持我，您可以让我在新内容、新功能和持续维护上投入更多时间。</p>
<p>支持我的最好方式是<a target="_blank" rel="noopener" href="https://github.com/sponsors/phil-opp">在GitHub上赞助我</a>，因为他们不收取任何中间费用。如果你喜欢其他平台，我也有<a target="_blank" rel="noopener" href="https://www.patreon.com/phil_opp">Patreon</a>和<a target="_blank" rel="noopener" href="https://donorbox.org/phil-opp">Donorbox</a>账户。后者是最灵活的，因为它支持多种货币和一次性捐款。</p>
<p>感谢您的支持！</p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Rust/">Rust</a><a class="link-muted mr-2" rel="tag" href="/tags/Operating-System/">Operating System</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatpay.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/04/01/writing-an-os-in-rust-3.3/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">使用Rust编写操作系统 - 3.3 - 内存堆分配</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/03/21/writing-an-os-in-rust-3.1/"><span class="level-item">使用Rust编写操作系统 - 3.1 - 内存分页简介</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><script src="https://utteranc.es/client.js" repo="zlotus/comment" issue-term="pathname" label="some-issue-label" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/opm_sq.png" alt="子实"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">子实</p><p class="is-size-6 is-block">程序员</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>陕西/西安</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">78</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">22</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zlotus" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zlotus"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com/qinzishi"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/Zealot_uS"><i class="fab fa-twitter"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.zhihu.com/people/zlotus" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Diary/"><span class="level-start"><span class="level-item">Diary</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">64</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Shell/"><span class="level-start"><span class="level-item">Shell</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Coroutines/"><span class="tag">Coroutines</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">30</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenCV/"><span class="tag">OpenCV</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Operating-System/"><span class="tag">Operating System</span><span class="tag">21</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Paper/"><span class="tag">Paper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">17</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Raspberry-Pi/"><span class="tag">Raspberry Pi</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag">29</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TensorFlow/"><span class="tag">TensorFlow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tokio/"><span class="tag">Tokio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZMQ/"><span class="tag">ZMQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ctpn/"><span class="tag">ctpn</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macOS/"><span class="tag">macOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/obsidion/"><span class="tag">obsidion</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%A5%E8%AE%B0/"><span class="tag">日记</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E8%B0%88/"><span class="tag">杂谈</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B/"><span class="tag">编程</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%84%9A%E6%9C%AC/"><span class="tag">脚本</span><span class="tag">4</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/opm_sq.png" alt="子实" height="28"></a><p class="is-size-7"><span>&copy; 2023 子实</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>